C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE USR
OBJECT MODULE PLACED IN .\Output\usr.obj
COMPILER INVOKED BY: E:\Keil_v5\C51\BIN\C51.EXE App\usr.c LARGE BROWSE INCDIR(.\StdDriver\inc;.\App) DEBUG OBJECTEXTEND 
                    -PRINT(.\List\usr.lst) TABS(2) OBJECT(.\Output\usr.obj)

line level    source

   1          
   2          #include "usr.h"
   3          
   4          
   5          struct DATA_ALARM alarm1,alarm2,alarm3;//闹钟初始值
   6          struct DATA_ALARM_ch ch_alarm1,ch_alarm2,ch_alarm3;
   7          struct DATA_TIME time;                  //时间初始值
   8          struct time_char time_ch;               //时间显示初始值
   9          
  10          
  11          
  12          unsigned char second,time1_second=0,long_flag;
  13          unsigned int delaytime =40,dc2=0,delaytime1=10,dc1=0; //20次1S
  14          unsigned char SET_Long_Flag=0,SET_Short_Flag=0,UP_Long_Flag=0,UP_Short_Flag=0,DOWN_Short_Flag=0,DOWN_Long_
             -Flag=0;
  15          unsigned char flag_display=0,display_flag_hur_min=1,SET_Short_Flag_hur_min=0;
  16          const unsigned char  dis[10] = {FD612_DISP_0,FD612_DISP_1,FD612_DISP_2,FD612_DISP_3,FD612_DISP_4,FD612_DIS
             -P_5,FD612_DISP_6,FD612_DISP_7,FD612_DISP_8,FD612_DISP_9 };
  17          //unsigned char  TEM_VALUE =1;
  18          unsigned char  ADC_TIME_Flag=0,dc_ADC=0,delaytime_ADC=20;//20次1S
  19          unsigned char display_flag_mon_day=1,SET_Short_Flag_mon_day=0,SET_Short_Flag_alarm1_flag=0,SET_Short_Flag_
             -year=0;
  20          unsigned char  flag_year_leap=0;//闰年的代表
  21          //unsigned char alarm_on_flag=0,alarm1_on_dispaly=0,alarm2_on_dispaly=0,alarm3_on_dispaly=0;
  22          unsigned char  back_TIME_Flag=0,dc_back=0,delaytime_back=20,back_first=1,voice_back=0,back_voice_Flag=0,al
             -arm_clock_flag=0,dc_alarm=0;
  23          //unsigned char alarm_flag=0,alarm_voice_flag=0,alarm3_voice_flag=0,alarm2_voice_flag=0,alarm3_flag=0,alar
             -m2_flag=0;
  24          unsigned char voice_flag=0,voice_fisrt=1,alarm_voice_flag=0;
  25          unsigned char sd_flag=0,dislay_all_flag=0,sd_mode_flag=0,sd_select_first=1;
  26          float   TEM2,TEM4;
  27          double   TEM;       //浮点类型
  28          unsigned char  ADC_Display=0,ADC_Display1=0,ADC_ONE=1;
  29          unsigned char key_first=1;
  30          unsigned char mode_select_first=1,mode_select_flag=2,hor_min_delay_time=0,mon_day_delay_time=0,mode_select
             -=0,temp_delay_time=0;
  31          UINT8 long_add_flag=0,up_down_flag=0;
  32          //UINT8 alarm_hour_long_up_down_flag=0,alarm_min_long_up_down_flag=0;
  33          UINT8 blink_flag=0,blink3_flag=0;
  34          UINT8 hour_chage_state=0,hour_12_24_flag=0,hour_pm_flag=0,alarm1_pm_flag=0,alarm2_pm_flag=0,alarm3_pm_flag
             -=0;
  35          void  mTimer0Interrupt( void ) interrupt INT_NO_TMR0 using 1                //timer0中断服务程序,使用寄存器
             -组1
  36          {                                                                           //方式3时，TH0使用Timer1的中断
             -资源
  37   1      
  38   1              TH0=0XFf;
  39   1              TL0=0X01;
  40   1              buzzer=~buzzer;
  41   1      
  42   1      
  43   1      
  44   1      }
  45          
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 2   

  46          void  mTimer1Interrupt( void ) interrupt INT_NO_TMR1 using 2                //timer1中断服务程序,使用寄存器
             -组2
  47          {                                                                           //方式3时，Timer1停止
  48   1          TH1 =0X3C;
  49   1          TL1 =0XB0; 
  50   1            dc2++;
  51   1          if(dc2==delaytime){
  52   2            second=1; 
  53   2            dc2=0;
  54   2          }  
  55   1          dc1++;
  56   1          if(dc1==delaytime1)
  57   1          {
  58   2            time1_second=1;
  59   2            dc1=0;
  60   2          }
  61   1          dc_ADC++;
  62   1          if(dc_ADC==delaytime_ADC)
  63   1          {
  64   2            ADC_TIME_Flag++;
  65   2            dc_ADC=0;
  66   2          }
  67   1          dc_back++;
  68   1          if(dc_back==delaytime_back)
  69   1          {
  70   2            back_TIME_Flag++;
  71   2            dc_back=0;
  72   2          }
  73   1          voice_back++;
  74   1          if(voice_back==delaytime_back)
  75   1          {
  76   2            back_voice_Flag++;
  77   2            voice_back=0;
  78   2          }
  79   1          dc_alarm++;
  80   1          if(dc_alarm==delaytime1)
  81   1          {
  82   2            alarm_clock_flag=1;
  83   2            dc_alarm=0;
  84   2            
  85   2          }
  86   1      #if mode_select_enable
                  mode_select++;
                  if(mode_select==delaytime_back)
                  {
                    if(flag_display==1)
                    hor_min_delay_time++;
                    if(flag_display==0)
                      mon_day_delay_time++;
              //      if(flag_display==5)
              //      temp_delay_time++;
                      mode_select=0;
                    
                  }
              #endif
 100   1      }
 101          
 102          
 103          /**
 104           *  @brief  BCD转十进制
 105           *  @param  bcd
 106           *  @return decimal
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 3   

 107           *  @note    
 108           *  @note    
 109           */
 110          UINT8 bcd_decimal(UINT8 bcd)
 111          {
 112   1      return bcd-(bcd >> 4)*6;
 113   1      }
 114          
 115          /**
 116           *  @brief  十进制转BCD
 117           *  @param  decimal
 118           *  @return bcd
 119           *  @note    
 120           *  @note    
 121           */
 122          UINT8 decimal_bcd(UINT8 decimal)
 123          {
 124   1      return  (decimal+(decimal / 10)*6);
 125   1      }
 126          
 127          
 128          /**
 129           *  @brief  判断是否是闰年
 130           *  @param  year
 131           *  @return 1代表闰年 0代表不是闰年
 132           *  @note    
 133           *  @note    
 134           */
 135          
 136          
 137          void alarm_time_init(void)
 138          {
 139   1          alarm1.hour  =12;
 140   1          alarm1.minute=0;
 141   1          alarm1.alarm_pm_flag=0;
 142   1          alarm1.alarm_on_dispaly=0;
 143   1          alarm1.alarm_flag=0;
 144   1          alarm2.hour  =12;
 145   1          alarm2.minute=0;
 146   1          alarm2.alarm_pm_flag=0;
 147   1          alarm2.alarm_on_dispaly=0;
 148   1          alarm2.alarm_flag=0;
 149   1          alarm3.hour  =12;
 150   1          alarm3.minute=0;
 151   1          alarm3.alarm_pm_flag=0;
 152   1          alarm3.alarm_on_dispaly=0;
 153   1          alarm3.alarm_flag=0;
 154   1          //buzzer=0;
 155   1      }
 156          
 157          void time0_setup(void)
 158          {
 159   1          long_flag=0;
 160   1          back_first=1;
 161   1          delaytime =40;
 162   1          second=0;
 163   1          dc2=0;
 164   1      
 165   1      
 166   1          back_TIME_Flag=0;
 167   1      #if mode_select_enable
                if(mode_select_flag==0)
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 4   

                {
              //    temp_delay_time=0; //DP1计数清0
                  mon_day_delay_time=0;
                  hor_min_delay_time=0; 
                }
              #endif
 175   1          TR0=1;
 176   1          mDelaymS(70);
 177   1          TR0=0;
 178   1          buzzer=0;
 179   1      
 180   1          back_voice_Flag=0; //唤醒功能延时重新计数
 181   1            
 182   1      }
 183          
 184          void key_statue(void)
 185          {
 186   1          from_ds1302_read_time_data( );
 187   1              
 188   1      if(alarm1.alarm_flag==0 && alarm2.alarm_flag==0&& alarm3.alarm_flag==0) {
 189   2      //set按键
 190   2        if(SET==0)
 191   2        {
 192   3          time0_setup( );
 193   3          while(!SET)
 194   3          {
 195   4        //    pm_12_24_alarm_display();
 196   4            /*SET按下时秒还在跳*/
 197   4            if(flag_display==0&&SET_Long_Flag==0)
 198   4            {
 199   5              point_blink();
 200   5            }
 201   4            
 202   4      
 203   4            if(second==1)
 204   4            {
 205   5              
 206   5              long_flag=1;
 207   5              SET_Long_Flag=1;
 208   5              if(dislay_all_flag==1){dislay_all_flag=0;sd_select_first=1;}
 209   5              switch(flag_display)
 210   5              {
 211   6                case 0:
 212   6                {
 213   7                  display_12_24_blink( );
 214   7                  break;
 215   7                }
 216   6                case 1:
 217   6                {
 218   7                      ui_mon_display();
 219   7          
 220   7                      all_blink(0,1,time.mday);
 221   7                }
 222   6                case 2:
 223   6                {
 224   7                    year_blink(0) ;         
 225   7                    break;
 226   7                }
 227   6                case 3:
 228   6                {
 229   7                  alarm_long_blink(alarm1)  ;       
 230   7                  break;
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 5   

 231   7                }
 232   6                case 4:
 233   6                {
 234   7                  alarm_long_blink(alarm2)  ;
 235   7                  break;
 236   7                }
 237   6                case 5:
 238   6                {
 239   7                  alarm_long_blink(alarm3)  ;
 240   7                  break;
 241   7                }         
 242   6              }       
 243   5              
 244   5              
 245   5            }
 246   4          }
 247   3          second=0;
 248   3          while(!SET);
 249   3          if(long_flag==0)
 250   3          {
 251   4            SET_Short_Flag=1;
 252   4            second=0;
 253   4          }
 254   3        }
 255   2      //up按键
 256   2        if(UP==0)
 257   2        {
 258   3          
 259   3          time0_setup( );
 260   3          while(!UP)
 261   3          {
 262   4          //  pm_12_24_alarm_display();
 263   4            if(SET_Long_Flag==1)
 264   4            {
 265   5             key_dislpay_up_down( );
 266   5            }
 267   4            if(second==1)
 268   4            {
 269   5              return;
 270   5              long_flag=1;
 271   5              UP_Long_Flag=1;
 272   5              long_add_flag=1;//长按时显示
 273   5              
 274   5              if(SET_Long_Flag==1)
 275   5              {
 276   6                back_TIME_Flag=0;
 277   6                if(mode_select_flag==0)
 278   6                {
 279   7                  temp_delay_time=0; //DP1计数清0
 280   7                  mon_day_delay_time=0;
 281   7                  hor_min_delay_time=0; 
 282   7                }
 283   6                switch (flag_display)
 284   6                {
 285   7                case 0:
 286   7                {
 287   8                   if(SET_Short_Flag_hur_min==1)
 288   8                   {
 289   9                     hour_long_up_down(0);
 290   9                   }
 291   8                   if(SET_Short_Flag_hur_min==2)
 292   8                   {
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 6   

 293   9      
 294   9                   min_long_up_down(0) ;
 295   9                   }             
 296   8                  break;
 297   8                }
 298   7                case 1:
 299   7                {
 300   8      
 301   8                   if(SET_Short_Flag_mon_day==0)
 302   8                   {
 303   9                      mday_long_up_down(0);
 304   9                   }  
 305   8                   if(SET_Short_Flag_mon_day==1)
 306   8                   {
 307   9                     mon_long_up_down(0);
 308   9                    
 309   9                   }             
 310   8                  break;
 311   8                }
 312   7                case 2:
 313   7                {
 314   8                  if(SET_Short_Flag_year==0)
 315   8                  year_long_up_down(0);
 316   8                  break;
 317   8                }
 318   7                case 3:
 319   7                {
 320   8                    if(SET_Short_Flag_alarm1_flag==0) 
 321   8                    {
 322   9                      alarm_hour_up_down2(1,0,&alarm1);
 323   9      
 324   9                    }   
 325   8                    if(SET_Short_Flag_alarm1_flag==1) 
 326   8                    {
 327   9                        alarm_min_up_down2(1,0,&alarm1);
 328   9      //                 alarm_min_long_up_down(1,1,alarm1);
 329   9                    }           
 330   8                  break;
 331   8                }
 332   7                case 4:
 333   7                {
 334   8                  if(SET_Short_Flag_alarm1_flag==0) 
 335   8                  {
 336   9                    alarm_hour_up_down2(1,0,&alarm2);
 337   9                  }
 338   8                  if(SET_Short_Flag_alarm1_flag==1) 
 339   8                  {
 340   9                    alarm_min_up_down2(1,0,&alarm2);
 341   9      //               alarm_min_long_up_down(2,1,alarm2);
 342   9                  }             
 343   8                  break;
 344   8                }
 345   7                case 5:
 346   7                {
 347   8                  if(SET_Short_Flag_alarm1_flag==0) 
 348   8                  {
 349   9                    alarm_hour_up_down2(1,0,&alarm3);
 350   9                  }
 351   8                  if(SET_Short_Flag_alarm1_flag==1) 
 352   8                  {
 353   9                    alarm_min_up_down2(1,0,&alarm3);
 354   9      //               alarm_min_long_up_down(3,1, alarm3);
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 7   

 355   9                  }           
 356   8                  break;
 357   8                }   
 358   7              }
 359   6      
 360   6                    
 361   6              }
 362   5            }
 363   4        
 364   4          }
 365   3      
 366   3      
 367   3          long_add_flag=0;
 368   3          second=0;
 369   3          while(!UP);
 370   3          if(long_flag==0)
 371   3          {
 372   4            UP_Short_Flag=1;
 373   4            second=0;
 374   4          }
 375   3        }
 376   2      
 377   2      //down按键
 378   2        if(DOWN==0)
 379   2        {
 380   3      
 381   3          time0_setup( );
 382   3          while(!DOWN)
 383   3          {
 384   4          //  pm_12_24_alarm_display();
 385   4            if(SET_Long_Flag==1)
 386   4            {
 387   5             key_dislpay_up_down( );
 388   5            }
 389   4            if(second==1)
 390   4            {
 391   5                back_TIME_Flag=0;
 392   5                if(mode_select_flag==0)
 393   5                {
 394   6                  temp_delay_time=0; //DP1计数清0
 395   6                  mon_day_delay_time=0;
 396   6                  hor_min_delay_time=0; 
 397   6                }
 398   5                
 399   5              long_add_flag=1;
 400   5              
 401   5              long_flag=1;
 402   5              DOWN_Long_Flag=1;
 403   5              if(SET_Long_Flag==1)
 404   5              {
 405   6                switch (flag_display)
 406   6                {
 407   7                  case 0:
 408   7                  {
 409   8                   if(SET_Short_Flag_hur_min==1)
 410   8                   {
 411   9                     hour_long_up_down(1);
 412   9                   }  
 413   8                    if(SET_Short_Flag_hur_min==2)
 414   8                   {
 415   9                    min_long_up_down(1) ;
 416   9                   }            
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 8   

 417   8                    break;
 418   8                  }
 419   7                  case 1:
 420   7                  {
 421   8      
 422   8                   if(SET_Short_Flag_mon_day==0)
 423   8                   {
 424   9                    mday_long_up_down(1);
 425   9                   }
 426   8                   if(SET_Short_Flag_mon_day==1)
 427   8                   {
 428   9                    
 429   9                     mon_long_up_down(1);
 430   9                   }             
 431   8                  
 432   8                    break;
 433   8                  }
 434   7                    case 2:
 435   7                    {
 436   8                      if(SET_Short_Flag_year==0)
 437   8                      year_long_up_down(1);
 438   8                      break;
 439   8                    }           
 440   7                  case 3:
 441   7                  {
 442   8                    if(SET_Short_Flag_alarm1_flag==0) 
 443   8                    {
 444   9      
 445   9                      alarm_hour_up_down2(1,1,&alarm1);
 446   9                      
 447   9                    }
 448   8                    if(SET_Short_Flag_alarm1_flag==1) 
 449   8                    {
 450   9      //                 alarm_min_long_up_down(1,2,alarm1);
 451   9                      alarm_min_up_down2(1,1,&alarm1);
 452   9                    }               
 453   8                    break;
 454   8                  }
 455   7                  case 4:
 456   7                  {
 457   8                    if(SET_Short_Flag_alarm1_flag==0) 
 458   8                    {
 459   9      
 460   9                      alarm_hour_up_down2(1,1,&alarm2);;
 461   9                    }
 462   8                    if(SET_Short_Flag_alarm1_flag==1) 
 463   8                    {
 464   9      //                 alarm_min_long_up_down(2,2, alarm2);
 465   9                      alarm_min_up_down2(1,1,&alarm2);
 466   9                    }             
 467   8                    break;
 468   8                  }
 469   7                  case 5:
 470   7                  {
 471   8                    if(SET_Short_Flag_alarm1_flag==0) 
 472   8                    {
 473   9      
 474   9                      alarm_hour_up_down2(1,1,&alarm3);
 475   9                    }
 476   8                    if(SET_Short_Flag_alarm1_flag==1) 
 477   8                    {
 478   9      //                 alarm_min_long_up_down(3,2, alarm3);
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 9   

 479   9                      alarm_min_up_down2(1,1,&alarm3);
 480   9                    }                       
 481   8                    break;
 482   8                  }
 483   7                  default :
 484   7                  break;
 485   7                              
 486   7                }
 487   6      
 488   6                  
 489   6              } 
 490   5              if(SET_Long_Flag==0&&ADC_ONE==1)
 491   5              {
 492   6                if(ADC_Display==0)ADC_Display=1;
 493   6                else ADC_Display=0;
 494   6                  adc_switch( );
 495   6      
 496   6                ADC_ONE=0;
 497   6              }
 498   5            }
 499   4        
 500   4          }
 501   3      
 502   3          long_add_flag=0;
 503   3          ADC_ONE=1;
 504   3          second=0;
 505   3          while(!DOWN);
 506   3          if(long_flag==0)
 507   3          {
 508   4            DOWN_Short_Flag=1;
 509   4            second=0;
 510   4          }
 511   3        }
 512   2      }
 513   1      key_off_alarm_clock(&alarm1);
 514   1      key_off_alarm_clock(&alarm2);
 515   1      key_off_alarm_clock(&alarm3);
 516   1      
 517   1      
 518   1      
 519   1      }
 520          void display(void)
 521          {
 522   1      //  UINT8 pm_flag;
 523   1          temper_display();
 524   1          from_ds1302_read_time_data( );
 525   1          if(SET_Long_Flag==0)
 526   1          {
 527   2          if(SET_Short_Flag)
 528   2          {
 529   3            flag_display++;
 530   3            SET_Short_Flag=0;
 531   3            if(flag_display>5)
 532   3            {
 533   4              flag_display=0;
 534   4      
 535   4            }
 536   3          }
 537   2      
 538   2          }
 539   1      
 540   1          switch(flag_display)
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 10  

 541   1          {
 542   2            case 0:
 543   2              {
 544   3      
 545   3                    if(display_flag_hur_min)
 546   3                    {
 547   4                        point_blink();                                                            
 548   4                    }
 549   3                    if(SET_Long_Flag)
 550   3                    {
 551   4                      key_first_into();
 552   4                      display_flag_hur_min=0;
 553   4                      if(SET_Short_Flag)
 554   4                      {
 555   5                        SET_Short_Flag_hur_min++;
 556   5                        SET_Short_Flag=0;
 557   5                        if(SET_Short_Flag_hur_min>4)
 558   5                        {
 559   6                          SET_Short_Flag_hur_min=0;
 560   6                        }
 561   5                      }
 562   4                      switch(SET_Short_Flag_hur_min)
 563   4                      {
 564   5                        case 0:
 565   5                        {
 566   6                          display_12_24_blink( ); 
 567   6                          if(UP_Short_Flag==1)
 568   6                          {
 569   7                            key_12and24_switch();
 570   7                            UP_Short_Flag=0;                                                                                  
 571   7                          }                   
 572   6                          break;
 573   6                        }
 574   5                        case 1:
 575   5                        {
 576   6                          FD612_DISPLAY_2DIG_input(2, dis[time.minute/10] ,dis[time.minute%10]);  
 577   6                          all_blink(0,1,time.hour);
 578   6                          if(UP_Short_Flag==1)
 579   6                          {                   
 580   7                              time.hour++;
 581   7                              hour_over_judge(0);
 582   7                              UP_Short_Flag=0;
 583   7                          }
 584   6                            if(DOWN_Short_Flag == 1)
 585   6                          {
 586   7                              time.hour--;  
 587   7                              hour_over_judge(1);                 
 588   7      
 589   7                              DOWN_Short_Flag = 0;
 590   7                          }                   
 591   6                          break;
 592   6                        }
 593   5                        case 2:
 594   5                        {
 595   6                            FD612_DispBuff.DispData[12]|=1<<2;
 596   6                            FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10]  ,dis[time.hour%10]);
 597   6                            all_blink(0,2,time.minute);
 598   6                            if(UP_Short_Flag == 1)
 599   6                            {
 600   7                                time.minute++;
 601   7                              if(time.minute >=60)
 602   7                              {
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 11  

 603   8                                time.minute = 0;
 604   8                              }
 605   7                                UP_Short_Flag = 0;
 606   7                              
 607   7                              Write_addr_byte_ds1302(sec_w_addr,0);
 608   7      
 609   7                            }
 610   6                            if(DOWN_Short_Flag == 1)
 611   6                            {
 612   7                                time.minute--;
 613   7                              if(time.minute>60)
 614   7                              {
 615   8                                  time.minute = time.minute -196; //溢出值
 616   8                              }
 617   7                                DOWN_Short_Flag = 0;
 618   7                                Write_addr_byte_ds1302(sec_w_addr,0);
 619   7      
 620   7      
 621   7                            }
 622   6                            time.minute = decimal_bcd(time.minute);                   
 623   6                            Write_addr_byte_ds1302(min_w_addr,time.minute);                   
 624   6                            break;
 625   6                        }
 626   5                        case 3:
 627   5                        {
 628   6                          display_flag_hur_min=1;
 629   6                          SET_Long_Flag=0;
 630   6                          SET_Short_Flag_hur_min=0;
 631   6                          key_first=1;
 632   6                          break;
 633   6                        }                 
 634   5                      }
 635   4                                                      
 636   4                      timeout_exit();
 637   4                                    
 638   4                    }
 639   3                    action_remove();
 640   3                    break;          
 641   3              }
 642   2      
 643   2              case 1:
 644   2                {
 645   3                  if(display_flag_mon_day)
 646   3                    {
 647   4                      ui_mon_display();
 648   4                      FD612_DISPLAY_2DIG_input(1,dis[time.mday/10],dis[time.mday% 10]);
 649   4                      
 650   4                    }                   
 651   3                if(SET_Long_Flag)
 652   3                {
 653   4                  key_first_into();           
 654   4                  display_flag_mon_day=0;
 655   4                
 656   4                if(SET_Short_Flag)
 657   4                      {
 658   5                        SET_Short_Flag_mon_day++;
 659   5                        SET_Short_Flag=0;
 660   5                        if(SET_Short_Flag_mon_day>2)
 661   5                        {
 662   6                          SET_Short_Flag_mon_day=0;
 663   6                        }
 664   5                      }
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 12  

 665   4                  switch(SET_Short_Flag_mon_day)
 666   4                    {
 667   5                      case 0:
 668   5                      {
 669   6      //                    FD612_DISPLAY_2DIG_input(2 ,dis[time.month/10] ,dis[time.month%10] );
 670   6                              ui_mon_display();
 671   6      //                        mday_blink(0);
 672   6                        
 673   6                          all_blink(0,1,time.mday);            
 674   6                          if(UP_Short_Flag >= 1)
 675   6                          {
 676   7                              time.mday++;
 677   7                                                   
 678   7                              mon_over_judge();
 679   7                            UP_Short_Flag = 0;            
 680   7                          } 
 681   6                          if(DOWN_Short_Flag >= 1)
 682   6                          {
 683   7                              time.mday--;
 684   7                              mon_over_judge();                     
 685   7                                                                                        
 686   7                              DOWN_Short_Flag = 0;
 687   7                          }         
 688   6                          time.mday = decimal_bcd(time.mday);
 689   6                          Write_addr_byte_ds1302(day_w_addr,time.mday);                 
 690   6                          break;
 691   6                      }
 692   5                      case 1:
 693   5                      {
 694   6                          FD612_DISPLAY_2DIG_input(1,dis[time.mday/10] ,dis[time.mday%10] );
 695   6                          if(time1_second)
 696   6                          {
 697   7                          if(blink_flag)
 698   7                          {
 699   8                            blink_flag=0; 
 700   8                              ui_mon_display();
 701   8                          }
 702   7                          else
 703   7                          {
 704   8                            blink_flag=1;
 705   8                            FD612_DISPLAY_2DIG_input(2 ,0x00  ,0x00 );
 706   8                          }
 707   7                          time1_second=0;
 708   7                          }
 709   6                          if(UP_Short_Flag == 1)
 710   6                          {
 711   7                              time.month++;
 712   7                              mday_over_judge();
 713   7                              UP_Short_Flag = 0;
 714   7                          }
 715   6                          if(DOWN_Short_Flag == 1)
 716   6                          {
 717   7                              time.month--;
 718   7                              mday_over_judge();
 719   7                              DOWN_Short_Flag = 0;
 720   7                          } 
 721   6                          time.month = decimal_bcd(time.month);
 722   6      
 723   6                          Write_addr_byte_ds1302(mon_w_addr,time.month);                  
 724   6                          break;
 725   6                      }
 726   5                      case 2:
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 13  

 727   5                      {
 728   6                          display_flag_mon_day=1;
 729   6                          SET_Long_Flag=0;
 730   6                          SET_Short_Flag_mon_day=0;
 731   6                          key_first=1;
 732   6                          break;
 733   6                      }               
 734   5                    }
 735   4      
 736   4                      timeout_exit();             
 737   4                    }
 738   3                  if(SET_Long_Flag==0)
 739   3                  {
 740   4                    timeout_exit(); 
 741   4                  }             
 742   3      
 743   3                  action_remove();                
 744   3                  break;            
 745   3                }
 746   2              case 2:
 747   2              {
 748   3                if(SET_Long_Flag==1)
 749   3                {
 750   4                  key_first_into();
 751   4                  year_blink(0);
 752   4                if(SET_Short_Flag)
 753   4                  {
 754   5                    SET_Short_Flag_year++;
 755   5                    SET_Short_Flag=0;
 756   5                    if(SET_Short_Flag_year>1)
 757   5                    {
 758   6                      SET_Short_Flag_year=0;
 759   6                    }
 760   5                  } 
 761   4                  switch(SET_Short_Flag_year)
 762   4                  {
 763   5                    case 0:
 764   5                    {
 765   6                      if(UP_Short_Flag == 1)
 766   6                      {
 767   7                          time.year++;  
 768   7                          if(time.year>99)time.year=0;
 769   7                          UP_Short_Flag = 0;
 770   7                      }
 771   6                      if(DOWN_Short_Flag == 1)
 772   6                      {
 773   7                          time.year--;
 774   7                          DOWN_Short_Flag = 0;
 775   7                      } 
 776   6                      break;
 777   6                    }
 778   5                    case 1:
 779   5                    {                 
 780   6                        SET_Long_Flag=0;
 781   6                        SET_Short_Flag_year=0;
 782   6                        key_first=1;
 783   6      
 784   6                      break;
 785   6                      
 786   6                    }
 787   5                  }
 788   4                  time.year= decimal_bcd(time.year);
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 14  

 789   4                  Write_addr_byte_ds1302(year_w_addr,time.year);
 790   4                  timeout_exit();           
 791   4                }
 792   3                else
 793   3                {
 794   4                  FD612_display_4DIG_input( dis[2] ,dis[0] ,dis[time.year/10]  ,dis[time.year%10] );
 795   4                  timeout_exit();
 796   4                }
 797   3                action_remove();
 798   3                break;
 799   3                
 800   3              }         
 801   2              case 3:
 802   2                {
 803   3                  
 804   3                  alarm_set_display(1, &alarm1);
 805   3                  break;  
 806   3                }
 807   2              case 4:
 808   2                {
 809   3      
 810   3                  alarm_set_display(2, &alarm2);
 811   3                  break;  
 812   3                }
 813   2              case 5:
 814   2                {
 815   3      
 816   3                  alarm_set_display(3, &alarm3);
 817   3                  break;  
 818   3                }
 819   2            
 820   2      
 821   2              default :
 822   2              break;
 823   2          }
 824   1      }
 825          
 826          
 827          
 828          
 829          
 830          
 831          void  ADC_Convert(void) 
 832          {
 833   1          float VCC = 4.77;                          //
 834   1          float ADC_VALUE;                           //
 835   1                                 //
 836   1      //    unsigned int B_value = 3450;
 837   1          unsigned int B_value = 3950;//科艺传感器
 838   1      
 839   1          ADC_CHAN1 =0;
 840   1          ADC_CHAN0=0;
 841   1          P1_DIR_PU &= ~bAIN0;  
 842   1          ADC_START = 1;  
 843   1          while(ADC_START);                                                      //ADC_START变为0时，表示采样完成
 844   1          ADC_VALUE = ADC_DATA * VCC / 255; // 读取转换的AD值   
 845   1        
 846   1          TEM = 1/(log(ADC_VALUE/(VCC - ADC_VALUE))/B_value + 1/(273.15 + 25));
 847   1            
 848   1          TEM4=TEM2*1.8+32;
 849   1          TEM2=TEM- 273.15;
 850   1          
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 15  

 851   1      }
 852          
 853          #if 0
              void alarm1_sleep(void)
              {
                  UINT8 alarm1_value1,alarm1_value2,alarm1_value3,alarm1_value4,alarm1_value5;
                  if(time.second==0 && time.hour==alarm1.hour && time.minute==alarm1.minute&&hour_pm_flag==alarm1.alarm_pm
             -_flag)
                  {
                    alarm_flag=1;
                    alarm_voice_flag=1;
                  }
                  if(alarm_flag)
                  {
                    alarm1_value1=alarm1.minute+alarm_time;
                    alarm1_value2=alarm1.minute+alarm_time+sleep_time;
                    alarm1_value3=alarm1.minute+(alarm_time*2)+sleep_time;
                    alarm1_value4=alarm1.minute+(alarm_time*2)+(sleep_time*2);
                    alarm1_value5=alarm1.minute+(alarm_time*3)+(sleep_time*2);
                    if(alarm_voice_flag)
                    {
                      
                      if(alarm_clock_flag)
                      {
                        if(TR0)
                        {TR0=0;buzzer=0;}
                        else TR0=1;
                        alarm_clock_flag=0;
                      }       
                      
                    }
                    if((alarm1_value1)>=60)
                    {
                      if((alarm1_value1-60)==time.minute)
                      {
                       TR0=0;
                       buzzer=0;
                       alarm_voice_flag=0;
                      }
                    }
                    else if((alarm1_value1)==time.minute)
                    {
                      TR0=0;
                      buzzer=0;
                      alarm_voice_flag=0;
                    }
                    if((alarm1_value2)>=60)
                    {
                      if((alarm1_value2-60)==time.minute)
                      {
                        alarm_voice_flag=1;
                      }       
                    }
                    else if(alarm1_value2==time.minute)
                    {
                      alarm_voice_flag=1;
                    }
                    if((alarm1_value3)>=60)
                    {
                      if((alarm1_value3-60)==time.minute)
                      {
                        TR0=0;
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 16  

                        buzzer=0;
                        alarm_voice_flag=0;
                      }       
                    }
                    else if((alarm1_value3)==time.minute)
                    {
                      TR0=0;
                      buzzer=0;
                      alarm_voice_flag=0;
                    }
                    if((alarm1_value4)>=60)
                    {
                      if((alarm1_value4-60)==time.minute)
                      {
                        alarm_voice_flag=1;
                      }       
                    }
                    else if((alarm1_value4)==time.minute)
                    {
                      alarm_voice_flag=1;
                    }
                    if((alarm1_value5)>=60)
                    {
                      if((alarm1_value5-60)==time.minute)
                      {
                        TR0=0;
                        buzzer=0;
                        alarm_voice_flag=0;
                      }     
                    }
                    else if((alarm1_value5)==time.minute)
                    {
                      TR0=0;
                      buzzer=0;
                      alarm_voice_flag=0;
                    }
              
                  }
              
              }
              
              void alarm2_sleep(void)
              {
                  UINT8 alarm2_value1,alarm2_value2,alarm2_value3,alarm2_value4,alarm2_value5;
                  if(time.second==0 && time.hour==alarm2.hour && time.minute==alarm2.minute&&hour_pm_flag==alarm2.alarm_pm
             -_flag)
                  {
                    alarm2_flag=1;
                    alarm2_voice_flag=1;
                  }
                  if(alarm2_flag)
                  {
                    alarm2_value1=alarm2.minute+alarm_time;
                    alarm2_value2=alarm2.minute+alarm_time+sleep_time;
                    alarm2_value3=alarm2.minute+(alarm_time*2)+sleep_time;
                    alarm2_value4=alarm2.minute+(alarm_time*2)+(sleep_time*2);
                    alarm2_value5=alarm2.minute+(alarm_time*3)+(sleep_time*2);
                    
                    if(alarm2_voice_flag)
                    {
                      if(alarm_clock_flag)
                      {
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 17  

                        if(TR0)
                        {TR0=0;buzzer=0;}
                        else TR0=1;
                        alarm_clock_flag=0;
                      }
                    }
                    if((alarm2_value1)>=60)
                    {
                      if((alarm2_value1-60)==time.minute)
                      {
                        TR0=0;
                        buzzer=0;
                        alarm2_voice_flag=0;
                      }     
                    }
                    else if((alarm2_value1)==time.minute)
                    {
                      TR0=0;
                      buzzer=0;
                      alarm2_voice_flag=0;
                    }
                    if((alarm2_value2)>=60)
                    {
                       if((alarm2_value2-60)==time.minute)
                      {
                        alarm2_voice_flag=1;
                      }
                    }
                    else if((alarm2_value2)==time.minute)
                    {
                      alarm2_voice_flag=1;
                    }
                    if((alarm2_value3)>=60)
                    {
                      if((alarm2_value3-60)>=time.minute)
                      {
                        TR0=0;
                        buzzer=0;
                        alarm2_voice_flag=0;
                      }
                    }     
                    else if((alarm2_value3)==time.minute)
                    {
                      TR0=0;
                      buzzer=0;
                      alarm2_voice_flag=0;
                    }
                    if((alarm2_value4)>=60)
                    {
                      if((alarm2_value4-60)==time.minute)
                      alarm2_voice_flag=1;
                    }     
                    else if((alarm2_value4)==time.minute)
                    {
                      alarm2_voice_flag=1;
                    }
                    if((alarm2_value5)>=60)
                    {
                    if((alarm2_value5-60)==time.minute)
                    {
                      TR0=0;
                      buzzer=0;
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 18  

                      alarm2_voice_flag=0;
                    }       
                    }
                    else if((alarm2_value5)==time.minute)
                    {
                      TR0=0;
                      buzzer=0;
                      alarm2_voice_flag=0;
                    }
              
                  }
              
              }
              
              void alarm3_sleep(void)
              {
                  UINT8 alarm3_value1,alarm3_value2,alarm3_value3,alarm3_value4,alarm3_value5;
                  if(time.second==0 && time.hour==alarm3.hour && time.minute==alarm3.minute&&hour_pm_flag==alarm3.alarm_pm
             -_flag)
                  {
                    alarm3_flag=1;
                    alarm3_voice_flag=1;
                  }
                  if(alarm3_flag)
                  {
                    alarm3_value1=alarm3.minute+alarm_time;
                    alarm3_value2=alarm3.minute+alarm_time+sleep_time;
                    alarm3_value3=alarm3.minute+(alarm_time*2)+sleep_time;
                    alarm3_value4=alarm3.minute+(alarm_time*2)+(sleep_time*2);
                    alarm3_value5=alarm3.minute+(alarm_time*3)+(sleep_time*2);
                    if(alarm3_voice_flag)
                    {
                      if(alarm_clock_flag)
                      {
                        if(TR0)
                        {TR0=0;buzzer=0;}
                        else TR0=1;
                        alarm_clock_flag=0;
                      }
                    }
                    if((alarm3_value1)>=60)
                    {
                      if((alarm3_value1-60)==time.minute)
                      {
                        TR0=0;
                        buzzer=0;
                        alarm3_voice_flag=0;
                      }       
                    }
                    else if((alarm3_value1)==time.minute)
                    {
                      TR0=0;
                      buzzer=0;
                      alarm3_voice_flag=0;
                    }
                    
                    if((alarm3_value2)>=60)
                    {
                      if((alarm3_value2-60)==time.minute)
                      {
                        alarm3_voice_flag=1;
                      }       
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 19  

                    }
                    else if((alarm3_value2)==time.minute)
                    {
                      alarm3_voice_flag=1;
                    }
                    if((alarm3_value3)>=60)
                    {
                      if((alarm3_value3-60)==time.minute)
                      {
                        TR0=0;
                        buzzer=0;
                        alarm3_voice_flag=0;
                      }       
                    }
                    else if((alarm3_value3)==time.minute)
                    {
                      TR0=0;
                      buzzer=0;
                      alarm3_voice_flag=0;
                    }
                    if((alarm3_value4)>=60)
                    {
                      if((alarm3_value4-60)==time.minute)
                      {
                        alarm3_voice_flag=1;
                      }       
                    }
                    else if((alarm3_value4)==time.minute)
                    {
                      alarm3_voice_flag=1;
                    }
                    if((alarm3_value5)>=60)
                    {
                      if((alarm3_value5-60)==time.minute)
                      {
                        TR0=0;
                        buzzer=0;
                        alarm3_voice_flag=0;
                      }       
                    }
                    else if((alarm3_value5)==time.minute)
                    {
                      TR0=0;
                      buzzer=0;
                      alarm3_voice_flag=0;
                    }
              
                  }
              
              }
              #endif
1147          void alarm_sleep_judge(struct DATA_ALARM* alarm)
1148          {
1149   1          UINT8 alarm_value1,alarm_value2,alarm_value3,alarm_value4,alarm_value5;
1150   1          if(time.second==0 && time.hour==alarm->hour && time.minute==alarm->minute&&hour_pm_flag==alarm->alarm_pm
             -_flag)
1151   1          {
1152   2            alarm->alarm_flag=1;
1153   2            alarm_voice_flag=1;     
1154   2          }
1155   1          if(alarm->alarm_flag)
1156   1          {
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 20  

1157   2            alarm_value1=alarm->minute+alarm_time;
1158   2            alarm_value2=alarm->minute+alarm_time+sleep_time;
1159   2            alarm_value3=alarm->minute+(alarm_time*2)+sleep_time;
1160   2            alarm_value4=alarm->minute+(alarm_time*2)+(sleep_time*2);
1161   2            alarm_value5=alarm->minute+(alarm_time*3)+(sleep_time*2);   
1162   2            if(alarm_voice_flag)
1163   2            {       
1164   3              if(alarm_clock_flag)
1165   3              {
1166   4                if(TR0)
1167   4                {TR0=0;buzzer=0;}
1168   4                else TR0=1;
1169   4                alarm_clock_flag=0;
1170   4              }               
1171   3            }
1172   2            if((alarm_value1)>=60)
1173   2            {
1174   3              if((alarm_value1-60)==time.minute)
1175   3              {
1176   4               TR0=0;
1177   4               buzzer=0;
1178   4               alarm_voice_flag=0;
1179   4              }
1180   3            }
1181   2            else if((alarm_value1)==time.minute)
1182   2            {
1183   3              TR0=0;
1184   3              buzzer=0;
1185   3              alarm_voice_flag=0;
1186   3            }
1187   2            if((alarm_value2)>=60)
1188   2            {
1189   3              if((alarm_value2-60)==time.minute)
1190   3              {
1191   4                alarm_voice_flag=1;
1192   4              }       
1193   3            }
1194   2            else if(alarm_value2==time.minute)
1195   2            {
1196   3              alarm_voice_flag=1;
1197   3            }
1198   2            if((alarm_value3)>=60)
1199   2            {
1200   3              if((alarm_value3-60)==time.minute)
1201   3              {
1202   4                TR0=0;
1203   4                buzzer=0;
1204   4                alarm_voice_flag=0;
1205   4              }       
1206   3            }
1207   2            else if((alarm_value3)==time.minute)
1208   2            {
1209   3              TR0=0;
1210   3              buzzer=0;
1211   3              alarm_voice_flag=0;
1212   3            }
1213   2            if((alarm_value4)>=60)
1214   2            {
1215   3              if((alarm_value4-60)==time.minute)
1216   3              {
1217   4                alarm_voice_flag=1;
1218   4              }       
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 21  

1219   3            }
1220   2            else if((alarm_value4)==time.minute)
1221   2            {
1222   3              alarm_voice_flag=1;
1223   3            }
1224   2            if((alarm_value5)>=60)
1225   2            {
1226   3              if((alarm_value5-60)==time.minute)
1227   3              {
1228   4                TR0=0;
1229   4                buzzer=0;
1230   4                alarm->alarm_flag=0;
1231   4                alarm_voice_flag=0;
1232   4              }     
1233   3            }
1234   2            else if((alarm_value5)==time.minute)
1235   2            {
1236   3              TR0=0;
1237   3              buzzer=0;
1238   3              alarm->alarm_flag=0;
1239   3              alarm_voice_flag=0;
1240   3            }     
1241   2          }
1242   1      
1243   1          
1244   1      }
1245          
1246          void alarm_display (void)
1247          {
1248   1         if(alarm1.alarm_on_dispaly)
1249   1       {
1250   2      //    alarm1_sleep( );
1251   2           alarm_sleep_judge(&alarm1);
1252   2       }
1253   1         if(alarm2.alarm_on_dispaly)
1254   1       {
1255   2      //    alarm2_sleep( );
1256   2         alarm_sleep_judge(&alarm2);
1257   2       }
1258   1         if(alarm3.alarm_on_dispaly)
1259   1       {
1260   2      //    alarm3_sleep( );
1261   2         alarm_sleep_judge(&alarm3);
1262   2       }
1263   1      }
1264          
1265          
1266          
1267          void voice_control(void)
1268          {
1269   1        if(SET_Long_Flag==0)
1270   1        {
1271   2          if(voice_flag==0)
1272   2          {
1273   3          if(voice_key==1)
1274   3            {
1275   4        
1276   4              if(voice_key==1)
1277   4              {
1278   5                FD612_DispStateWr(FD612_INTENS8|FD612_DISP_ON);  
1279   5                FD612_Refresh();
1280   5              }
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 22  

1281   4      
1282   4            }
1283   3              else
1284   3              {
1285   4                FD612_DispStateWr(FD612_DISP_OFF); 
1286   4                FD612_Refresh();
1287   4              }     
1288   3          }
1289   2          if(FD612_DispBuff.DispState&0x08)
1290   2              {
1291   3              
1292   3                voice_flag=1;
1293   3                if(voice_fisrt)
1294   3                {
1295   4                  back_voice_Flag=0;
1296   4                  voice_fisrt=0;
1297   4                }
1298   3      
1299   3                if(back_voice_Flag==voice_wake_up_time)
1300   3                {
1301   4                  voice_flag=0;
1302   4                  voice_fisrt=1;
1303   4                  flag_display=0;
1304   4                  FD612_DispStateWr(FD612_DISP_OFF); 
1305   4                  FD612_Refresh();
1306   4                  mDelayuS(150);
1307   4              
1308   4                }
1309   3              }
1310   2            }
1311   1      }
1312          
1313          void sd_mode (void)
1314          {
1315   1        if(DOWN_Short_Flag)
1316   1        {
1317   2          up_down_flag=1;//up_down键与模式选择冲突
1318   2      //    if(SET_Long_Flag==0&&flag_display !=5)
1319   2          if(SET_Long_Flag==0&&flag_display ==0)
1320   2          {
1321   3            dislay_all_flag=1;
1322   3            sd_flag++;
1323   3            if(sd_select_first==1)
1324   3                {
1325   4                  sd_flag--;
1326   4                  sd_select_first=0;
1327   4                }
1328   3                if(sd_flag>1)sd_flag=0;     
1329   3              switch(sd_flag)
1330   3              {
1331   4                case 0:
1332   4                {
1333   5                  
1334   5                  FD612_display_4DIG_input(0x40  ,0x40 ,FD612_DISP_S ,FD612_DISP_d  );
1335   5                  sd_mode_flag=0;
1336   5                  break;
1337   5            
1338   5                }
1339   4                case 1: 
1340   4                {
1341   5                  
1342   5                  FD612_display_4DIG_input(0x5c  ,0x54 ,FD612_DISP_S ,FD612_DISP_d );
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 23  

1343   5                  sd_mode_flag=1;
1344   5                  break;
1345   5                }
1346   4                  default :
1347   4                  break;          
1348   4              }
1349   3          }
1350   2          up_down_flag=0;
1351   2          DOWN_Short_Flag=0;  
1352   2      //    mode_select_first=1;
1353   2        if(back_first)
1354   2          {
1355   3            back_TIME_Flag=0;
1356   3            back_first=0;
1357   3          }   
1358   2        }
1359   1        if(back_first)
1360   1          {
1361   2            back_TIME_Flag=0;
1362   2            back_first=0;
1363   2          }
1364   1          if(back_TIME_Flag==over_time  ||SET_Short_Flag==1)
1365   1          {
1366   2      
1367   2            dislay_all_flag=0;
1368   2            back_TIME_Flag=0;
1369   2            back_first=1; 
1370   2            UP_Short_Flag=0;
1371   2            SET_Short_Flag=0;
1372   2      //      mode_select_first=1;
1373   2            sd_select_first=1;
1374   2      //      up_down_flag=0;
1375   2            
1376   2      
1377   2          }         
1378   1      }
1379          
1380          #if mode_select_enable
              void Display_Mode_Select(void)
              {
                  if(UP_Short_Flag)
                  {
                      up_down_flag=1;//up_down键与模式选择冲突
              //        dislay_all_flag=1;
              
              //        if(SET_Long_Flag==0&&flag_display !=2&&flag_display !=3&&flag_display !=4)
                    if(SET_Long_Flag==0&&flag_display ==0)
                      {
                        dislay_all_flag=1;
                          mode_select_flag++;
                        if(mode_select_first==1)
                        {
                          mode_select_flag--;
                          mode_select_first=0;
                        }
                        if(mode_select_flag>2)mode_select_flag=0;
                        switch (mode_select_flag)
                        {
                          case 0:
                            {
                              
                              FD612_display_4DIG_input( FD612_DISP_d ,FD612_DISP_P  ,0x40 ,FD612_DISP_1 );
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 24  

                              break;
                            }
                          case 1:
                            {
                                
                              FD612_display_4DIG_input( FD612_DISP_d ,FD612_DISP_P ,0x40 ,FD612_DISP_2 );
                              break;
                            }
                          case 2:
                            {
                              
                              FD612_display_4DIG_input( FD612_DISP_d ,FD612_DISP_P ,0x40 ,FD612_DISP_3 );
                              break;
                            } 
                              default :
                              break;              
                        }
                                  UP_Short_Flag=0;
                                  up_down_flag=0;
                      }
              
                      sd_select_first=1;
                        if(back_first)
                          {
                            back_TIME_Flag=0;
                            back_first=0;
                          }
                  }
                    if(back_first)
                  {
                    back_TIME_Flag=0;
                    back_first=0;
                  }
              //    if(back_TIME_Flag==over_time ||SET_Short_Flag==1 )
              //    {
              //      FD612_DispBuff.DispData[FD612_DIG1_ADDR]=0x00 ; 
              //      FD612_DispBuff.DispData[FD612_DIG2_ADDR]=0x00 ;
              //      FD612_DispBuff.DispData[FD612_DIG3_ADDR]=0x00; 
              //      FD612_DispBuff.DispData[FD612_DIG4_ADDR]=0x00 ;
              //      FD612_Refresh();
              
              //      dislay_all_flag=0;
              //      back_TIME_Flag=0;
              //      back_first=1; 
              //      UP_Short_Flag=0;
              //      SET_Short_Flag=0;
              //      mode_select_first=1;
              //      up_down_flag=1;
              //    }
              
              }
              void mode1_select_dislay(void)
              {
                  if(mode_select_flag==0)
                  {
                    if(SET_Long_Flag==0)
                    {
                    if(hor_min_delay_time==over_time_2s)
                    {
                      flag_display=0;
                      hor_min_delay_time=0;
                      
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 25  

                    }
                    if(mon_day_delay_time==over_time_10s)
                    {
                      flag_display=1;
                      mon_day_delay_time=0;
                    }
              //      if(temp_delay_time==over_time_2s)
              //      {
              //        flag_display=0;
              //        temp_delay_time=0;
              //      } 
                  }
                    
                  }
              }
              
              #endif
1484          
1485          void year_long_up_down(UINT8 i)
1486          {
1487   1      //      ResetDS1302();
1488   1      //      WriteByteDS1302(year_r_addr); //读取分的地址        
1489   1      //      time.year=ReadByteDS1302();
1490   1      //      ResetDS1302();
1491   1            time.year=Read_addr_byte_ds1302(year_r_addr); 
1492   1            time.year = bcd_decimal(time.year);
1493   1            if(i==1)time.year--;
1494   1            if(i==0)
1495   1            {
1496   2              time.year++;
1497   2              if(time.year>99)time.year=0;
1498   2                
1499   2            }
1500   1                     
1501   1            FD612_display_4DIG_input( dis[2] ,dis[0] ,dis[time.year/10] , dis[ time.year% 10]);
1502   1            time.year = decimal_bcd(time.year);
1503   1            Write_addr_byte_ds1302(year_w_addr,time.year);
1504   1      //      ResetDS1302();
1505   1      //      WriteByteDS1302(year_w_addr); //写入时的地址
1506   1      //      WriteByteDS1302(time.year);
1507   1      //      ResetDS1302();  
1508   1            mDelaymS(up_down_delay_time); 
1509   1            time.year = bcd_decimal(time.year);
1510   1      }
1511          
1512          void hour_long_up_down(UINT8 i)
1513          {
1514   1      
1515   1              time.hour=Read_addr_byte_ds1302(hour_r_addr);       
1516   1              if(hour_12_24_flag==1)
1517   1              {
1518   2                time.hour<<=3;
1519   2                time.hour>>=3;
1520   2      
1521   2              }
1522   1              time.hour = bcd_decimal(time.hour);
1523   1              if(i==0) 
1524   1              {
1525   2                time.hour++;
1526   2                hour_over_judge(i);
1527   2              
1528   2              }
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 26  

1529   1              if(i==1)
1530   1              { 
1531   2                  time.hour--;
1532   2                  hour_over_judge(i);         
1533   2                
1534   2              }
1535   1              if(hour_12_24_flag){time.hour<<=3;time.hour>>=3;}
1536   1              time.hour = bcd_decimal(time.hour);
1537   1              FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10]  ,dis[time.hour% 10] );
1538   1      
1539   1             
1540   1      
1541   1             mDelaymS(up_down_delay_time);
1542   1            
1543   1              
1544   1      
1545   1        
1546   1      }
1547          
1548          void min_long_up_down(UINT8 i) 
1549          {
1550   1      
1551   1            time.minute=Read_addr_byte_ds1302(min_r_addr);  
1552   1            time.minute = bcd_decimal(time.minute);
1553   1            if(i==0)
1554   1            {
1555   2              time.minute++;
1556   2              if(time.minute >=60)
1557   2              {
1558   3                time.minute = 0;
1559   3              }
1560   2            }
1561   1            if(i==1)
1562   1            {
1563   2            time.minute--;
1564   2            if(time.minute>60)
1565   2            {
1566   3                time.minute = time.minute -196; //溢出值
1567   3            } 
1568   2            }
1569   1      
1570   1            FD612_DISPLAY_2DIG_input(2,dis[time.minute/10] ,dis[ time.minute% 10] );
1571   1            time.minute = decimal_bcd(time.minute);
1572   1      
1573   1              Write_addr_byte_ds1302(min_w_addr,time.minute);
1574   1              Write_addr_byte_ds1302(sec_w_addr,0);
1575   1          
1576   1      
1577   1            time.minute = bcd_decimal(time.minute);
1578   1            mDelaymS(up_down_delay_time);
1579   1      }
1580          void mon_long_up_down(UINT8 i)
1581          {
1582   1      
1583   1            time.month=Read_addr_byte_ds1302(mon_r_addr);
1584   1            time.month = bcd_decimal(time.month); 
1585   1              time.mday=Read_addr_byte_ds1302(day_r_addr);
1586   1            time.mday = bcd_decimal(time.mday);
1587   1        
1588   1            if(i==0)
1589   1            {
1590   2              time.month++;
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 27  

1591   2      
1592   2              mday_over_judge();
1593   2            }
1594   1            if(i==1)
1595   1            {
1596   2            time.month--;
1597   2      
1598   2            mday_over_judge();  
1599   2            } 
1600   1        
1601   1            ui_mon_display();
1602   1      //      FD612_DISPLAY_2DIG_input(1 ,dis[time.month/10] , dis[time.month% 10]);
1603   1            time.month = decimal_bcd(time.month);
1604   1      
1605   1              Write_addr_byte_ds1302(mon_w_addr,time.month);
1606   1      
1607   1      
1608   1      
1609   1            time.month = bcd_decimal(time.month);     
1610   1            mDelaymS(up_down_delay_time);     
1611   1      }
1612          
1613          void mday_long_up_down(UINT8 i)
1614          {
1615   1      
1616   1            time.mday=Read_addr_byte_ds1302(day_r_addr);
1617   1            time.mday = bcd_decimal(time.mday);
1618   1            if(i==0)
1619   1            {
1620   2              time.mday++;
1621   2              mon_over_judge();
1622   2            }
1623   1            if(i==1)
1624   1            {
1625   2            time.mday--;
1626   2              mon_over_judge(); 
1627   2            } 
1628   1      
1629   1              
1630   1              FD612_DISPLAY_2DIG_input(1,dis[time.mday/10] ,dis[time.mday% 10] );
1631   1              time.mday = decimal_bcd(time.mday);
1632   1      
1633   1              Write_addr_byte_ds1302(day_w_addr,time.mday);
1634   1      
1635   1        
1636   1              time.mday = bcd_decimal(time.mday);
1637   1              mDelaymS(up_down_delay_time);     
1638   1      }
1639          
1640          void alarm_hour_up_down2(UINT8 long_key_enble,UINT8 up_down_seclect,struct DATA_ALARM * alarm)
1641          {
1642   1        if(up_down_seclect==0)
1643   1        {
1644   2          if(long_key_enble)alarm->hour++;
1645   2          if(hour_12_24_flag)
1646   2          {
1647   3            if(alarm->hour>=13)alarm->hour = 1;
1648   3            if(alarm->hour==12)
1649   3            {
1650   4              if(alarm->alarm_pm_flag)alarm->alarm_pm_flag=0;
1651   4              else alarm->alarm_pm_flag=1;
1652   4            }
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 28  

1653   3          }
1654   2          else
1655   2          {
1656   3            if(alarm->hour >=24)      alarm->hour = 0;
1657   3          }
1658   2        }
1659   1        if(up_down_seclect==1)
1660   1        {
1661   2          if(long_key_enble)alarm->hour--;
1662   2          if(hour_12_24_flag)
1663   2          {
1664   3            if(alarm->hour==0)alarm->hour = 12;
1665   3            if(alarm->hour==11)
1666   3            {
1667   4              if(alarm->alarm_pm_flag)alarm->alarm_pm_flag=0;
1668   4              else alarm->alarm_pm_flag=1;
1669   4            }     
1670   3          }
1671   2          else
1672   2          {
1673   3            if(alarm->hour >=255)     alarm->hour = 23;
1674   3          }
1675   2        }
1676   1         FD612_DISPLAY_2DIG_input(1 , dis[alarm->hour/10],dis[alarm->hour%10] );
1677   1      //  FD612_DISPLAY_2DIG_input(2,0x00 ,dis[alarm->alarm_pm_flag] );
1678   1         if(long_key_enble) mDelaymS(up_down_delay_time);
1679   1      }
1680          //void alarm_hour_long_up_down(UINT8 alarm_seclect,UINT8 up_down_seclect,struct DATA_ALARM * alarm)
1681          //{
1682          //  
1683          //  if(up_down_seclect==1)
1684          //  {
1685          //        if(alarm_seclect==1)
1686          //        {
1687          //          
1688          //          alarm->hour=alarm->hour+1;
1689          //          if(hour_12_24_flag){
1690          //             if(alarm1.hour>=13)
1691          //             {
1692          //               alarm1.hour = 1;
1693          //             }
1694          //             if(alarm1.hour==1)
1695          //            {
1696          //              if(alarm1_pm_flag)alarm1_pm_flag=0;
1697          //              else alarm1_pm_flag=1;            
1698          //            }
1699          //            }
1700          //          else
1701          //          {
1702          //            if(alarm1.hour >=24)
1703          //            {
1704          //              alarm1.hour = 0;
1705          //            } 
1706          //          }
1707          //          alarm_hour_long_up_down_flag=1;
1708          //        }
1709          //        if(alarm_seclect==2)
1710          //        {
1711          //          alarm2.hour++;
1712          //          if(hour_12_24_flag){
1713          //             if(alarm2.hour>=13)
1714          //             {
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 29  

1715          //               alarm2.hour = 1;
1716          
1717          //             }
1718          //            if(alarm2.hour==1)
1719          //            {
1720          //              if(alarm2_pm_flag)alarm2_pm_flag=0;
1721          //              else alarm2_pm_flag=1;            
1722          //            }            
1723          //            }
1724          //          else
1725          //          {
1726          //            if(alarm2.hour >=24)
1727          //            {
1728          //              alarm2.hour = 0;
1729          //            } 
1730          //          }
1731          //          alarm_hour_long_up_down_flag=2;
1732          //        } 
1733          //        if(alarm_seclect==3)
1734          //        {
1735          //          alarm3.hour++;
1736          //          if(hour_12_24_flag){
1737          //             if(alarm3.hour>=13)
1738          //             {
1739          //               alarm3.hour = 1;
1740          
1741          //             }
1742          //            if(alarm3.hour==1)
1743          //            {
1744          //              if(alarm3_pm_flag)alarm3_pm_flag=0;
1745          //              else alarm3_pm_flag=1;            
1746          //            }              
1747          //            }
1748          //          else
1749          //          {
1750          //            if(alarm3.hour >=24)
1751          //            {
1752          //              alarm3.hour = 0;
1753          //            } 
1754          //          }
1755          //          alarm_hour_long_up_down_flag=3;
1756          //        }
1757          //    }
1758          //    if(up_down_seclect==2)
1759          //    {
1760          //      if(alarm_seclect==1)
1761          //      {
1762          //        alarm1.hour--;          
1763          //        if(hour_12_24_flag){
1764          //           if(alarm1.hour>=13||alarm1.hour==0)
1765          //           {
1766          //              alarm1.hour = alarm1.hour -244; //溢出值
1767          //            
1768          //           }
1769          //            if(alarm1.hour==10)
1770          //            {
1771          //              if(alarm1_pm_flag)alarm1_pm_flag=0;
1772          //              else alarm1_pm_flag=1;            
1773          //            } 
1774          //          }
1775          //        else
1776          //        {
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 30  

1777          //          if(alarm1.hour >=24)
1778          //          {
1779          //            alarm1.hour = alarm1.hour -232; //溢出值
1780          //          }
1781          //        } 
1782          //      alarm_hour_long_up_down_flag=4;
1783          //      }
1784          //      if(alarm_seclect==2)
1785          //      {
1786          //        alarm2.hour--;          
1787          //        if(hour_12_24_flag){
1788          //           if(alarm2.hour>=13||alarm2.hour==0)
1789          //           {
1790          //              alarm2.hour = alarm2.hour -244; //溢出值
1791          
1792          //           }
1793          //              if(alarm2.hour==10)
1794          //            {
1795          //              if(alarm2_pm_flag)alarm2_pm_flag=0;
1796          //              else alarm2_pm_flag=1;            
1797          //            } 
1798          //          }
1799          //        else
1800          //        {
1801          //          if(alarm2.hour >=24)
1802          //          {
1803          //            alarm2.hour = alarm2.hour -232; //溢出值
1804          //          }
1805          //        } 
1806          
1807          //      alarm_hour_long_up_down_flag=5;
1808          //      }
1809          //      if(alarm_seclect==3)
1810          //      {
1811          //        alarm3.hour--;          
1812          //        if(hour_12_24_flag){
1813          //           if(alarm3.hour>=13||alarm3.hour==0)
1814          //           {
1815          //              alarm3.hour = alarm3.hour -244; //溢出值
1816          //           }
1817          //            if(alarm3.hour==10)
1818          //            {
1819          //              if(alarm3_pm_flag)alarm3_pm_flag=0;
1820          //              else alarm3_pm_flag=1;            
1821          //            } 
1822          //          }
1823          //        else
1824          //        {
1825          //          if(alarm3.hour >=24)
1826          //          {
1827          //            alarm3.hour = alarm3.hour -232; //溢出值
1828          //          }
1829          //        } 
1830          //      alarm_hour_long_up_down_flag=6;
1831          //      }   
1832          //    }
1833          
1834          //          
1835          //        FD612_DISPLAY_2DIG_input(1 , dis[alarm->hour/10],dis[alarm->hour%10] );
1836          //        mDelaymS(up_down_delay_time);
1837          //        
1838          //}
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 31  

1839          
1840          void alarm_min_up_down2(UINT8 long_key_enble,UINT8 up_down_seclect,struct DATA_ALARM* alarm)
1841          {
1842   1        if(up_down_seclect==0)
1843   1        {
1844   2          if(long_key_enble)alarm->minute++;
1845   2          if(alarm->minute >=60)alarm->minute = 0;
1846   2        }
1847   1        else
1848   1        {
1849   2          if(long_key_enble)alarm->minute--;
1850   2          if(alarm->minute ==255)alarm->minute = 59;
1851   2        }
1852   1        FD612_DISPLAY_2DIG_input(2,dis[alarm->minute/10]  ,dis[alarm->minute%10] );
1853   1        if(long_key_enble)mDelaymS(up_down_delay_time);
1854   1      }
1855          //void alarm_min_long_up_down(UINT8 alarm_seclect,UINT8 up_down_seclect,struct DATA_ALARM alarm)
1856          //{
1857          //  if(up_down_seclect==1)
1858          //  {
1859          //        if(alarm_seclect==1)
1860          //        {
1861          //          alarm1.minute++;
1862          //        if(alarm1.minute >=60)
1863          //        {
1864          //          alarm1.minute = 0;
1865          //        }
1866          //        alarm_min_long_up_down_flag=1;
1867          //        }
1868          //        if(alarm_seclect==2)
1869          //        {
1870          //          alarm2.minute++;
1871          //        if(alarm2.minute >=60)
1872          //        {
1873          //          alarm2.minute = 0;
1874          //        }
1875          //        alarm_min_long_up_down_flag=2;        
1876          //        }
1877          //        if(alarm_seclect==3)
1878          //        {
1879          //          alarm3.minute++;
1880          //        if(alarm3.minute >=60)
1881          //        {
1882          //          alarm3.minute = 0;
1883          //        }
1884          //        alarm_min_long_up_down_flag=3;        
1885          //        } 
1886          //    }
1887          //    if(up_down_seclect==2)
1888          //    {
1889          //        if(alarm_seclect==1)
1890          //        {
1891          //          alarm1.minute--;
1892          //        if(alarm1.minute>60)
1893          //        {
1894          //            alarm1.minute = alarm1.minute -196; //溢出值
1895          //        }
1896          //        alarm_min_long_up_down_flag=4;        
1897          //        }
1898          //        if(alarm_seclect==2)
1899          //        {
1900          //          alarm2.minute--;
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 32  

1901          //        if(alarm2.minute>60)
1902          //        {
1903          //            alarm2.minute = alarm2.minute -196; //溢出值
1904          //        }
1905          //        alarm_min_long_up_down_flag=5;        
1906          //        }
1907          //        if(alarm_seclect==3)
1908          //        {
1909          //          alarm3.minute--;
1910          //        if(alarm3.minute>60)
1911          //        {
1912          //            alarm3.minute = alarm3.minute -196; //溢出值
1913          //        }
1914          //        alarm_min_long_up_down_flag=6;        
1915          //        }     
1916          //    }
1917          
1918          //        
1919          //        FD612_DISPLAY_2DIG_input(2,dis[alarm.minute/10]  ,dis[alarm.minute%10] );
1920          //        mDelaymS(up_down_delay_time);
1921          //        
1922          //}
1923          void alarm_set_display(UINT8 alarm_flag,struct DATA_ALARM* alarm)
1924          {
1925   1        if(SET_Long_Flag)
1926   1        {
1927   2          key_first_into();
1928   2          alarm->alarm_on_dispaly=1;
1929   2          if(SET_Short_Flag)
1930   2          {
1931   3            SET_Short_Flag_alarm1_flag++;
1932   3            if(SET_Short_Flag_alarm1_flag>3)  SET_Short_Flag_alarm1_flag=0;
1933   3            SET_Short_Flag=0;
1934   3          }
1935   2            switch(SET_Short_Flag_alarm1_flag)
1936   2            {
1937   3              case 0:
1938   3              {
1939   4                FD612_DISPLAY_2DIG_input(2,dis[alarm->minute/10] ,dis[alarm->minute%10] );
1940   4                all_blink(0,1,alarm->hour);
1941   4                if(UP_Short_Flag==1)
1942   4                {
1943   5                  alarm->hour++;
1944   5                  alarm_hour_up_down2(0,0,alarm);
1945   5                  UP_Short_Flag=0;
1946   5                }
1947   4                if(DOWN_Short_Flag == 1)
1948   4                {
1949   5                  alarm->hour--;
1950   5                  alarm_hour_up_down2(0,1,alarm);
1951   5                  DOWN_Short_Flag=0;
1952   5                }
1953   4                break;
1954   4              }
1955   3              case 1:
1956   3              {                         
1957   4                FD612_DISPLAY_2DIG_input(1 ,dis[alarm->hour/10] ,dis[alarm->hour%10] ); 
1958   4                all_blink(0,2,alarm->minute); 
1959   4                if(UP_Short_Flag==1)
1960   4                {
1961   5                  alarm->minute++;
1962   5                  alarm_min_up_down2(0,0,alarm);
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 33  

1963   5                  UP_Short_Flag=0;
1964   5                }
1965   4                if(DOWN_Short_Flag == 1)
1966   4                {
1967   5                  alarm->minute--;
1968   5                  alarm_min_up_down2(0,1,alarm);
1969   5                  DOWN_Short_Flag=0;
1970   5                }         
1971   4                break;
1972   4              }
1973   3              case 2:
1974   3              {
1975   4                SET_Long_Flag=0;
1976   4                SET_Short_Flag_alarm1_flag=0;
1977   4                key_first=1;
1978   4                break;
1979   4              }       
1980   3            }
1981   2            timeout_exit();
1982   2        }
1983   1        else
1984   1        {                               
1985   2            if(UP_Short_Flag==1)
1986   2             {
1987   3                if(alarm->alarm_on_dispaly)alarm->alarm_on_dispaly=0;
1988   3                else alarm->alarm_on_dispaly=1;
1989   3                UP_Short_Flag=0;
1990   3             }  
1991   2                switch(alarm_flag)
1992   2                {
1993   3                    case 1:
1994   3                    {
1995   4                      if(alarm->alarm_on_dispaly==0)FD612_display_4DIG_input( 0x40 ,0x40 ,FD612_DISP_A ,FD612_DISP_1 );
1996   4                      else FD612_display_4DIG_input( 0x5c ,0x54 ,FD612_DISP_A ,FD612_DISP_1 );
1997   4                
1998   4                      break;
1999   4                    }
2000   3                    case 2:
2001   3                    {
2002   4                      if(alarm->alarm_on_dispaly==0)FD612_display_4DIG_input( 0x40 ,0x40 ,FD612_DISP_A ,FD612_DISP_2 );
2003   4                      else FD612_display_4DIG_input( 0x5c ,0x54 ,FD612_DISP_A ,FD612_DISP_2 );
2004   4                  
2005   4                      break;
2006   4                    }
2007   3                    case 3:
2008   3                    {
2009   4                      if(alarm->alarm_on_dispaly==0)FD612_display_4DIG_input( 0x40 ,0x40 ,FD612_DISP_A ,FD612_DISP_3 );
2010   4                      else FD612_display_4DIG_input( 0x5c ,0x54 ,FD612_DISP_A ,FD612_DISP_3 );
2011   4                  
2012   4                      break;
2013   4                    }             
2014   3                
2015   3                }
2016   2              timeout_exit();   
2017   2        }
2018   1      }
2019          //void alarm_set_display(UINT8 i,struct DATA_ALARM alarm)
2020          //{
2021          //              if(SET_Long_Flag)
2022          //            {
2023          //              key_first_into();
2024          
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 34  

2025          //              if(i==1)alarm1_on_dispaly=1;
2026          //              if(i==2)alarm2_on_dispaly=1;
2027          //              if(i==3)alarm3_on_dispaly=1;  
2028          //              if(SET_Short_Flag)
2029          //                {
2030          //                  SET_Short_Flag_alarm1_flag++;
2031          //                  SET_Short_Flag=0;
2032          //                  if(SET_Short_Flag_alarm1_flag>3)
2033          //                  {
2034          //                    SET_Short_Flag_alarm1_flag=0;
2035          //                  }
2036          //                }
2037          //          if(SET_Short_Flag_alarm1_flag==0)
2038          //            {
2039          //          all_blink(0,1,alarm.hour);
2040          
2041          //            
2042          //            FD612_DISPLAY_2DIG_input(2,dis[alarm.minute/10] ,dis[alarm.minute%10] );
2043          //                if(UP_Short_Flag==1)
2044          //                {
2045          //                  if(i==1)
2046          //                  {
2047          //                    alarm1.hour++;
2048          //                    if(hour_12_24_flag){
2049          //                       if(alarm1.hour>=13)
2050          //                       {
2051          //                         alarm1.hour = 1;
2052          
2053          //                       }
2054          //                       if(alarm1.hour==12)
2055          //                       {
2056          //                         if(alarm1_pm_flag)alarm1_pm_flag=0;
2057          //                         else alarm1_pm_flag=1;
2058          //                        }
2059          //                      }
2060          //                    else
2061          //                    {
2062          //                      if(alarm1.hour >=24)
2063          //                      {
2064          //                        alarm1.hour = 0;
2065          //                      } 
2066          //                    }
2067          //                  }
2068          //                  if(i==2)
2069          //                  {
2070          //                    alarm2.hour++;
2071          //                    if(hour_12_24_flag){
2072          //                       if(alarm2.hour>=13)
2073          //                       {
2074          //                         alarm2.hour = 1;
2075          
2076          //                       }
2077          //                     if(alarm2.hour==12)
2078          //                       {
2079          //                         if(alarm2_pm_flag)alarm2_pm_flag=0;
2080          //                         else alarm2_pm_flag=1;
2081          //                        }                      
2082          //                      }
2083          //                    else
2084          //                    {
2085          //                      if(alarm2.hour >=24)
2086          //                      {
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 35  

2087          //                        alarm2.hour = 0;
2088          //                      } 
2089          //                    }
2090          //                  } 
2091          //                  if(i==3)
2092          //                  {
2093          //                    alarm3.hour++;
2094          //                    if(hour_12_24_flag){
2095          //                       if(alarm3.hour>=13)
2096          //                       {
2097          //                         alarm3.hour = 1;
2098          //                       }
2099          //                     if(alarm3.hour==12)
2100          //                       {
2101          //                         if(alarm3_pm_flag)alarm3_pm_flag=0;
2102          //                         else alarm3_pm_flag=1;
2103          //                        }                      
2104          //                      }
2105          //                    else
2106          //                    {
2107          //                      if(alarm3.hour >=24)
2108          //                      {
2109          //                        alarm3.hour = 0;
2110          //                      } 
2111          //                    }
2112          //                  }                 
2113          //                    UP_Short_Flag=0;
2114          //                }
2115          //                  if(DOWN_Short_Flag == 1)
2116          //                {
2117          //                  if(i==1)
2118          //                  {
2119          //                    alarm1.hour--;          
2120          //                    if(hour_12_24_flag){
2121          //                      if(alarm1.hour==0)alarm1.hour=12;
2122          ////                       if(alarm1.hour>=13||alarm1.hour==0)
2123          ////                       {
2124          ////                          alarm1.hour = alarm1.hour -244; //溢出值
2125          ////                       }
2126          //                      if(alarm1.hour==11)
2127          //                       {
2128          //                         if(alarm1_pm_flag)alarm1_pm_flag=0;
2129          //                         else alarm1_pm_flag=1;
2130          //                        }                      
2131          //                      }
2132          //                    else
2133          //                    {
2134          //                      if(alarm1.hour ==255)     alarm1.hour = 23; //溢出值
2135          //                    }
2136          //                  }
2137          //                  if(i==2)
2138          //                  {
2139          //                    alarm2.hour--;          
2140          //                    if(hour_12_24_flag){
2141          //                      if(alarm2.hour==0)alarm2.hour=12;
2142          //                       if(alarm2.hour==11)
2143          //                       {
2144          //                         if(alarm2_pm_flag)alarm2_pm_flag=0;
2145          //                         else alarm2_pm_flag=1;
2146          //                        }                    
2147          //                      }
2148          //                    else
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 36  

2149          //                    {
2150          //                      if(alarm2.hour ==255)     alarm2.hour = 23;
2151          //                    }
2152          //                  }
2153          //                  if(i==3)
2154          //                  {
2155          //                    alarm3.hour--;          
2156          //                    if(hour_12_24_flag){
2157          //                       if(alarm3.hour==0)alarm3.hour=12;
2158          //                      if(alarm2.hour==11)
2159          //                       {
2160          //                         if(alarm2_pm_flag)alarm2_pm_flag=0;
2161          //                         else alarm2_pm_flag=1;
2162          //                        }                      
2163          //                      }
2164          //                    else
2165          //                    {
2166          //                      if(alarm3.hour ==255)     alarm3.hour = 23;
2167          //                    }
2168          //                  }                 
2169          //                    DOWN_Short_Flag = 0;
2170          //                }           
2171          //            }
2172          //          if(SET_Short_Flag_alarm1_flag==1)
2173          //          {
2174          //            all_blink(0,2,alarm.minute);
2175          //            
2176          //              
2177          //              FD612_DISPLAY_2DIG_input(1 ,dis[alarm.hour/10] ,dis[alarm.hour%10] );
2178          //                
2179          //              if(UP_Short_Flag == 1)
2180          //              {
2181          //                if(i==1)
2182          //                {
2183          //                  alarm1.minute++;
2184          //                if(alarm1.minute >=60)
2185          //                {
2186          //                  alarm1.minute = 0;
2187          //                }
2188          //                }
2189          //                if(i==2)
2190          //                {
2191          //                  alarm2.minute++;
2192          //                if(alarm2.minute >=60)
2193          //                {
2194          //                  alarm2.minute = 0;
2195          //                }
2196          //                }
2197          //                if(i==3)
2198          //                {
2199          //                  alarm3.minute++;
2200          //                if(alarm3.minute >=60)
2201          //                {
2202          //                  alarm3.minute = 0;
2203          //                }
2204          //                }               
2205          //                  UP_Short_Flag = 0;
2206          //              }
2207          //              if(DOWN_Short_Flag == 1)
2208          //              {
2209          //                if(i==1)
2210          //                {
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 37  

2211          //                  alarm1.minute--;
2212          //                if(alarm1.minute==255)      alarm1.minute = 59; //溢出值
2213          //                }
2214          //                if(i==2)
2215          //                {
2216          //                  alarm2.minute--;
2217          //                if(alarm2.minute==255)      alarm2.minute = 59;
2218          //                }
2219          //                if(i==3)
2220          //                {
2221          //                  alarm3.minute--;
2222          //                if(alarm3.minute==255)      alarm3.minute = 59;
2223          //                }               
2224          //                  DOWN_Short_Flag = 0;
2225          //              }
2226          //          } 
2227          //          if(SET_Short_Flag_alarm1_flag==2) 
2228          //          {
2229          //                  
2230          //                  SET_Long_Flag=0;
2231          //                  SET_Short_Flag_alarm1_flag=0;
2232          //                  key_first=1;
2233          //          
2234          //          }
2235          //              timeout_exit();
2236          //            }
2237          //            if(SET_Long_Flag==0)
2238          //            {
2239          //              switch(i)
2240          //              {
2241          //                  case 1:
2242          //                  {
2243          //                    if(alarm1_on_dispaly==0)FD612_display_4DIG_input( 0x40 ,0x40 ,FD612_DISP_A ,FD612_DISP_1 );
2244          //                    else FD612_display_4DIG_input( 0x5c ,0x54 ,FD612_DISP_A ,FD612_DISP_1 );
2245          //                    if(UP_Short_Flag==1)
2246          //                    {
2247          //                      if(alarm1_on_dispaly)alarm1_on_dispaly=0;
2248          //                      else alarm1_on_dispaly=1;
2249          //                      UP_Short_Flag=0;
2250          //                    }               
2251          //                    break;
2252          //                  }
2253          //                  case 2:
2254          //                  {
2255          //                    if(alarm2_on_dispaly==0)FD612_display_4DIG_input( 0x40 ,0x40 ,FD612_DISP_A ,FD612_DISP_2 );
2256          //                    else FD612_display_4DIG_input( 0x5c ,0x54 ,FD612_DISP_A ,FD612_DISP_2 );
2257          //                    if(UP_Short_Flag==1)
2258          //                    {
2259          //                      if(alarm2_on_dispaly)alarm2_on_dispaly=0;
2260          //                      else alarm2_on_dispaly=1;
2261          //                      UP_Short_Flag=0;
2262          //                    }               
2263          //                    break;
2264          //                  }
2265          //                  case 3:
2266          //                  {
2267          //                    if(alarm3_on_dispaly==0)FD612_display_4DIG_input( 0x40 ,0x40 ,FD612_DISP_A ,FD612_DISP_3 );
2268          //                    else FD612_display_4DIG_input( 0x5c ,0x54 ,FD612_DISP_A ,FD612_DISP_3 );
2269          //                    if(UP_Short_Flag==1)
2270          //                    {
2271          //                      if(alarm3_on_dispaly)alarm3_on_dispaly=0;
2272          //                      else alarm3_on_dispaly=1;
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 38  

2273          //                      UP_Short_Flag=0;
2274          //                    }               
2275          //                    break;
2276          //                  }             
2277          
2278          //              }
2279          //              timeout_exit();
2280          //            }
2281          
2282          
2283          
2284          
2285          //}
2286          
2287          void alarm_hour_display(struct DATA_ALARM alarm)
2288          {
2289   1      
2290   1                
2291   1              FD612_DISPLAY_2DIG_input(1 ,dis[alarm.hour/10] ,dis[alarm.hour%10] );
2292   1      }
2293          
2294          void alarm_min_display(struct DATA_ALARM alarm)
2295          {
2296   1      
2297   1                
2298   1              FD612_DISPLAY_2DIG_input(2,dis[alarm.minute/10] ,dis[alarm.minute%10] );
2299   1      }
2300          
2301          void alarm_long_blink(struct DATA_ALARM alarm)//闹钟长按闪烁
2302          {
2303   1          if(time1_second==1)
2304   1        {
2305   2      
2306   2          if(blink_flag)
2307   2          {
2308   3            blink_flag=0;
2309   3            FD612_DISPLAY_2DIG_input(1 ,dis[alarm.hour/10],dis[alarm.hour%10]);
2310   3          }
2311   2          else
2312   2          {
2313   3            blink_flag=1;
2314   3            FD612_DISPLAY_2DIG_input(1 ,0x00,0x00); 
2315   3          }
2316   2      
2317   2          FD612_DISPLAY_2DIG_input(2 ,dis[alarm.minute/10],dis[alarm.minute%10]);
2318   2          time1_second=0;
2319   2        }
2320   1      }
2321          #if mode_select_enable
              void dp_mode_exit(void)
              {
                  if(mode_select_flag==0){
                    flag_display=0;
              //      temp_delay_time=0;
                    mon_day_delay_time=0;
                    hor_min_delay_time=0;
                  }                                     
                  
              }
              #endif
2333          void key_dislpay_up_down(void)
2334          {
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 39  

2335   1            if(long_add_flag==0)
2336   1            {
2337   2              switch(flag_display)
2338   2            {
2339   3              case 0:
2340   3              {
2341   4                if(SET_Short_Flag_hur_min==1 )
2342   4                {
2343   5      
2344   5                  
2345   5                  FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10]  ,dis[time.hour% 10]);
2346   5                }
2347   4                if(SET_Short_Flag_hur_min==2 )
2348   4                {
2349   5      
2350   5                
2351   5                  FD612_DISPLAY_2DIG_input(2,dis[time.minute/10] ,dis[time.minute% 10] );
2352   5                } 
2353   4                break;          
2354   4              }
2355   3              case 1:
2356   3              {
2357   4      
2358   4                if(SET_Short_Flag_mon_day==0)
2359   4                {
2360   5                FD612_DISPLAY_2DIG_input(1,dis[time.mday/10] ,dis[time.mday% 10] );
2361   5                
2362   5                }
2363   4                if(SET_Short_Flag_mon_day==1 )
2364   4                {
2365   5        
2366   5                  ui_mon_display();
2367   5                  
2368   5                }
2369   4                break;          
2370   4              }
2371   3              case 2:
2372   3              {
2373   4                          
2374   4                  if(SET_Short_Flag_year==0)
2375   4                  FD612_display_4DIG_input( dis[2] ,dis[0] ,dis[time.year/10] ,dis[time.year%10] );
2376   4                  
2377   4                
2378   4                break;
2379   4              }
2380   3              case 3:
2381   3              {
2382   4                if(SET_Short_Flag_alarm1_flag==0 )
2383   4                {
2384   5                 alarm_hour_display(alarm1);
2385   5                
2386   5                }
2387   4                if(SET_Short_Flag_alarm1_flag==1 )
2388   4                {
2389   5                  alarm_min_display(alarm1) ;     
2390   5                } 
2391   4                break;
2392   4              }
2393   3              case 4:
2394   3              {
2395   4                if(SET_Short_Flag_alarm1_flag==0 )
2396   4                {
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 40  

2397   5                  alarm_hour_display( alarm2);        
2398   5                } 
2399   4                if(SET_Short_Flag_alarm1_flag==1 )
2400   4                {
2401   5                  alarm_min_display(alarm2) ;
2402   5                }
2403   4                break;
2404   4              }
2405   3              case 5:
2406   3              {
2407   4                  if(SET_Short_Flag_alarm1_flag==0 )
2408   4                  {
2409   5                    alarm_hour_display(alarm3);       
2410   5                  } 
2411   4                  if(SET_Short_Flag_alarm1_flag==1 )
2412   4                  {
2413   5                    alarm_min_display(alarm3) ;
2414   5                  } 
2415   4                break;
2416   4              }       
2417   3            }
2418   2          }
2419   1      }
2420          
2421          
2422          
2423          void FD612_display_4DIG_input(UINT8 dig1,UINT8 dig2,UINT8 dig3,UINT8 dig4)
2424          {
2425   1      
2426   1            FD612_PotiveTNage(FD612_DIG1_ADDR,dig1);
2427   1            FD612_PotiveTNage(FD612_DIG2_ADDR,dig2);
2428   1            FD612_PotiveTNage(FD612_DIG3_ADDR,dig3);
2429   1            FD612_PotiveTNage(FD612_DIG4_ADDR,dig4);
2430   1            pm_12_24_alarm_display();
2431   1            FD612_Refresh();  
2432   1      }
2433          void FD612_DISPLAY_2DIG_input(UINT8 i ,UINT8 dig1,UINT8 dig2)
2434          {
2435   1          if(i==1)
2436   1          {
2437   2            FD612_PotiveTNage(FD612_DIG1_ADDR,dig1);
2438   2            FD612_PotiveTNage(FD612_DIG2_ADDR,dig2);
2439   2            pm_12_24_alarm_display();
2440   2      //      FD612_Refresh();
2441   2          }
2442   1          if(i==2)
2443   1          {
2444   2            FD612_PotiveTNage(FD612_DIG3_ADDR,dig1);
2445   2            FD612_PotiveTNage(FD612_DIG4_ADDR,dig2);
2446   2            pm_12_24_alarm_display();
2447   2      //      FD612_Refresh();
2448   2          }
2449   1      }
2450          void  pm_12_24_alarm_display(void)
2451          {
2452   1                if(hour_12_24_flag==1)
2453   1                {
2454   2      
2455   2                
2456   2                  if(hour_pm_flag==1)
2457   2                  {
2458   3                      
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 41  

2459   3                      FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2460   3                  
2461   3                  }
2462   2                  else 
2463   2                  {
2464   3                    
2465   3                      FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2466   3                  
2467   3                  }
2468   2                  if(SET_Long_Flag==1)
2469   2                  {
2470   3                    if(alarm1.alarm_pm_flag==1&&flag_display==3 )
2471   3                    {
2472   4      
2473   4                        FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2474   4                      
2475   4                    }
2476   3                    if(alarm1.alarm_pm_flag==0&&flag_display==3)
2477   3                    {
2478   4                        FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2479   4                                  
2480   4                    }       
2481   3      
2482   3      
2483   3                    if(alarm2.alarm_pm_flag==1&&flag_display==4)
2484   3                    {
2485   4      
2486   4                        FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2487   4                      
2488   4                    }
2489   3                     if(alarm2.alarm_pm_flag==0&&flag_display==4)
2490   3                    {
2491   4                          FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2492   4                                  
2493   4                    } 
2494   3      
2495   3                    
2496   3                    if(alarm3.alarm_pm_flag&&flag_display==5)
2497   3                    {
2498   4      
2499   4                        FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2500   4                      
2501   4                    } 
2502   3                    if(alarm3.alarm_pm_flag&&flag_display==5)
2503   3                    {
2504   4                      FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2505   4                                  
2506   4                    } 
2507   3                    if(flag_display==0)
2508   3                    {
2509   4                        if(SET_Short_Flag_hur_min==1||SET_Short_Flag_hur_min==2)FD612_DispBuff.DispData[FD612_DIG12_ADDR]
             - |=(1<<1) ;
2510   4                    }
2511   3                     if(flag_display==3||flag_display==4||flag_display==5)
2512   3                    {
2513   4                        if(SET_Short_Flag_alarm1_flag==0||SET_Short_Flag_alarm1_flag==1)FD612_DispBuff.DispData[FD612_DIG
             -12_ADDR] |=(1<<1) ;
2514   4                    }
2515   3                    
2516   3                  }
2517   2                
2518   2                  if(SET_Long_Flag==0&&(flag_display==0||flag_display==2)&&(hour_pm_flag==1))
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 42  

2519   2                  {
2520   3                      FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2521   3                  
2522   3                  }
2523   2              
2524   2                }
2525   1                else
2526   1                {
2527   2      
2528   2                }
2529   1                if(alarm1.alarm_on_dispaly ||alarm2.alarm_on_dispaly ||alarm3.alarm_on_dispaly)
2530   1                {
2531   2                  FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<3) ;
2532   2                }
2533   1                else
2534   1                {
2535   2                  FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<3) ;
2536   2                }
2537   1                if(flag_display==1)FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2538   1                FD612_Refresh();
2539   1      }
2540          
2541          
2542          
2543          void after_arrive_write_1302(void)
2544          {
2545   1      
2546   1              hour_chage_state=Read_addr_byte_ds1302(hour_r_addr);
2547   1      
2548   1             if(hour_chage_state&0x20)
2549   1             {
2550   2               hour_chage_state &=~(1<<5);
2551   2               hour_pm_flag=0;
2552   2             }
2553   1             else 
2554   1             {
2555   2               hour_chage_state |=(1<<5);
2556   2               hour_pm_flag=1;
2557   2             }
2558   1            Write_addr_byte_ds1302(hour_w_addr,hour_chage_state);
2559   1      
2560   1      }
2561          
2562            void hour_chage_input(UINT8 i)
2563            {//24小时转12小时
2564   1          
2565   1          UINT8 hour_state_value;
2566   1          hour_state_value=Read_addr_byte_ds1302(hour_r_addr);
2567   1      //    ResetDS1302();              
2568   1      //    WriteByteDS1302(hour_r_addr); //读取时的地址
2569   1      //    hour_state_value=ReadByteDS1302();
2570   1          if(i==1)    
2571   1          {
2572   2      //      hour_state_value<<=3;
2573   2      //      hour_state_value>>=3;
2574   2                  
2575   2            hour_state_value = bcd_decimal(hour_state_value);       
2576   2          if(hour_state_value>12)
2577   2          {
2578   3            hour_state_value=hour_state_value-12;
2579   3            hour_state_value=decimal_bcd(hour_state_value);
2580   3            hour_state_value |=(1<<5);
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 43  

2581   3            hour_state_value |= (1<<7);
2582   3            hour_pm_flag=1;
2583   3          }
2584   2          else if(hour_state_value==12)
2585   2          {
2586   3           hour_pm_flag=1;
2587   3            hour_state_value=decimal_bcd(hour_state_value);
2588   3            hour_state_value |=(1<<5);
2589   3            hour_state_value |= (1<<7);
2590   3          }
2591   2            else if(hour_state_value<12)
2592   2            {
2593   3            hour_state_value=decimal_bcd(hour_state_value);
2594   3            hour_state_value |= (1<<7);
2595   3            }
2596   2      //    if(hour_chage_state==12)
2597   2      //    {
2598   2      //     hour_pm_flag=1;
2599   2      //    hour_chage_state |=(1<<5);
2600   2      //    }
2601   2      //    hour_chage_state=decimal_bcd(hour_chage_state);
2602   2              
2603   2          }
2604   1          if(i==0)    
2605   1          {
2606   2            //12小时转24小时
2607   2            if(hour_state_value&0x20)
2608   2            {
2609   3              hour_state_value&=~(1<<7);
2610   3              hour_state_value &=~(1<<5);       
2611   3              hour_pm_flag=0;
2612   3              hour_state_value = bcd_decimal(hour_state_value);   
2613   3              if(hour_state_value!=12)
2614   3              hour_state_value=hour_state_value+12;
2615   3              hour_state_value=decimal_bcd(hour_state_value);
2616   3            }
2617   2            else
2618   2            {
2619   3            hour_state_value&=~(1<<7);  
2620   3            hour_state_value = bcd_decimal(hour_state_value);
2621   3            if(hour_state_value==12)hour_state_value=0;
2622   3            hour_state_value=decimal_bcd(hour_state_value);
2623   3            
2624   3            }
2625   2            
2626   2            
2627   2          }
2628   1          Write_addr_byte_ds1302(hour_w_addr,hour_state_value);
2629   1      
2630   1        }
2631            
2632            void temper_display(void)
2633            {
2634   1                
2635   1          if(ADC_TIME_Flag==temp_refresh_time)
2636   1          {
2637   2            ADC_Convert( );
2638   2            ADC_TIME_Flag=0;
2639   2          }
2640   1            adc_switch( );
2641   1      
2642   1        }
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 44  

2643            
2644          void display_12_24_blink(void)
2645          {
2646   1          if(time1_second==1)
2647   1          {
2648   2          if(blink_flag)          
2649   2            {
2650   3              blink_flag=0;
2651   3              if(hour_12_24_flag)
2652   3              {
2653   4              FD612_DISPLAY_2DIG_input(1 ,dis[1],dis[2]);
2654   4              }
2655   3              else
2656   3              {
2657   4              FD612_DISPLAY_2DIG_input(1 ,dis[2],dis[4]);
2658   4              }
2659   3      
2660   3              FD612_DISPLAY_2DIG_input(2,FD612_DISP_H ,FD612_DISP_);  
2661   3            }
2662   2            else
2663   2            {
2664   3              blink_flag=1;
2665   3              FD612_display_4DIG_input(0x00,0x00,0x00,0x00);
2666   3            }
2667   2            time1_second=0;
2668   2          } 
2669   1      }
2670          
2671          void year_blink(UINT8 i)
2672          {
2673   1          if(time1_second==1)
2674   1          {
2675   2            if(blink_flag)
2676   2            {
2677   3            blink_flag=0;
2678   3              FD612_display_4DIG_input( dis[2] ,dis[0] ,dis[time.year/10]  ,dis[time.year%10] );
2679   3            }
2680   2            else
2681   2            {
2682   3              blink_flag=1;
2683   3              if(i==0)
2684   3              FD612_display_4DIG_input( 0x00 ,0x00 ,0x00 ,0x00 );
2685   3            }
2686   2            time1_second=0;
2687   2          }
2688   1      }
2689          
2690          
2691          void from_ds1302_read_time_data(void)
2692          {
2693   1        //        UINT8 pm_flag;
2694   1            ResetDS1302();  
2695   1            WriteByteDS1302(0xbf);                                          //以多字节方式读取时钟寄存器数据
2696   1            time.second=ReadByteDS1302();
2697   1            time.minute=ReadByteDS1302();
2698   1            time.hour=ReadByteDS1302();
2699   1            time.mday=ReadByteDS1302();
2700   1            time.month=ReadByteDS1302();
2701   1            time.week=ReadByteDS1302();
2702   1            time.year=ReadByteDS1302();
2703   1            ResetDS1302();
2704   1            if(hour_12_24_flag==1)
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 45  

2705   1            {
2706   2             if((time.hour&0x20)&&(time.hour&0x80))
2707   2               { 
2708   3                 hour_pm_flag=1;
2709   3               }
2710   2               else 
2711   2               {                 
2712   3                 hour_pm_flag=0;
2713   3               }
2714   2              time.hour<<=3;
2715   2              time.hour>>=3;
2716   2            
2717   2            }
2718   1            time.year = bcd_decimal(time.year); 
2719   1            time.month =bcd_decimal(time.month);
2720   1            time.mday = bcd_decimal(time.mday);
2721   1            time.week = bcd_decimal(time.week);
2722   1            time.hour = bcd_decimal(time.hour);
2723   1            time.minute = bcd_decimal(time.minute);
2724   1            time.second = bcd_decimal(time.second);
2725   1      }
2726          
2727          
2728          void InitDS1302(void)
2729          {   
2730   1            unsigned char year,month,mday,week,hour,minute,second ;
2731   1            year = decimal_bcd(year_init); 
2732   1            month =decimal_bcd(month_init);
2733   1            mday = decimal_bcd(mday_init);
2734   1            week = decimal_bcd(week_init);
2735   1            hour = decimal_bcd(hour_init);
2736   1            minute = decimal_bcd(minute_init);
2737   1            second = decimal_bcd(second_init);
2738   1            
2739   1            hour |= 1<<7;
2740   1            hour &=~ (1<<5);
2741   1            hour_12_24_flag=1;
2742   1            hour_pm_flag=0;
2743   1            ds1302_w_on();
2744   1      //      ResetDS1302();
2745   1      //      WriteByteDS1302(0x8e);                          //写保护控制寄存器
2746   1      //      WriteByteDS1302(0x0);                           //允许写入
2747   1            
2748   1            ResetDS1302();
2749   1            WriteByteDS1302(0x90);                          //写涓流充电控制寄存器
2750   1            WriteByteDS1302(0xab);                          //允许充电
2751   1            
2752   1            ResetDS1302();
2753   1            WriteByteDS1302(0xbe);                          //写多字节突发方式控制寄存器
2754   1            
2755   1            WriteByteDS1302(second);
2756   1            WriteByteDS1302(minute);
2757   1            WriteByteDS1302(hour);
2758   1            WriteByteDS1302(mday);
2759   1            WriteByteDS1302(month);
2760   1            WriteByteDS1302(week);
2761   1            WriteByteDS1302(year);
2762   1            WriteByteDS1302(0);                             //对写保护控制寄存器写入0
2763   1            ResetDS1302();
2764   1            ds1302_w_off();
2765   1          
2766   1      //      from_ds1302_read_time_data();
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 46  

2767   1            
2768   1                
2769   1      }
2770          
2771          
2772          
2773          void point_blink(void)
2774          {
2775   1      
2776   1                                      
2777   1      
2778   1                      if(time1_second)
2779   1                      {
2780   2      //                  pm_12_24_alarm_display();
2781   2                        if(blink3_flag)
2782   2                        {
2783   3                          blink3_flag=0;
2784   3                          FD612_PotiveTNage(FD612_DIG1_ADDR,dis[time.hour/10]);
2785   3                          FD612_PotiveTNage(FD612_DIG2_ADDR,dis[time.hour% 10]);
2786   3                          FD612_PotiveTNage(FD612_DIG3_ADDR,dis[time.minute/10]);
2787   3                          FD612_PotiveTNage(FD612_DIG4_ADDR,dis[time.minute% 10]);
2788   3                          FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<1);
2789   3                           if(hour_pm_flag==1)
2790   3                          {                       
2791   4                              FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2792   4                          }
2793   3                          else 
2794   3                          {                     
2795   4                              FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;                   
2796   4                          }
2797   3                          if(alarm1.alarm_on_dispaly ||alarm2.alarm_on_dispaly ||alarm3.alarm_on_dispaly)
2798   3                          {
2799   4                            FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<3) ;
2800   4                          }
2801   3                          else
2802   3                          {
2803   4                            FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<3) ;
2804   4                          }                   
2805   3      //                    FD612_Refresh();
2806   3                        }
2807   2                        else
2808   2                        {
2809   3                          blink3_flag=1;
2810   3                          FD612_PotiveTNage(FD612_DIG1_ADDR,dis[time.hour/10]);
2811   3                          FD612_PotiveTNage(FD612_DIG2_ADDR,dis[time.hour% 10]);
2812   3                          FD612_PotiveTNage(FD612_DIG3_ADDR,dis[time.minute/10]);
2813   3                          FD612_PotiveTNage(FD612_DIG4_ADDR,dis[time.minute% 10]);
2814   3                          FD612_DispBuff.DispData[FD612_DIG12_ADDR] |= (1<<1);
2815   3                           if(hour_pm_flag==1)
2816   3                          {  
2817   4                              FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;                    
2818   4                          }
2819   3                          else 
2820   3                          {                     
2821   4                              FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;                   
2822   4                          }
2823   3                          if(alarm1.alarm_on_dispaly ||alarm2.alarm_on_dispaly ||alarm3.alarm_on_dispaly)
2824   3                          {
2825   4                            FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<3) ;
2826   4                          }
2827   3                          else
2828   3                          {
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 47  

2829   4                            FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<3) ;
2830   4                          }                   
2831   3                        }
2832   2                        FD612_Refresh();
2833   2                        time1_second=0;
2834   2                        
2835   2                      }
2836   1      }
2837          
2838          void adc_switch(void)
2839          {
2840   1                  switch (ADC_Display)
2841   1                 {
2842   2                   
2843   2                   case 0:
2844   2                   {
2845   3                                     
2846   3                      FD612_PotiveTNage(FD612_DIG5_ADDR,dis[(unsigned char)TEM2/10]);
2847   3                      FD612_PotiveTNage(FD612_DIG6_ADDR,dis[(unsigned char)TEM2%10]);
2848   3                      FD612_PotiveTNage(FD612_DIG7_ADDR,FD612_DISP_cc);
2849   3                      FD612_DispBuff.DispData[FD612_DIG12_ADDR]|= 1<<6 ; 
2850   3                      FD612_Refresh();
2851   3                     ADC_Display1=0;
2852   3                     break;
2853   3                   }
2854   2                    
2855   2      
2856   2                    case 1:
2857   2                    {
2858   3                      
2859   3      
2860   3                    FD612_PotiveTNage(FD612_DIG5_ADDR,dis[(unsigned char)TEM4/100]);
2861   3                    FD612_PotiveTNage(FD612_DIG6_ADDR,dis[(unsigned char)TEM4%100/10]);
2862   3                    FD612_PotiveTNage(FD612_DIG7_ADDR,dis[(unsigned char)TEM4%100%10]);
2863   3                    FD612_Refresh();  
2864   3                    ADC_Display1=1;
2865   3                      break;
2866   3                    } 
2867   2                      default :
2868   2                      break;
2869   2                }
2870   1      }
2871          
2872          void timeout_exit(void)
2873          {
2874   1                if(back_first)
2875   1              {
2876   2                back_TIME_Flag=0;
2877   2                back_first=0;
2878   2              }
2879   1              if(back_TIME_Flag==over_time)
2880   1              {
2881   2                display_flag_mon_day=1; 
2882   2                display_flag_hur_min=1; 
2883   2                SET_Long_Flag=0;
2884   2                SET_Short_Flag_mon_day=0;
2885   2                SET_Short_Flag_hur_min=0;
2886   2                SET_Short_Flag_alarm1_flag=0;
2887   2                back_TIME_Flag=0;
2888   2                back_first=1;
2889   2                key_first=1;
2890   2                flag_display=0;
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 48  

2891   2      #if mode_select_enable                  
                        dp_mode_exit(); 
              #endif                  
2894   2              } 
2895   1              
2896   1      
2897   1      }
2898          
2899          void ui_mon_display(void)
2900          {
2901   1              if(time.month<=9)
2902   1            {
2903   2            FD612_PotiveTNage(FD612_DIG3_ADDR,0x00);
2904   2            FD612_PotiveTNage(FD612_DIG4_ADDR,dis[time.month%10]);
2905   2            pm_12_24_alarm_display();
2906   2            }
2907   1            else
2908   1            FD612_DISPLAY_2DIG_input(2 ,dis[time.month/10] ,dis[time.month%10] );
2909   1      }
2910          
2911          UINT8  leep_year(UINT16  year)
2912          {
2913   1        if((year%400 == 0) || year%4 == 0 && year%100!=0)
2914   1        return 1;
2915   1        else
2916   1        return 0;
2917   1      }
2918          
2919          void mon_over_judge(void)
2920          {
2921   1            unsigned long year1;
2922   1            year1 = 2000+time.year; 
2923   1            flag_year_leap=leep_year(year1);//???????  
2924   1      //      if(time.mday>=30)   
2925   1      //     {          
2926   1            if(time.month==1||time.month==3||time.month==5||time.month==7||time.month==8||time.month==10||time.mont
             -h==12)  //?????31?????1??3??5??7??8??10??12      
2927   1               {     
2928   2                  if(time.mday==32)  time.mday=1;
2929   2                 if(time.mday==0)    time.mday=31;
2930   2                 
2931   2              }          
2932   1            if(time.month==4||time.month==6||time.month==9||time.month==11)  
2933   1                {     
2934   2                 if(time.mday==31)   time.mday=1;
2935   2                  if(time.mday==0)   time.mday=30;        
2936   2                 }         
2937   1      //      }     
2938   1             if(time.month==2)    
2939   1              {      
2940   2                if(flag_year_leap&&(time.mday==30))                    time.mday=1;
2941   2                if(flag_year_leap&&(time.mday==0))                   time.mday=29;
2942   2                if((!flag_year_leap)&&(time.mday==29))                 time.mday=1;
2943   2                if((!flag_year_leap)&&(time.mday==0))                time.mday=28;
2944   2              }
2945   1      }
2946          
2947          void mday_over_judge(void)
2948          {
2949   1        if(time.month >=13)time.month=1;
2950   1        if(time.month ==0)time.month=12;
2951   1        if(time.month==4||time.month==6||time.month==9||time.month==11) 
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 49  

2952   1        {if(time.mday==31)time.mday=1;time.mday = decimal_bcd(time.mday);Write_addr_byte_ds1302(day_w_addr,time.m
             -day);}
2953   1        if(time.month==2) 
2954   1        {if(time.mday>=30)time.mday=1;time.mday = decimal_bcd(time.mday);Write_addr_byte_ds1302(day_w_addr,time.m
             -day);}
2955   1      }
2956          #if 0
              void mday_blink(UINT8 blink_set)
              {
                    if(time1_second)
                  {
                  if(blink_flag)
                  {
                    blink_flag=0; 
                    FD612_DISPLAY_2DIG_input(1 ,dis[time.mday/10] ,dis[time.mday%10] );
                  }
                  else
                  {
                    blink_flag=1;
                    if(blink_set==0)
                    FD612_DISPLAY_2DIG_input(1 ,0x00  ,0x00 );
                    else
                    FD612_DISPLAY_2DIG_input(1 ,dis[time.mday/10] ,dis[time.mday%10] );
                  }
                  time1_second=0;
                  } 
              }
              #endif
2978          void key_12and24_switch(void)
2979          {
2980   1                  if(hour_12_24_flag)//12转成24
2981   1                {
2982   2                  hour_12_24_flag=0;
2983   2                  hour_chage_input(hour_12_24_flag);
2984   2                  alarm_12switch24(&alarm1);
2985   2                  alarm_12switch24(&alarm2);
2986   2                  alarm_12switch24(&alarm3);
2987   2      //            if(alarm1_pm_flag)
2988   2      //          {
2989   2      //            if(alarm1.hour!=12)
2990   2      //            {
2991   2      //              alarm1.hour=alarm1.hour+12;
2992   2      //            }
2993   2      //            alarm1_pm_flag=0;
2994   2      //          }
2995   2      //          else if(alarm1.hour==12)alarm1.hour=0;
2996   2      //        
2997   2      //          if(alarm2_pm_flag)
2998   2      //          {
2999   2      //            if(alarm2.hour!=12)
3000   2      //            {
3001   2      //              alarm2.hour=alarm2.hour+12;
3002   2      //            }
3003   2      //            alarm2_pm_flag=0;
3004   2      //          }
3005   2      //          else if(alarm2.hour==12)alarm2.hour=0;
3006   2      //        
3007   2      //          if(alarm3_pm_flag)
3008   2      //          {
3009   2      //            if(alarm3.hour!=12)
3010   2      //            {
3011   2      //              alarm3.hour=alarm3.hour+12;
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 50  

3012   2      //            }
3013   2      //            alarm3_pm_flag=0;
3014   2      //          }
3015   2      //          else if(alarm3.hour==12)alarm3.hour=0;  
3016   2                }
3017   1                
3018   1                else  
3019   1                {
3020   2                  hour_12_24_flag=1;
3021   2                  hour_chage_input(hour_12_24_flag);
3022   2                  alarm_24switch12(&alarm1);  
3023   2                  alarm_24switch12(&alarm2);
3024   2                  alarm_24switch12(&alarm3);
3025   2      //            if(alarm1.hour>12)
3026   2      //            {
3027   2      //              alarm1.hour=alarm1.hour-12;
3028   2      //              alarm1_pm_flag=1;
3029   2      //            }
3030   2      //            if(alarm1.hour==12)alarm1_pm_flag=1;
3031   2      //            if(alarm1.hour==0){alarm1.hour=12;alarm1_pm_flag=0;}
3032   2      //            
3033   2      //            if(alarm2.hour>12)
3034   2      //            {
3035   2      //              alarm2.hour=alarm2.hour-12;
3036   2      //              alarm2_pm_flag=1;
3037   2      //            }
3038   2      //            if(alarm2.hour==12)alarm2_pm_flag=1;
3039   2      //            if(alarm2.hour==0){alarm2.hour=12;alarm2_pm_flag=0;}
3040   2      //            
3041   2      //            if(alarm3.hour>12)
3042   2      //            {
3043   2      //              alarm3.hour=alarm3.hour-12;
3044   2      //              alarm3_pm_flag=1;
3045   2      //            }
3046   2      //            if(alarm3.hour==12)alarm3_pm_flag=1;
3047   2      //            if(alarm3.hour==0){alarm3.hour=12;alarm3_pm_flag=0;}                          
3048   2                }
3049   1      }
3050          
3051          void key_first_into(void)
3052          {
3053   1          if(key_first)
3054   1        {
3055   2          key_first=0;
3056   2          UP_Short_Flag=0;
3057   2          DOWN_Short_Flag = 0;
3058   2        }
3059   1      }
3060          #if 0 
              void hour_blink(UINT8 blink_set)
              {
                      if(time1_second)
                    {
                    if(blink_flag)
                    { 
                      blink_flag=0;
                      FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10] , dis[time.hour%10]);
                    }
                    else
                    {
                      blink_flag=1; 
                      if(blink_set==0)
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 51  

                      FD612_DISPLAY_2DIG_input(1 ,0x00 ,0x00  );
                      else
                      FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10] , dis[time.hour%10]);
                    }
                    time1_second=0;
                    }
              }
              #endif
3082          #if 0
              void min_blink(UINT8 blink_set)
              {
                      if(time1_second)
                    {
                      if(blink_flag)
                      {
                        blink_flag=0;
                        FD612_DISPLAY_2DIG_input(2 ,dis[time.minute/10] , dis[time.minute%10]);
              
                      }
                    else
                      {
                        blink_flag=1;
                        if(blink_set==0)
                        FD612_DISPLAY_2DIG_input(2 ,0x00 ,0x00  );
                        else
                        FD612_DISPLAY_2DIG_input(2 ,dis[time.minute/10] , dis[time.minute%10]);
                        
                      }
                      time1_second=0;
                     }
              }
              #endif
3106          void all_blink(UINT8 blink_set,UINT8 ui_set,UINT8 value)
3107          {
3108   1            if(time1_second)
3109   1            {
3110   2              if(blink_flag)
3111   2              {
3112   3                blink_flag=0;
3113   3                
3114   3                FD612_DISPLAY_2DIG_input(ui_set ,dis[value/10] , dis[value%10]);
3115   3      
3116   3              }
3117   2            else
3118   2              {
3119   3                blink_flag=1;
3120   3                if(blink_set==0)
3121   3                FD612_DISPLAY_2DIG_input(ui_set ,0x00 ,0x00  );
3122   3                else
3123   3                FD612_DISPLAY_2DIG_input(ui_set ,dis[value/10] , dis[value%10]);
3124   3                
3125   3              }
3126   2              time1_second=0;
3127   2             }
3128   1      }
3129          void hour_over_judge(UINT8 add_redue_flag)
3130          {
3131   1          if(hour_12_24_flag)
3132   1          {
3133   2      
3134   2            switch(add_redue_flag)
3135   2            {
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 52  

3136   3              case 0:
3137   3              {
3138   4                if(time.hour==12) after_arrive_write_1302();
3139   4                if(time.hour>=13)              time.hour = 1;
3140   4                break;
3141   4              }
3142   3              case 1:
3143   3              {
3144   4                if(time.hour==11) after_arrive_write_1302();
3145   4                if(time.hour==0)               time.hour = 12;
3146   4                break;
3147   4              }       
3148   3            }     
3149   2          }
3150   1          else
3151   1          {
3152   2            switch(add_redue_flag)
3153   2            {
3154   3              case 0:
3155   3              {
3156   4                if(time.hour >=24) time.hour = 0;
3157   4                break;
3158   4              }
3159   3              case 1:
3160   3              {
3161   4                if(time.hour ==255) time.hour = 23;
3162   4                break;
3163   4              }       
3164   3            }     
3165   2      
3166   2          }
3167   1      
3168   1            time.hour = decimal_bcd(time.hour);
3169   1            if(hour_12_24_flag)
3170   1            {
3171   2              time.hour |=1<<7;
3172   2              if(hour_pm_flag)time.hour |=1<<5;
3173   2              else time.hour &=~(1<<5);
3174   2            }
3175   1            else time.hour &=~(1<<7);
3176   1            Write_addr_byte_ds1302(hour_w_addr,time.hour);    
3177   1            
3178   1      }
3179          
3180          void key_off_alarm_clock(struct  DATA_ALARM* alarm)
3181          {
3182   1        if(alarm->alarm_flag==1)
3183   1      {
3184   2        if(SET==0||UP==0||DOWN==0)
3185   2        {
3186   3          alarm->alarm_flag=0;
3187   3          PWM_CTRL &= ~(1<<3);
3188   3          alarm_voice_flag=0;   
3189   3        }
3190   2      }
3191   1      }
3192          
3193          void action_remove(void)
3194          {
3195   1        if(SET_Long_Flag==0)
3196   1        {
3197   2          if(UP_Short_Flag == 1)UP_Short_Flag=0;
C51 COMPILER V9.52.0.0   USR                                                               07/10/2018 17:33:52 PAGE 53  

3198   2        }
3199   1      }
3200          
3201          
3202          void alarm_12switch24(struct  DATA_ALARM* alarm)
3203          {
3204   1        if(alarm->alarm_pm_flag)
3205   1        {
3206   2          if(alarm->hour!=12)alarm->hour+=12;
3207   2          alarm->alarm_pm_flag=0;
3208   2        }
3209   1        else if(alarm->hour==12)alarm->hour=0;
3210   1      }
3211          
3212          void alarm_24switch12(struct  DATA_ALARM* alarm)
3213          {
3214   1        if(alarm->hour>12)
3215   1        {
3216   2          alarm->hour-=12;
3217   2          alarm->alarm_pm_flag=1;
3218   2        }
3219   1        if(alarm->hour==12)alarm->alarm_pm_flag=1;
3220   1        if(alarm->hour==0){alarm->hour=12;alarm->alarm_pm_flag=0;}
3221   1      }
3222            
3223          
3224          
3225          
*** WARNING C294 IN LINE 270 OF App\usr.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7544    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    133      59
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
