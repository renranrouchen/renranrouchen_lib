C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE USR
OBJECT MODULE PLACED IN .\Output\usr.obj
COMPILER INVOKED BY: E:\Keil_v5\C51\BIN\C51.EXE App\usr.c LARGE BROWSE INCDIR(.\StdDriver\inc;.\App) DEBUG OBJECTEXTEND 
                    -PRINT(.\List\usr.lst) TABS(2) OBJECT(.\Output\usr.obj)

line level    source

   1          
   2          #include "usr.h"
   3          
   4          
   5          struct DATA_ALARM alarm1,alarm2,alarm3;//闹钟初始值
   6          struct DATA_ALARM_ch ch_alarm1,ch_alarm2,ch_alarm3;
   7          struct DATA_TIME time;                  //时间初始值
   8          struct time_char time_ch;               //时间显示初始值
   9          
  10          
  11          
  12          unsigned char second,time1_second=0,long_flag;
  13          unsigned int delaytime =40,dc2=0,delaytime1=10,dc1=0; //20次1S
  14          unsigned char SET_Long_Flag=0,SET_Short_Flag=0,UP_Long_Flag=0,UP_Short_Flag=0,DOWN_Short_Flag=0,DOWN_Long_
             -Flag=0;
  15          unsigned char flag_display=0,display_flag_hur_min=1,SET_Short_Flag_hur_min=0;
  16          const unsigned char  dis[10] = {FD612_DISP_0,FD612_DISP_1,FD612_DISP_2,FD612_DISP_3,FD612_DISP_4,FD612_DIS
             -P_5,FD612_DISP_6,FD612_DISP_7,FD612_DISP_8,FD612_DISP_9 };
  17          unsigned char  TEM_VALUE =1;
  18          unsigned char  ADC_TIME_Flag=0,dc_ADC=0,delaytime_ADC=20,ADC_fisrt=1;//20次1S
  19          unsigned char display_flag_mon_day=1,SET_Short_Flag_mon_day=0,SET_Short_Flag_alarm1_flag=0;
  20          unsigned char  flag_year_leap=0;//闰年的代表
  21          unsigned char alarm_on_flag=0,alarm1_on_dispaly=0,alarm2_on_dispaly=0,alarm3_on_dispaly=0;
  22          unsigned char  back_TIME_Flag=0,dc_back=0,delaytime_back=20,back_first=1,voice_back=0,back_voice_Flag=0,al
             -arm_clock_flag=0,dc_alarm=0;
  23          unsigned char alarm_flag=0,alarm_voice_flag=0,alarm3_voice_flag=0,alarm2_voice_flag=0,alarm3_flag=0,alarm2
             -_flag=0;
  24          unsigned char voice_flag=0,voice_fisrt=1;
  25          unsigned char sd_flag=0,dislay_all_flag=0,sd_mode_flag=0,sd_select_first=1;
  26          float   TEM2,TEM4;
  27          double   TEM;       //浮点类型
  28          unsigned char  ADC_Display=0,ADC_Display1=0,ADC_ONE=1;
  29          unsigned char key_first=1;
  30          unsigned char mode_select_first=1,mode_select_flag=0,hor_min_delay_time=0,mon_day_delay_time=0,mode_select
             -=0,temp_delay_time=0;
  31          UINT8 long_add_flag=0,up_down_flag=0;
  32          UINT8 alarm_hour_long_up_down_flag=0,alarm_min_long_up_down_flag=0;
  33          UINT8 blink_flag=0,blink3_flag=0;
  34          UINT8 hour_chage_state=0,hour_12_24_flag=0,hour_pm_flag=0,alarm1_pm_flag=0,alarm2_pm_flag=0,alarm3_pm_flag
             -=0;
  35          void  mTimer0Interrupt( void ) interrupt INT_NO_TMR0 using 1                //timer0中断服务程序,使用寄存器
             -组1
  36          {                                                                           //方式3时，TH0使用Timer1的中断
             -资源
  37   1      
  38   1              TH0=0XFf;
  39   1              TL0=0X90;
  40   1              buzzer=~buzzer;
  41   1      //      dc2++;
  42   1      //    if(dc2==delaytime){
  43   1      //      second=1; 
  44   1      //      dc2=0;
  45   1      //    }
  46   1      
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 2   

  47   1      
  48   1      }
  49          
  50          void  mTimer1Interrupt( void ) interrupt INT_NO_TMR1 using 2                //timer1中断服务程序,使用寄存器
             -组2
  51          {                                                                           //方式3时，Timer1停止
  52   1          TH1 =0X3C;
  53   1          TL1 =0XB0; 
  54   1            dc2++;
  55   1          if(dc2==delaytime){
  56   2            second=1; 
  57   2            dc2=0;
  58   2          }  
  59   1          dc1++;
  60   1          if(dc1==delaytime1)
  61   1          {
  62   2            time1_second=1;
  63   2            dc1=0;
  64   2          }
  65   1          dc_ADC++;
  66   1          if(dc_ADC==delaytime_ADC)
  67   1          {
  68   2            ADC_TIME_Flag++;
  69   2            dc_ADC=0;
  70   2          }
  71   1          dc_back++;
  72   1          if(dc_back==delaytime_back)
  73   1          {
  74   2            back_TIME_Flag++;
  75   2            dc_back=0;
  76   2          }
  77   1          voice_back++;
  78   1          if(voice_back==delaytime_back)
  79   1          {
  80   2            back_voice_Flag++;
  81   2            voice_back=0;
  82   2          }
  83   1          dc_alarm++;
  84   1          if(dc_alarm==delaytime1)
  85   1          {
  86   2            alarm_clock_flag=1;
  87   2            dc_alarm=0;
  88   2            
  89   2          }
  90   1          mode_select++;
  91   1          if(mode_select==delaytime_back)
  92   1          {
  93   2            if(flag_display==1)
  94   2            hor_min_delay_time++;
  95   2            if(flag_display==0)
  96   2              mon_day_delay_time++;
  97   2            if(flag_display==5)
  98   2            temp_delay_time++;
  99   2              mode_select=0;
 100   2            
 101   2          }
 102   1      }
 103          
 104          
 105          /**
 106           *  @brief  BCD转十进制
 107           *  @param  bcd
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 3   

 108           *  @return decimal
 109           *  @note    
 110           *  @note    
 111           */
 112          UINT8 bcd_decimal(UINT8 bcd)
 113          {
 114   1      return bcd-(bcd >> 4)*6;
 115   1      }
 116          
 117          /**
 118           *  @brief  十进制转BCD
 119           *  @param  decimal
 120           *  @return bcd
 121           *  @note    
 122           *  @note    
 123           */
 124          UINT8 decimal_bcd(UINT8 decimal)
 125          {
 126   1      return  (decimal+(decimal / 10)*6);
 127   1      }
 128          
 129          
 130          /**
 131           *  @brief  判断是否是闰年
 132           *  @param  year
 133           *  @return 1代表闰年 0代表不是闰年
 134           *  @note    
 135           *  @note    
 136           */
 137          
 138          
 139          void alarm_time_init(void)
 140          {
 141   1          alarm1.hour  =0;
 142   1          alarm1.minute=0;
 143   1          alarm2.hour  =0;
 144   1          alarm2.minute=0;
 145   1          alarm3.hour  =0;
 146   1          alarm3.minute=0;
 147   1          //buzzer=0;
 148   1      }
 149          
 150          void time0_setup(void)
 151          {
 152   1          long_flag=0;
 153   1          back_first=1;
 154   1          delaytime =40;
 155   1          second=0;
 156   1          dc2=0;
 157   1      
 158   1      //    TH0 =0X3C;
 159   1      //    TL0 =0XB0;
 160   1      //    TR0=1;
 161   1          back_TIME_Flag=0;
 162   1        if(mode_select_flag==0)
 163   1        {
 164   2          temp_delay_time=0; //DP1计数清0
 165   2          mon_day_delay_time=0;
 166   2          hor_min_delay_time=0; 
 167   2        }
 168   1          TR0=1;
 169   1          mDelaymS(70);
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 4   

 170   1          TR0=0;
 171   1          buzzer=0;
 172   1      
 173   1          back_voice_Flag=0; //唤醒功能延时重新计数
 174   1            
 175   1      }
 176          
 177          void key_statue(void)
 178          {
 179   1          from_ds1302_read_time_data( );
 180   1              
 181   1      if(alarm_flag==0 && alarm2_flag==0&& alarm3_flag==0)  {
 182   2      //set按键
 183   2        if(SET==0)
 184   2        {
 185   3          time0_setup( );
 186   3          while(!SET)
 187   3          {
 188   4        //    pm_12_24_alarm_display();
 189   4            /*SET按下时秒还在跳*/
 190   4            if(flag_display==0&&SET_Long_Flag==0)
 191   4            {
 192   5      //          if(time1_second==1)
 193   5      //          {
 194   5      //          if(blink3_flag==1)
 195   5      //            {   
 196   5      //              blink3_flag=0;
 197   5      //              FD612_DispBuff.DispData[FD612_DIG12_ADDR] &= ~(1<<1);
 198   5      //              FD612_Refresh();  
 199   5      //            }
 200   5      //            else
 201   5      //            {
 202   5      //              blink3_flag=1;
 203   5      //              FD612_DispBuff.DispData[FD612_DIG12_ADDR] |= 1<<1;
 204   5      //              FD612_Refresh();  
 205   5      //            }
 206   5      //            time1_second=0;
 207   5      //          }
 208   5              point_blink();
 209   5            }
 210   4            
 211   4      
 212   4            if(second==1)
 213   4            {
 214   5              
 215   5              long_flag=1;
 216   5              SET_Long_Flag=1;
 217   5              switch(flag_display)
 218   5              {
 219   6                case 0:
 220   6                {
 221   7                  display_12_24_blink( );
 222   7                  break;
 223   7                }
 224   6              
 225   6                case 1:
 226   6                {
 227   7                    year_blink(0) ;         
 228   7                    break;
 229   7                }
 230   6                case 2:
 231   6                {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 5   

 232   7                  alarm_long_blink(alarm1)  ;       
 233   7                  break;
 234   7                }
 235   6                case 3:
 236   6                {
 237   7                  alarm_long_blink(alarm2)  ;
 238   7                  break;
 239   7                }
 240   6                case 4:
 241   6                {
 242   7                  alarm_long_blink(alarm3)  ;
 243   7                  break;
 244   7                }         
 245   6              }       
 246   5              
 247   5              
 248   5            }
 249   4          }
 250   3          second=0;
 251   3          while(!SET);
 252   3          if(long_flag==0)
 253   3          {
 254   4            SET_Short_Flag=1;
 255   4            second=0;
 256   4          }
 257   3        }
 258   2      //up按键
 259   2        if(UP==0)
 260   2        {
 261   3          
 262   3          time0_setup( );
 263   3          while(!UP)
 264   3          {
 265   4          //  pm_12_24_alarm_display();
 266   4            if(SET_Long_Flag==1)
 267   4            {
 268   5             key_dislpay_up_down( );
 269   5            }
 270   4            if(second==1)
 271   4            {
 272   5              
 273   5              long_flag=1;
 274   5              UP_Long_Flag=1;
 275   5              long_add_flag=1;//长按时显示
 276   5              
 277   5              if(SET_Long_Flag==1)
 278   5              {
 279   6                back_TIME_Flag=0;
 280   6                if(mode_select_flag==0)
 281   6                {
 282   7                  temp_delay_time=0; //DP1计数清0
 283   7                  mon_day_delay_time=0;
 284   7                  hor_min_delay_time=0; 
 285   7                }
 286   6                switch (flag_display)
 287   6                {
 288   7                case 0:
 289   7                {
 290   8                   if(SET_Short_Flag_hur_min==1)
 291   8                   {
 292   9                     hour_long_up_down(0);
 293   9                   }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 6   

 294   8                   if(SET_Short_Flag_hur_min==2)
 295   8                   {
 296   9      
 297   9                   min_long_up_down(0) ;
 298   9                   }             
 299   8                  break;
 300   8                }
 301   7                case 1:
 302   7                {
 303   8                   if(SET_Short_Flag_mon_day==0)
 304   8                   {
 305   9                    year_long_up_down(0);
 306   9                   }
 307   8                   if(SET_Short_Flag_mon_day==1)
 308   8                   {
 309   9                    mon_long_up_down(0);
 310   9                   }  
 311   8                   if(SET_Short_Flag_mon_day==2)
 312   8                   {
 313   9                    mday_long_up_down(0);
 314   9                   }             
 315   8                  break;
 316   8                }
 317   7                case 2:
 318   7                {
 319   8                    if(SET_Short_Flag_alarm1_flag==0) 
 320   8                    {
 321   9                       alarm_hour_long_up_down(1,1,alarm1);
 322   9      
 323   9                    }   
 324   8                    if(SET_Short_Flag_alarm1_flag==1) 
 325   8                    {
 326   9                       alarm_min_long_up_down(1,1,alarm1);
 327   9                    }           
 328   8                  break;
 329   8                }
 330   7                case 3:
 331   7                {
 332   8                  if(SET_Short_Flag_alarm1_flag==0) 
 333   8                  {
 334   9                     alarm_hour_long_up_down(2,1, alarm2);
 335   9                  }
 336   8                  if(SET_Short_Flag_alarm1_flag==1) 
 337   8                  {
 338   9                     alarm_min_long_up_down(2,1,alarm2);
 339   9                  }             
 340   8                  break;
 341   8                }
 342   7                case 4:
 343   7                {
 344   8                  if(SET_Short_Flag_alarm1_flag==0) 
 345   8                  {
 346   9                     alarm_hour_long_up_down(3,1, alarm3);
 347   9                  }
 348   8                  if(SET_Short_Flag_alarm1_flag==1) 
 349   8                  {
 350   9                     alarm_min_long_up_down(3,1, alarm3);
 351   9                  }           
 352   8                  break;
 353   8                }   
 354   7              }
 355   6      
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 7   

 356   6                    
 357   6              }
 358   5            }
 359   4        
 360   4          }
 361   3      
 362   3      /*用于ALARM自加自减时多加减一 */  
 363   3          switch(alarm_hour_long_up_down_flag)
 364   3          {
 365   4            case 1:
 366   4            {
 367   5              alarm1.hour--;
 368   5             if(hour_12_24_flag)
 369   5              {
 370   6                if(alarm1.hour==0)alarm1.hour=12;
 371   6              }
 372   5              else 
 373   5              {
 374   6                if(alarm1.hour>=24)alarm1.hour=23;
 375   6              }
 376   5              alarm_hour_long_up_down_flag=0; 
 377   5              alarm_hour_long_up_down_flag=0;       
 378   5              break;
 379   5            }
 380   4            case 2:
 381   4            {
 382   5              alarm2.hour--;
 383   5              if(hour_12_24_flag)
 384   5              {
 385   6                if(alarm2.hour==0)alarm2.hour=12;
 386   6              }
 387   5              else 
 388   5              {
 389   6                if(alarm2.hour>=24)alarm2.hour=23;
 390   6              }         
 391   5              alarm_hour_long_up_down_flag=0;       
 392   5              break;
 393   5            }     
 394   4            case 3:
 395   4            {
 396   5              alarm3.hour--;
 397   5               if(hour_12_24_flag)
 398   5              {
 399   6                if(alarm3.hour==0)alarm3.hour=12;
 400   6              }
 401   5              else 
 402   5              {
 403   6                if(alarm3.hour>=24)alarm3.hour=23;
 404   6              }       
 405   5              alarm_hour_long_up_down_flag=0;       
 406   5              break;
 407   5            }     
 408   4          
 409   4            default :
 410   4            break;      
 411   4          }
 412   3          switch(alarm_min_long_up_down_flag)
 413   3          {
 414   4            case 1:
 415   4            {
 416   5              alarm1.minute--;
 417   5              if(alarm1.minute>=60)alarm1.minute=59;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 8   

 418   5              alarm_min_long_up_down_flag=0;        
 419   5              break;
 420   5            }
 421   4            case 2:
 422   4            {
 423   5              alarm2.minute--;
 424   5              if(alarm2.minute>=60)alarm2.minute=59;
 425   5              alarm_min_long_up_down_flag=0;        
 426   5              break;
 427   5            }     
 428   4            case 3:
 429   4            {
 430   5              alarm3.minute--;
 431   5              if(alarm3.minute>=60)alarm3.minute=59;
 432   5              alarm_min_long_up_down_flag=0;        
 433   5              break;
 434   5            }     
 435   4            
 436   4            default :
 437   4            break;      
 438   4          }
 439   3          long_add_flag=0;
 440   3          second=0;
 441   3          while(!UP);
 442   3          if(long_flag==0)
 443   3          {
 444   4            UP_Short_Flag=1;
 445   4            second=0;
 446   4          }
 447   3        }
 448   2      
 449   2      //down按键
 450   2        if(DOWN==0)
 451   2        {
 452   3      
 453   3          time0_setup( );
 454   3          while(!DOWN)
 455   3          {
 456   4          //  pm_12_24_alarm_display();
 457   4            if(SET_Long_Flag==1)
 458   4            {
 459   5             key_dislpay_up_down( );
 460   5            }
 461   4            if(second==1)
 462   4            {
 463   5                back_TIME_Flag=0;
 464   5                if(mode_select_flag==0)
 465   5                {
 466   6                  temp_delay_time=0; //DP1计数清0
 467   6                  mon_day_delay_time=0;
 468   6                  hor_min_delay_time=0; 
 469   6                }
 470   5                
 471   5              long_add_flag=1;
 472   5              
 473   5              long_flag=1;
 474   5              DOWN_Long_Flag=1;
 475   5              if(SET_Long_Flag==1)
 476   5              {
 477   6                switch (flag_display)
 478   6                {
 479   7                  case 0:
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 9   

 480   7                  {
 481   8                   if(SET_Short_Flag_hur_min==1)
 482   8                   {
 483   9                     hour_long_up_down(1);
 484   9                   }  
 485   8                    if(SET_Short_Flag_hur_min==2)
 486   8                   {
 487   9                    min_long_up_down(1) ;
 488   9                   }            
 489   8                    break;
 490   8                  }
 491   7                  case 1:
 492   7                  {
 493   8                   if(SET_Short_Flag_mon_day==0)
 494   8                   {
 495   9                    year_long_up_down(1);
 496   9                   }
 497   8                   if(SET_Short_Flag_mon_day==1)
 498   8                   {
 499   9                    mon_long_up_down(1);
 500   9                   }
 501   8                   if(SET_Short_Flag_mon_day==2)
 502   8                   {
 503   9                    mday_long_up_down(1);
 504   9                   }             
 505   8                  
 506   8                    break;
 507   8                  }
 508   7                  case 2:
 509   7                  {
 510   8                    if(SET_Short_Flag_alarm1_flag==0) 
 511   8                    {
 512   9                       alarm_hour_long_up_down(1,2,  alarm1);
 513   9                      
 514   9                    }
 515   8                    if(SET_Short_Flag_alarm1_flag==1) 
 516   8                    {
 517   9                       alarm_min_long_up_down(1,2,alarm1);
 518   9                    }               
 519   8                    break;
 520   8                  }
 521   7                  case 3:
 522   7                  {
 523   8                    if(SET_Short_Flag_alarm1_flag==0) 
 524   8                    {
 525   9                       alarm_hour_long_up_down(2,2,alarm2);
 526   9                    }
 527   8                    if(SET_Short_Flag_alarm1_flag==1) 
 528   8                    {
 529   9                       alarm_min_long_up_down(2,2, alarm2);
 530   9                    }             
 531   8                    break;
 532   8                  }
 533   7                  case 4:
 534   7                  {
 535   8                    if(SET_Short_Flag_alarm1_flag==0) 
 536   8                    {
 537   9                       alarm_hour_long_up_down(3,2, alarm3);
 538   9                    }
 539   8                    if(SET_Short_Flag_alarm1_flag==1) 
 540   8                    {
 541   9                       alarm_min_long_up_down(3,2, alarm3);
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 10  

 542   9                    }                       
 543   8                    break;
 544   8                  }
 545   7                  default :
 546   7                  break;
 547   7                              
 548   7                }
 549   6      
 550   6                  
 551   6              } 
 552   5              if(flag_display==5&&ADC_ONE==1)
 553   5              {
 554   6                if(ADC_Display==0)ADC_Display=1;
 555   6                else ADC_Display=0;
 556   6                  adc_switch( );
 557   6      //          switch (ADC_Display)
 558   6      //           {
 559   6      //             
 560   6      //             case 0:
 561   6      //             {
 562   6      //                
 563   6      //               
 564   6      //               //FD612_display_4DIG_input(0x00,dis[(unsigned char)TEM2/10],dis[(unsigned char)TEM2%10],FD612_DI
             -SP_C);   
 565   6      //                FD612_PotiveTNage(FD612_DIG1_ADDR,0x00);
 566   6      //                FD612_PotiveTNage(FD612_DIG2_ADDR,dis[(unsigned char)TEM2/10]);
 567   6      //                FD612_PotiveTNage(FD612_DIG3_ADDR,dis[(unsigned char)TEM2%10]);
 568   6      //                FD612_PotiveTNage(FD612_DIG4_ADDR,FD612_DISP_cc);
 569   6      //                FD612_DispBuff.DispData[FD612_DIG12_ADDR]|= 1<<6 ; 
 570   6      //                FD612_Refresh();
 571   6      //               ADC_Display1=0;
 572   6      //               break;
 573   6      //             }
 574   6      //              
 575   6      
 576   6      //              case 1:
 577   6      //              {
 578   6      //              ADC_AVG_NUM[2]   = (unsigned char)TEM4/100;
 579   6      //              ADC_AVG_NUM[1]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )/10;
 580   6      //              ADC_AVG_NUM[0]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )%10;
 581   6      ////              FD612_display_4DIG_input(dis[ADC_AVG_NUM[2]],dis[ADC_AVG_NUM[1]],dis[ADC_AVG_NUM[0]],FD612_DISP
             -_F);
 582   6      //              FD612_PotiveTNage(FD612_DIG1_ADDR,dis[ADC_AVG_NUM[2]]);
 583   6      //              FD612_PotiveTNage(FD612_DIG2_ADDR,dis[ADC_AVG_NUM[1]]);
 584   6      //              FD612_PotiveTNage(FD612_DIG3_ADDR,dis[ADC_AVG_NUM[0]] );
 585   6      //                FD612_PotiveTNage(FD612_DIG4_ADDR,FD612_DISP_F);
 586   6      
 587   6      //              FD612_Refresh();  
 588   6      //                ADC_Display1=1;
 589   6      ////                ADC_Display=0;
 590   6      //                break;
 591   6      //              } 
 592   6      //                default :
 593   6      //                break;
 594   6      //          }
 595   6                ADC_ONE=0;
 596   6              }
 597   5            }
 598   4        
 599   4          }
 600   3          switch(alarm_hour_long_up_down_flag)
 601   3          {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 11  

 602   4            case 4:
 603   4            {
 604   5              alarm1.hour++;
 605   5              if(hour_12_24_flag)
 606   5              {
 607   6                if(alarm1.hour==13)alarm1.hour=1;
 608   6              }
 609   5              else 
 610   5              {
 611   6                if(alarm1.hour>=24)alarm1.hour=0;
 612   6              }       
 613   5              alarm_hour_long_up_down_flag=0;       
 614   5              break;
 615   5            }     
 616   4            case 5:
 617   4            {
 618   5              alarm2.hour++;
 619   5              if(hour_12_24_flag)
 620   5              {
 621   6                if(alarm2.hour==13)alarm2.hour=1;
 622   6              }
 623   5              else 
 624   5              {
 625   6                if(alarm2.hour>=24)alarm2.hour=0;
 626   6              }         
 627   5              alarm_hour_long_up_down_flag=0;       
 628   5              break;
 629   5            }
 630   4            case 6:
 631   4            {
 632   5              alarm3.hour++;
 633   5              if(hour_12_24_flag)
 634   5              {
 635   6                if(alarm3.hour==13)alarm3.hour=1;
 636   6              }
 637   5              else 
 638   5              {
 639   6                if(alarm3.hour>=24)alarm3.hour=0;
 640   6              }         
 641   5              alarm_hour_long_up_down_flag=0;       
 642   5              break;
 643   5            }
 644   4            default :
 645   4            break;      
 646   4          }
 647   3          switch(alarm_min_long_up_down_flag)
 648   3          {
 649   4            case 4:
 650   4            {
 651   5              alarm1.minute++;
 652   5              if(alarm1.minute==60)alarm1.minute=0;
 653   5              alarm_min_long_up_down_flag=0;        
 654   5              break;
 655   5            }     
 656   4            case 5:
 657   4            {
 658   5              alarm2.minute++;
 659   5              if(alarm2.minute==60)alarm2.minute=0;
 660   5              alarm_min_long_up_down_flag=0;        
 661   5              break;
 662   5            }
 663   4            case 6:
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 12  

 664   4            {
 665   5              alarm3.minute++;
 666   5              if(alarm3.minute==60)alarm3.minute=0;
 667   5              alarm_min_long_up_down_flag=0;        
 668   5              break;
 669   5            }     
 670   4            default :
 671   4            break;      
 672   4          }
 673   3          long_add_flag=0;
 674   3          ADC_ONE=1;
 675   3          second=0;
 676   3          while(!DOWN);
 677   3          if(long_flag==0)
 678   3          {
 679   4            DOWN_Short_Flag=1;
 680   4            second=0;
 681   4          }
 682   3        }
 683   2      }
 684   1      if(alarm_flag==1)
 685   1      {
 686   2        if(SET==0||UP==0||DOWN==0)
 687   2        {
 688   3          alarm_flag=0;
 689   3          PWM_CTRL &= ~(1<<3);
 690   3          alarm_voice_flag=0;   
 691   3        }
 692   2      }
 693   1      if(alarm2_flag==1)
 694   1      {
 695   2        if(SET==0||UP==0||DOWN==0)
 696   2        {
 697   3          alarm2_flag=0;
 698   3          PWM_CTRL &= ~(1<<3);
 699   3          alarm2_voice_flag=0;
 700   3        }
 701   2      }
 702   1      if(alarm3_flag==1)
 703   1      {
 704   2        if(SET==0||UP==0||DOWN==0)
 705   2        {
 706   3          alarm3_flag=0;
 707   3          PWM_CTRL &= ~(1<<3);
 708   3          alarm3_voice_flag=0;    
 709   3        }
 710   2      }
 711   1      
 712   1      }
 713          void display(void)
 714          {
 715   1      //  UINT8 pm_flag;
 716   1      //    temper_display();
 717   1          from_ds1302_read_time_data( );
 718   1          if(SET_Long_Flag==0)
 719   1          {
 720   2          if(SET_Short_Flag)
 721   2          {
 722   3            flag_display++;
 723   3            SET_Short_Flag=0;
 724   3            if(flag_display>5)
 725   3            {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 13  

 726   4              flag_display=0;
 727   4              ADC_fisrt=1;
 728   4            }
 729   3          }
 730   2      //    if(time.hour>=13&&hour_12_24_flag==1)
 731   2      //    {
 732   2      //      time.hour=time.hour-12;
 733   2      //      if(hour_pm_flag)hour_pm_flag=0;
 734   2      //      else hour_pm_flag=1;
 735   2      //      time.hour = decimal_bcd(time.hour);
 736   2      //     ResetDS1302();
 737   2      //     WriteByteDS1302(hour_w_addr); //写入时的地址
 738   2      //     WriteByteDS1302(time.hour);                                  
 739   2      //    time.hour = bcd_decimal(time.hour);     
 740   2      //    }
 741   2          }
 742   1      
 743   1          switch(flag_display)
 744   1          {
 745   2            case 0:
 746   2              {
 747   3      
 748   3      
 749   3      
 750   3                    if(display_flag_hur_min)
 751   3                    {
 752   4                        point_blink();
 753   4                                      
 754   4      
 755   4                    
 756   4                    
 757   4      
 758   4      //              after_arrive_write_1302();  
 759   4                    }
 760   3                    if(SET_Long_Flag)
 761   3                    {
 762   4                      if(key_first)
 763   4                      {
 764   5                        key_first=0;
 765   5                        UP_Short_Flag=0;
 766   5                        DOWN_Short_Flag = 0;
 767   5                      }
 768   4                      display_flag_hur_min=0;
 769   4                      if(SET_Short_Flag)
 770   4                      {
 771   5                        SET_Short_Flag_hur_min++;
 772   5                        SET_Short_Flag=0;
 773   5                        if(SET_Short_Flag_hur_min>4)
 774   5                        {
 775   6                          SET_Short_Flag_hur_min=0;
 776   6                        }
 777   5                      }
 778   4                      if(SET_Short_Flag_hur_min==0)
 779   4                      {
 780   5                          display_12_24_blink( ); 
 781   5                          if(UP_Short_Flag==1)
 782   5                          {
 783   6                              if(hour_12_24_flag)
 784   6                              {
 785   7                                hour_12_24_flag=0;
 786   7                                hour_chage_input(hour_12_24_flag);
 787   7                                if(alarm1_pm_flag)
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 14  

 788   7                            {
 789   8                              if(alarm1.hour!=12)
 790   8                              {
 791   9                                alarm1.hour=alarm1.hour+12;
 792   9                              }
 793   8                              alarm1_pm_flag=0;
 794   8                            }
 795   7                            else if(alarm1.hour==12)alarm1.hour=0;
 796   7                            
 797   7                            if(alarm2_pm_flag)
 798   7                            {
 799   8                              if(alarm2.hour!=12)
 800   8                              {
 801   9                                alarm2.hour=alarm2.hour+12;
 802   9                              }
 803   8                              alarm2_pm_flag=0;
 804   8                            }
 805   7                            else if(alarm2.hour==12)alarm2.hour=0;
 806   7                            
 807   7                            if(alarm3_pm_flag)
 808   7                            {
 809   8                              if(alarm3.hour!=12)
 810   8                              {
 811   9                                alarm3.hour=alarm3.hour+12;
 812   9                              }
 813   8                              alarm3_pm_flag=0;
 814   8                            }
 815   7                            else if(alarm3.hour==12)alarm3.hour=0;  
 816   7                              }
 817   6                              
 818   6                              else  
 819   6                              {
 820   7                                hour_12_24_flag=1;
 821   7                                hour_chage_input(hour_12_24_flag);    
 822   7                            if(alarm1.hour>12)
 823   7                            {
 824   8                              alarm1.hour=alarm1.hour-12;
 825   8                              alarm1_pm_flag=1;
 826   8                            }
 827   7                            if(alarm1.hour==12)alarm1_pm_flag=1;
 828   7                            if(alarm1.hour==0){alarm1.hour=12;alarm1_pm_flag=0;}
 829   7                            
 830   7                            if(alarm2.hour>12)
 831   7                            {
 832   8                              alarm2.hour=alarm2.hour-12;
 833   8                              alarm2_pm_flag=1;
 834   8                            }
 835   7                            if(alarm2.hour==12)alarm2_pm_flag=1;
 836   7                            if(alarm2.hour==0){alarm2.hour=12;alarm2_pm_flag=0;}
 837   7                            
 838   7                            if(alarm3.hour>12)
 839   7                            {
 840   8                              alarm3.hour=alarm3.hour-12;
 841   8                              alarm3_pm_flag=1;
 842   8                            }
 843   7                            if(alarm3.hour==12)alarm3_pm_flag=1;
 844   7                            if(alarm3.hour==0){alarm3.hour=12;alarm3_pm_flag=0;}                          
 845   7                              }
 846   6                              UP_Short_Flag=0;
 847   6                                                                                        
 848   6                        }
 849   5                      }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 15  

 850   4                      if(SET_Short_Flag_hur_min==1)
 851   4                      {
 852   5      //                  if(hour_12_24_flag==1)
 853   5      //                  {
 854   5      //                    time.hour<<=3;
 855   5      //                    time.hour>>=3;
 856   5      //                    time.hour &=~(1<<7);
 857   5      //                    time.hour &=~(1<<5);
 858   5      //                  }
 859   5                      FD612_DISPLAY_2DIG_input(2, dis[time.minute/10] ,dis[time.minute%10]);  
 860   5                      if(time1_second)
 861   5                      {
 862   6                      if(blink_flag)
 863   6                      { 
 864   7                        blink_flag=0;
 865   7                        FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10] , dis[time.hour%10]);
 866   7                      }
 867   6                      else
 868   6                      {
 869   7                        blink_flag=1; 
 870   7                        FD612_DISPLAY_2DIG_input(1 ,0x00 ,0x00  );
 871   7                      }
 872   6                      time1_second=0;
 873   6                      }
 874   5                      if(UP_Short_Flag==1)
 875   5                      {                   
 876   6                          time.hour++;
 877   6                        if(hour_12_24_flag){
 878   7                           if(time.hour>=13)
 879   7                           {
 880   8                             time.hour = 1;                  
 881   8                             
 882   8                           }
 883   7                        if(time.hour==12) after_arrive_write_1302();
 884   7                          }
 885   6                        else
 886   6                        {
 887   7                          if(time.hour >=24)
 888   7                          {
 889   8                            time.hour = 0;
 890   8                          }
 891   7                        }
 892   6                          UP_Short_Flag=0;
 893   6                      }
 894   5                        if(DOWN_Short_Flag == 1)
 895   5                      {
 896   6                          time.hour--;  
 897   6                        if(hour_12_24_flag){
 898   7                           if(time.hour>=13||time.hour==0)
 899   7                           {
 900   8                              time.hour = time.hour -244; //溢出值
 901   8                         
 902   8                             
 903   8                           }
 904   7                        if(time.hour==11) after_arrive_write_1302();                   
 905   7                          }
 906   6                        else
 907   6                        {
 908   7                          if(time.hour >=24)
 909   7                          {
 910   8                            time.hour = time.hour -232; //溢出值
 911   8                          }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 16  

 912   7                        }                 
 913   6      
 914   6                          DOWN_Short_Flag = 0;
 915   6                      }
 916   5                      time.hour = decimal_bcd(time.hour);
 917   5      //                ResetDS1302();
 918   5      //                WriteByteDS1302(hour_w_addr); //写入时的地址
 919   5                      if(hour_12_24_flag)
 920   5                      {
 921   6                        time.hour |=1<<7;
 922   6                        if(hour_pm_flag)time.hour |=1<<5;
 923   6                        else time.hour &=~(1<<5);
 924   6                      }
 925   5                      else time.hour &=~(1<<7);
 926   5                      Write_addr_byte_ds1302(hour_w_addr,time.hour);
 927   5      //                ResetDS1302();
 928   5      //                WriteByteDS1302(hour_w_addr); //写入时的地址                
 929   5      //                WriteByteDS1302(time.hour);
 930   5      //                ResetDS1302();
 931   5                      }
 932   4                      if(SET_Short_Flag_hur_min==2)
 933   4                      {
 934   5                        FD612_DispBuff.DispData[12]|=1<<2;
 935   5                        FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10]  ,dis[time.hour%10]);
 936   5                        if(time1_second)
 937   5                        {
 938   6                          if(blink_flag)
 939   6                          {
 940   7                            blink_flag=0;
 941   7                            
 942   7                            FD612_PotiveTNage(FD612_DIG3_ADDR,dis[time.minute/10]);
 943   7                            FD612_PotiveTNage(FD612_DIG4_ADDR,dis[time.minute%10]);
 944   7                            pm_12_24_alarm_display();
 945   7                            FD612_Refresh();
 946   7                          }
 947   6                        else
 948   6                          {
 949   7                            blink_flag=1;
 950   7                            FD612_PotiveTNage(FD612_DIG3_ADDR,0x00);
 951   7                            FD612_PotiveTNage(FD612_DIG4_ADDR,0x00);
 952   7                            pm_12_24_alarm_display();
 953   7                            FD612_Refresh();
 954   7                            
 955   7                          }
 956   6                          time1_second=0;
 957   6                         }
 958   5                          if(UP_Short_Flag == 1)
 959   5                          {
 960   6                              time.minute++;
 961   6                            if(time.minute >=60)
 962   6                            {
 963   7                              time.minute = 0;
 964   7                            }
 965   6                              UP_Short_Flag = 0;
 966   6                            
 967   6                            Write_addr_byte_ds1302(sec_w_addr,0);
 968   6      //                      ResetDS1302();
 969   6      //                      WriteByteDS1302(sec_w_addr); //写入秒的地址
 970   6      //                      WriteByteDS1302(0);
 971   6                          }
 972   5                          if(DOWN_Short_Flag == 1)
 973   5                          {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 17  

 974   6                              time.minute--;
 975   6                            if(time.minute>60)
 976   6                            {
 977   7                                time.minute = time.minute -196; //溢出值
 978   7                            }
 979   6                              DOWN_Short_Flag = 0;
 980   6                              Write_addr_byte_ds1302(sec_w_addr,0);
 981   6      //                        ResetDS1302();
 982   6      //                        WriteByteDS1302(sec_w_addr); //写入秒的地址
 983   6      //                        WriteByteDS1302(0); 
 984   6      
 985   6                          }
 986   5                          time.minute = decimal_bcd(time.minute);
 987   5                          
 988   5                          Write_addr_byte_ds1302(min_w_addr,time.minute);
 989   5      //                    ResetDS1302();
 990   5      //                    WriteByteDS1302(min_w_addr); //写入秒的地址
 991   5      //                    WriteByteDS1302(time.minute);
 992   5                      }
 993   4                      if(SET_Short_Flag_hur_min==3)
 994   4                      {
 995   5                        display_flag_hur_min=1;
 996   5                        SET_Long_Flag=0;
 997   5                        SET_Short_Flag_hur_min=0;
 998   5                        key_first=1;
 999   5                      }
1000   4                      if(back_first)
1001   4                      {
1002   5                        back_TIME_Flag=0;
1003   5                        back_first=0;
1004   5                      }
1005   4                      if(back_TIME_Flag==over_time)
1006   4                      {
1007   5                        display_flag_hur_min=1; 
1008   5                        SET_Long_Flag=0;
1009   5                        SET_Short_Flag_hur_min=0;
1010   5                        back_TIME_Flag=0;
1011   5                        back_first=1;
1012   5                        key_first=1;
1013   5                        dp_mode_exit();
1014   5                        if(mode_select_flag==2) flag_display=0;
1015   5                      }
1016   4                    
1017   4                      
1018   4                    }
1019   3                    break;          
1020   3              }
1021   2              case 1:
1022   2                {
1023   3      
1024   3                    
1025   3              
1026   3      
1027   3      
1028   3                if(SET_Long_Flag)
1029   3                {
1030   4                      if(key_first)
1031   4                      {
1032   5                        key_first=0;
1033   5                        UP_Short_Flag=0;
1034   5                        DOWN_Short_Flag = 0;
1035   5                      }           
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 18  

1036   4                  display_flag_mon_day=0;
1037   4                
1038   4                if(SET_Short_Flag)
1039   4                      {
1040   5                        SET_Short_Flag_mon_day++;
1041   5                        SET_Short_Flag=0;
1042   5                        if(SET_Short_Flag_mon_day>4)
1043   5                        {
1044   6                          SET_Short_Flag_mon_day=0;
1045   6                        }
1046   5                      }
1047   4                if(SET_Short_Flag_mon_day==0)
1048   4                {
1049   5                year_blink(0);
1050   5                if(UP_Short_Flag == 1)
1051   5                {
1052   6                    time.year++;  
1053   6                    if(time.year>99)time.year=0;
1054   6                    UP_Short_Flag = 0;
1055   6                }
1056   5                if(DOWN_Short_Flag == 1)
1057   5                {
1058   6                    time.year--;
1059   6                    DOWN_Short_Flag = 0;
1060   6                } 
1061   5                time.year= decimal_bcd(time.year);
1062   5                Write_addr_byte_ds1302(year_w_addr,time.year);
1063   5      //          ResetDS1302();
1064   5      //          WriteByteDS1302(year_w_addr); //写入秒的地址
1065   5      //          WriteByteDS1302(time.year);
1066   5                
1067   5                }
1068   4                if(SET_Short_Flag_mon_day==1)
1069   4                {
1070   5                        
1071   5                      FD612_DISPLAY_2DIG_input(2,dis[time.mday/10] ,dis[time.mday%10] );
1072   5                      if(time1_second)
1073   5                      {
1074   6                      if(blink_flag)
1075   6                      {
1076   7                        blink_flag=0; 
1077   7                        FD612_DISPLAY_2DIG_input(1 ,dis[time.month/10] ,dis[time.month%10] );
1078   7                      }
1079   6                      else
1080   6                      {
1081   7                        blink_flag=1;
1082   7                        FD612_DISPLAY_2DIG_input(1 ,0x00  ,0x00 );
1083   7                      }
1084   6                      time1_second=0;
1085   6                      }
1086   5                if(UP_Short_Flag == 1)
1087   5                {
1088   6                    time.month++;
1089   6                  
1090   6                  if(time.month >=13)
1091   6                  {
1092   7                    time.month = 1;
1093   7                  }
1094   6                    UP_Short_Flag = 0;
1095   6                }
1096   5                if(DOWN_Short_Flag == 1)
1097   5                {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 19  

1098   6                    time.month--;
1099   6                    
1100   6                  if(time.month==0 || time.month>13)
1101   6                  {
1102   7                      time.month = time.month -244; //溢出值
1103   7                  }
1104   6                    DOWN_Short_Flag = 0;
1105   6                } 
1106   5                time.month = decimal_bcd(time.month);
1107   5      
1108   5                Write_addr_byte_ds1302(mon_w_addr,time.month);
1109   5      //          ResetDS1302();
1110   5      //          WriteByteDS1302(mon_w_addr); //写入秒的地址
1111   5      //          WriteByteDS1302(time.month);
1112   5                }
1113   4                if(SET_Short_Flag_mon_day==2)
1114   4                      {
1115   5                        
1116   5                        
1117   5                        FD612_DISPLAY_2DIG_input(1 ,dis[time.month/10] ,dis[time.month%10] );
1118   5                        if(time1_second)
1119   5                        {
1120   6                          if(blink_flag)
1121   6                          {
1122   7                            blink_flag=0; 
1123   7                            FD612_DISPLAY_2DIG_input(2,dis[time.mday/10] ,dis[time.mday%10] );
1124   7                          }
1125   6                        else
1126   6                          {
1127   7                            blink_flag=1; 
1128   7                            FD612_DISPLAY_2DIG_input(2,0x00 ,0x00 );
1129   7                          }
1130   6                          time1_second=0;
1131   6                         }
1132   5                       
1133   5                if(UP_Short_Flag >= 1)
1134   5                {
1135   6                    time.mday++;
1136   6                               
1137   6                    if(time.mday>=32)   
1138   6                    {                         
1139   7                          time.mday=1;
1140   7                    }          
1141   6              
1142   6                  UP_Short_Flag = 0;            
1143   6                } 
1144   5                if(DOWN_Short_Flag >= 1)
1145   5                {
1146   6                    time.mday--;
1147   6                    if(time.mday==0 || time.mday >=32)
1148   6                      {               
1149   7                    
1150   7                      time.mday = time.mday -225;
1151   7                      }          
1152   6                                                                              
1153   6                    DOWN_Short_Flag = 0;
1154   6                }         
1155   5                time.mday = decimal_bcd(time.mday);
1156   5                Write_addr_byte_ds1302(day_w_addr,time.mday);
1157   5      //          ResetDS1302();
1158   5      //          WriteByteDS1302(day_w_addr); //写入秒的地址
1159   5      //          WriteByteDS1302(time.mday);
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 20  

1160   5                
1161   5                }
1162   4                       
1163   4                      if(SET_Short_Flag_mon_day==3)
1164   4                      {
1165   5                        display_flag_mon_day=1;
1166   5                        SET_Long_Flag=0;
1167   5                        SET_Short_Flag_mon_day=0;
1168   5                        key_first=1;
1169   5                      }
1170   4                      if(back_first)
1171   4                      {
1172   5                        back_TIME_Flag=0;
1173   5                        back_first=0;
1174   5                      }
1175   4                      if(back_TIME_Flag==over_time)
1176   4                      {
1177   5                        display_flag_mon_day=1; 
1178   5                        SET_Long_Flag=0;
1179   5                        SET_Short_Flag_mon_day=0;
1180   5                        back_TIME_Flag=0;
1181   5                        back_first=1;
1182   5                        key_first=1;
1183   5                        dp_mode_exit();                   
1184   5                      }                 
1185   4                    }
1186   3                    
1187   3                  if(display_flag_mon_day)
1188   3                    {
1189   4                      
1190   4                      FD612_display_4DIG_input( dis[time.month/10] ,dis[time.month% 10] ,dis[time.mday/10] , dis[time.md
             -ay% 10]);
1191   4                    }
1192   3                    
1193   3                    
1194   3      //              if(SET_Long_Flag==0){
1195   3      //              if(back_first)
1196   3      //                {
1197   3      //                  back_TIME_Flag=0;
1198   3      //                  back_first=0;
1199   3      //                }
1200   3      //                if(back_TIME_Flag==over_time)
1201   3      //                {
1202   3      //                  display_flag_mon_day=1; 
1203   3      //                  SET_Long_Flag=0;
1204   3      //                  SET_Short_Flag_mon_day=0;
1205   3      //                  back_TIME_Flag=0;
1206   3      //                  back_first=1;
1207   3      //                  key_first=1;
1208   3      //                  if(mode_select_flag==2) flag_display=0;
1209   3      //                } 
1210   3      //              }
1211   3                  break;            
1212   3                }
1213   2              case 2:
1214   2                {
1215   3      
1216   3                  alarm_set_display(1, alarm1);
1217   3                  break;  
1218   3                }
1219   2              case 3:
1220   2                {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 21  

1221   3      
1222   3                  alarm_set_display(2, alarm2);
1223   3                  break;  
1224   3                }
1225   2              case 4:
1226   2                {
1227   3      
1228   3                  alarm_set_display(3, alarm3);
1229   3                  break;  
1230   3                }
1231   2            
1232   2              case 5:
1233   2              {
1234   3                if(SET_Long_Flag==1)SET_Long_Flag=0;
1235   3                if(UP_Short_Flag)UP_Short_Flag=0;
1236   3                if(ADC_fisrt)
1237   3                {
1238   4                  ADC_Convert( );
1239   4                  ADC_fisrt=0;
1240   4                  ADC_TIME_Flag=0;
1241   4                  
1242   4                }
1243   3                temper_display();
1244   3      //          if(ADC_TIME_Flag==temp_refresh_time)
1245   3      //          {
1246   3      //            ADC_fisrt=1;
1247   3      //            ADC_TIME_Flag=0;
1248   3      //          }
1249   3      //        
1250   3      //      if(ADC_Display1==0)
1251   3      //      {     
1252   3      //      FD612_display_4DIG_input( 0x00 ,dis[(unsigned char)TEM2/10] ,dis[(unsigned char)TEM2%10] ,FD612_DISP_
             -C );
1253   3      //      }
1254   3      //      else
1255   3      //      {
1256   3      //      ADC_AVG_NUM[2]   = (unsigned char)TEM4/100;
1257   3      //      ADC_AVG_NUM[1]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )/10;
1258   3      //      ADC_AVG_NUM[0]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )%10;
1259   3      
1260   3      //      FD612_display_4DIG_input(dis[ADC_AVG_NUM[2]]  , dis[ADC_AVG_NUM[1]],dis[ADC_AVG_NUM[0]]  ,FD612_DISP_
             -F );
1261   3      //      }       
1262   3                if(back_first)
1263   3                {
1264   4                  back_TIME_Flag=0;
1265   4                  back_first=0;
1266   4                }
1267   3                if(back_TIME_Flag==over_time)
1268   3                {                                                   
1269   4                  back_TIME_Flag=0;
1270   4                  back_first=1;
1271   4                  if(mode_select_flag==2) flag_display=0;
1272   4                  dp_mode_exit();                     
1273   4                }
1274   3                break;  
1275   3              }
1276   2              default :
1277   2              break;
1278   2          }
1279   1      }
1280          
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 22  

1281          
1282          
1283          
1284          
1285          
1286          void  ADC_Convert(void) 
1287          {
1288   1          float VCC = 4.77;                          //
1289   1          float ADC_VALUE;                           //
1290   1                                 //
1291   1      //    unsigned int B_value = 3450;
1292   1          unsigned int B_value = 3950;//科艺传感器
1293   1      
1294   1          ADC_CHAN1 =0;
1295   1          ADC_CHAN0=0;
1296   1          P1_DIR_PU &= ~bAIN0;  
1297   1          ADC_START = 1;  
1298   1          while(ADC_START);                                                      //ADC_START变为0时，表示采样完成
1299   1          ADC_VALUE = ADC_DATA * VCC / 255; // 读取转换的AD值   
1300   1        
1301   1          TEM = 1/(log(ADC_VALUE/(VCC - ADC_VALUE))/B_value + 1/(273.15 + 25));
1302   1            
1303   1          TEM4=TEM2*1.8+32;
1304   1          TEM2=TEM- 273.15;
1305   1          
1306   1      }
1307          
1308          
1309          void alarm1_sleep(void)
1310          {
1311   1          UINT8 alarm1_value1,alarm1_value2,alarm1_value3,alarm1_value4,alarm1_value5;
1312   1          if(time.second==0 && time.hour==alarm1.hour && time.minute==alarm1.minute&&hour_pm_flag==alarm1_pm_flag)
1313   1          {
1314   2            alarm_flag=1;
1315   2            alarm_voice_flag=1;
1316   2          }
1317   1          if(alarm_flag)
1318   1          {
1319   2            alarm1_value1=alarm1.minute+alarm_time;
1320   2            alarm1_value2=alarm1.minute+alarm_time+sleep_time;
1321   2            alarm1_value3=alarm1.minute+(alarm_time*2)+sleep_time;
1322   2            alarm1_value4=alarm1.minute+(alarm_time*2)+(sleep_time*2);
1323   2            alarm1_value5=alarm1.minute+(alarm_time*3)+(sleep_time*2);
1324   2            if(alarm_voice_flag)
1325   2            {
1326   3              
1327   3              if(alarm_clock_flag)
1328   3              {
1329   4                if(TR0)
1330   4                {TR0=0;buzzer=0;}
1331   4                else TR0=1;
1332   4                alarm_clock_flag=0;
1333   4              }       
1334   3              
1335   3            }
1336   2            if((alarm1_value1)>=60)
1337   2            {
1338   3              if((alarm1_value1-60)==time.minute)
1339   3              {
1340   4               TR0=0;
1341   4               buzzer=0;
1342   4               alarm_voice_flag=0;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 23  

1343   4              }
1344   3            }
1345   2            else if((alarm1_value1)==time.minute)
1346   2            {
1347   3              TR0=0;
1348   3              buzzer=0;
1349   3              alarm_voice_flag=0;
1350   3            }
1351   2            if((alarm1_value2)>=60)
1352   2            {
1353   3              if((alarm1_value2-60)==time.minute)
1354   3              {
1355   4                alarm_voice_flag=1;
1356   4              }       
1357   3            }
1358   2            else if(alarm1_value2==time.minute)
1359   2            {
1360   3              alarm_voice_flag=1;
1361   3            }
1362   2            if((alarm1_value3)>=60)
1363   2            {
1364   3              if((alarm1_value3-60)==time.minute)
1365   3              {
1366   4                TR0=0;
1367   4                buzzer=0;
1368   4                alarm_voice_flag=0;
1369   4              }       
1370   3            }
1371   2            else if((alarm1_value3)==time.minute)
1372   2            {
1373   3              TR0=0;
1374   3              buzzer=0;
1375   3              alarm_voice_flag=0;
1376   3            }
1377   2            if((alarm1_value4)>=60)
1378   2            {
1379   3              if((alarm1_value4-60)==time.minute)
1380   3              {
1381   4                alarm_voice_flag=1;
1382   4              }       
1383   3            }
1384   2            else if((alarm1_value4)==time.minute)
1385   2            {
1386   3              alarm_voice_flag=1;
1387   3            }
1388   2            if((alarm1_value5)>=60)
1389   2            {
1390   3              if((alarm1_value5-60)==time.minute)
1391   3              {
1392   4                TR0=0;
1393   4                buzzer=0;
1394   4                alarm_voice_flag=0;
1395   4              }     
1396   3            }
1397   2            else if((alarm1_value5)==time.minute)
1398   2            {
1399   3              TR0=0;
1400   3              buzzer=0;
1401   3              alarm_voice_flag=0;
1402   3            }
1403   2      
1404   2          }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 24  

1405   1      
1406   1      }
1407          
1408          void alarm2_sleep(void)
1409          {
1410   1          UINT8 alarm2_value1,alarm2_value2,alarm2_value3,alarm2_value4,alarm2_value5;
1411   1          if(time.second==0 && time.hour==alarm2.hour && time.minute==alarm2.minute&&hour_pm_flag==alarm2_pm_flag)
1412   1          {
1413   2            alarm2_flag=1;
1414   2            alarm2_voice_flag=1;
1415   2          }
1416   1          if(alarm2_flag)
1417   1          {
1418   2            alarm2_value1=alarm2.minute+alarm_time;
1419   2            alarm2_value2=alarm2.minute+alarm_time+sleep_time;
1420   2            alarm2_value3=alarm2.minute+(alarm_time*2)+sleep_time;
1421   2            alarm2_value4=alarm2.minute+(alarm_time*2)+(sleep_time*2);
1422   2            alarm2_value5=alarm2.minute+(alarm_time*3)+(sleep_time*2);
1423   2            
1424   2            if(alarm2_voice_flag)
1425   2            {
1426   3              if(alarm_clock_flag)
1427   3              {
1428   4                if(TR0)
1429   4                {TR0=0;buzzer=0;}
1430   4                else TR0=1;
1431   4                alarm_clock_flag=0;
1432   4              }
1433   3            }
1434   2            if((alarm2_value1)>=60)
1435   2            {
1436   3              if((alarm2_value1-60)==time.minute)
1437   3              {
1438   4                TR0=0;
1439   4                buzzer=0;
1440   4                alarm2_voice_flag=0;
1441   4              }     
1442   3            }
1443   2            else if((alarm2_value1)==time.minute)
1444   2            {
1445   3              TR0=0;
1446   3              buzzer=0;
1447   3              alarm2_voice_flag=0;
1448   3            }
1449   2            if((alarm2_value2)>=60)
1450   2            {
1451   3               if((alarm2_value2-60)==time.minute)
1452   3              {
1453   4                alarm2_voice_flag=1;
1454   4              }
1455   3            }
1456   2            else if((alarm2_value2)==time.minute)
1457   2            {
1458   3              alarm2_voice_flag=1;
1459   3            }
1460   2            if((alarm2_value3)>=60)
1461   2            {
1462   3              if((alarm2_value3-60)>=time.minute)
1463   3              {
1464   4                TR0=0;
1465   4                buzzer=0;
1466   4                alarm2_voice_flag=0;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 25  

1467   4              }
1468   3            }     
1469   2            else if((alarm2_value3)==time.minute)
1470   2            {
1471   3              TR0=0;
1472   3              buzzer=0;
1473   3              alarm2_voice_flag=0;
1474   3            }
1475   2            if((alarm2_value4)>=60)
1476   2            {
1477   3              if((alarm2_value4-60)==time.minute)
1478   3              alarm2_voice_flag=1;
1479   3            }     
1480   2            else if((alarm2_value4)==time.minute)
1481   2            {
1482   3              alarm2_voice_flag=1;
1483   3            }
1484   2            if((alarm2_value5)>=60)
1485   2            {
1486   3            if((alarm2_value5-60)==time.minute)
1487   3            {
1488   4              TR0=0;
1489   4              buzzer=0;
1490   4              alarm2_voice_flag=0;
1491   4            }       
1492   3            }
1493   2            else if((alarm2_value5)==time.minute)
1494   2            {
1495   3              TR0=0;
1496   3              buzzer=0;
1497   3              alarm2_voice_flag=0;
1498   3            }
1499   2      
1500   2          }
1501   1      
1502   1      }
1503          
1504          void alarm3_sleep(void)
1505          {
1506   1          UINT8 alarm3_value1,alarm3_value2,alarm3_value3,alarm3_value4,alarm3_value5;
1507   1          if(time.second==0 && time.hour==alarm3.hour && time.minute==alarm3.minute&&hour_pm_flag==alarm3_pm_flag)
1508   1          {
1509   2            alarm3_flag=1;
1510   2            alarm3_voice_flag=1;
1511   2          }
1512   1          if(alarm3_flag)
1513   1          {
1514   2            alarm3_value1=alarm3.minute+alarm_time;
1515   2            alarm3_value2=alarm3.minute+alarm_time+sleep_time;
1516   2            alarm3_value3=alarm3.minute+(alarm_time*2)+sleep_time;
1517   2            alarm3_value4=alarm3.minute+(alarm_time*2)+(sleep_time*2);
1518   2            alarm3_value5=alarm3.minute+(alarm_time*3)+(sleep_time*2);
1519   2            if(alarm3_voice_flag)
1520   2            {
1521   3              if(alarm_clock_flag)
1522   3              {
1523   4                if(TR0)
1524   4                {TR0=0;buzzer=0;}
1525   4                else TR0=1;
1526   4                alarm_clock_flag=0;
1527   4              }
1528   3            }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 26  

1529   2            if((alarm3_value1)>=60)
1530   2            {
1531   3              if((alarm3_value1-60)==time.minute)
1532   3              {
1533   4                TR0=0;
1534   4                buzzer=0;
1535   4                alarm3_voice_flag=0;
1536   4              }       
1537   3            }
1538   2            else if((alarm3_value1)==time.minute)
1539   2            {
1540   3              TR0=0;
1541   3              buzzer=0;
1542   3              alarm3_voice_flag=0;
1543   3            }
1544   2            
1545   2            if((alarm3_value2)>=60)
1546   2            {
1547   3              if((alarm3_value2-60)==time.minute)
1548   3              {
1549   4                alarm3_voice_flag=1;
1550   4              }       
1551   3            }
1552   2            else if((alarm3_value2)==time.minute)
1553   2            {
1554   3              alarm3_voice_flag=1;
1555   3            }
1556   2            if((alarm3_value3)>=60)
1557   2            {
1558   3              if((alarm3_value3-60)==time.minute)
1559   3              {
1560   4                TR0=0;
1561   4                buzzer=0;
1562   4                alarm3_voice_flag=0;
1563   4              }       
1564   3            }
1565   2            else if((alarm3_value3)==time.minute)
1566   2            {
1567   3              TR0=0;
1568   3              buzzer=0;
1569   3              alarm3_voice_flag=0;
1570   3            }
1571   2            if((alarm3_value4)>=60)
1572   2            {
1573   3              if((alarm3_value4-60)==time.minute)
1574   3              {
1575   4                alarm3_voice_flag=1;
1576   4              }       
1577   3            }
1578   2            else if((alarm3_value4)==time.minute)
1579   2            {
1580   3              alarm3_voice_flag=1;
1581   3            }
1582   2            if((alarm3_value5)>=60)
1583   2            {
1584   3              if((alarm3_value5-60)==time.minute)
1585   3              {
1586   4                TR0=0;
1587   4                buzzer=0;
1588   4                alarm3_voice_flag=0;
1589   4              }       
1590   3            }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 27  

1591   2            else if((alarm3_value5)==time.minute)
1592   2            {
1593   3              TR0=0;
1594   3              buzzer=0;
1595   3              alarm3_voice_flag=0;
1596   3            }
1597   2      
1598   2          }
1599   1      
1600   1      }
1601          
1602          void alarm_display (void)
1603          {
1604   1         if(alarm1_on_dispaly)
1605   1       {
1606   2          alarm1_sleep( );
1607   2       }
1608   1         if(alarm2_on_dispaly)
1609   1       {
1610   2          alarm2_sleep( );
1611   2       }
1612   1         if(alarm3_on_dispaly)
1613   1       {
1614   2          alarm3_sleep( );
1615   2       }
1616   1      }
1617          
1618          
1619          
1620          void voice_control(void)
1621          {
1622   1        if(SET_Long_Flag==0)
1623   1        {
1624   2          if(voice_flag==0)
1625   2          {
1626   3          if(voice_key==1)
1627   3            {
1628   4        
1629   4              if(voice_key==1)
1630   4              {
1631   5                FD612_DispStateWr(FD612_INTENS8|FD612_DISP_ON);  
1632   5                FD612_Refresh();
1633   5              }
1634   4      
1635   4            }
1636   3              else
1637   3              {
1638   4                FD612_DispStateWr(FD612_DISP_OFF); 
1639   4                FD612_Refresh();
1640   4              }     
1641   3          }
1642   2          if(FD612_DispBuff.DispState&0x08)
1643   2              {
1644   3              
1645   3                voice_flag=1;
1646   3                if(voice_fisrt)
1647   3                {
1648   4                  back_voice_Flag=0;
1649   4                  voice_fisrt=0;
1650   4                }
1651   3      
1652   3                if(back_voice_Flag==voice_wake_up_time)
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 28  

1653   3                {
1654   4                  voice_flag=0;
1655   4                  voice_fisrt=1;
1656   4                  flag_display=0;
1657   4                  FD612_DispStateWr(FD612_DISP_OFF); 
1658   4                  FD612_Refresh();
1659   4                  mDelayuS(150);
1660   4              
1661   4                }
1662   3              }
1663   2            }
1664   1      }
1665          
1666          void sd_mode (void)
1667          {
1668   1        if(DOWN_Short_Flag)
1669   1        {
1670   2          up_down_flag=1;//up_down键与模式选择冲突
1671   2      //    if(SET_Long_Flag==0&&flag_display !=5)
1672   2          if(SET_Long_Flag==0&&flag_display ==0)
1673   2          {
1674   3            dislay_all_flag=1;
1675   3            sd_flag++;
1676   3            if(sd_select_first==1)
1677   3                {
1678   4                  sd_flag--;
1679   4                  sd_select_first=0;
1680   4                }
1681   3                if(sd_flag>1)sd_flag=0;     
1682   3              switch(sd_flag)
1683   3              {
1684   4                case 0:
1685   4                {
1686   5                  
1687   5                  FD612_display_4DIG_input(0x40  ,0x40 ,FD612_DISP_S ,FD612_DISP_d  );
1688   5                  sd_mode_flag=0;
1689   5                  break;
1690   5            
1691   5                }
1692   4                case 1: 
1693   4                {
1694   5                  
1695   5                  FD612_display_4DIG_input(0x5c  ,0x54 ,FD612_DISP_S ,FD612_DISP_d );
1696   5                  sd_mode_flag=1;
1697   5                  break;
1698   5                }
1699   4                  default :
1700   4                  break;          
1701   4              }
1702   3          }
1703   2          up_down_flag=0;
1704   2          DOWN_Short_Flag=0;  
1705   2          mode_select_first=1;
1706   2        if(back_first)
1707   2          {
1708   3            back_TIME_Flag=0;
1709   3            back_first=0;
1710   3          }   
1711   2        }
1712   1        if(back_first)
1713   1          {
1714   2            back_TIME_Flag=0;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 29  

1715   2            back_first=0;
1716   2          }
1717   1          if(back_TIME_Flag==over_time  ||SET_Short_Flag==1)
1718   1          {
1719   2      
1720   2            dislay_all_flag=0;
1721   2            back_TIME_Flag=0;
1722   2            back_first=1; 
1723   2            UP_Short_Flag=0;
1724   2            SET_Short_Flag=0;
1725   2            mode_select_first=1;
1726   2            sd_select_first=1;
1727   2      //      up_down_flag=0;
1728   2            
1729   2      
1730   2          }         
1731   1      }
1732          
1733          
1734          void Display_Mode_Select(void)
1735          {
1736   1          if(UP_Short_Flag)
1737   1          {
1738   2              up_down_flag=1;//up_down键与模式选择冲突
1739   2      //        dislay_all_flag=1;
1740   2      
1741   2      //        if(SET_Long_Flag==0&&flag_display !=2&&flag_display !=3&&flag_display !=4)
1742   2            if(SET_Long_Flag==0&&flag_display ==0)
1743   2              {
1744   3                dislay_all_flag=1;
1745   3                  mode_select_flag++;
1746   3                if(mode_select_first==1)
1747   3                {
1748   4                  mode_select_flag--;
1749   4                  mode_select_first=0;
1750   4                }
1751   3                if(mode_select_flag>2)mode_select_flag=0;
1752   3                switch (mode_select_flag)
1753   3                {
1754   4                  case 0:
1755   4                    {
1756   5                      
1757   5                      FD612_display_4DIG_input( FD612_DISP_d ,FD612_DISP_P  ,0x40 ,FD612_DISP_1 );
1758   5                      break;
1759   5                    }
1760   4                  case 1:
1761   4                    {
1762   5                        
1763   5                      FD612_display_4DIG_input( FD612_DISP_d ,FD612_DISP_P ,0x40 ,FD612_DISP_2 );
1764   5                      break;
1765   5                    }
1766   4                  case 2:
1767   4                    {
1768   5                      
1769   5                      FD612_display_4DIG_input( FD612_DISP_d ,FD612_DISP_P ,0x40 ,FD612_DISP_3 );
1770   5                      break;
1771   5                    } 
1772   4                      default :
1773   4                      break;              
1774   4                }
1775   3                          UP_Short_Flag=0;
1776   3                          up_down_flag=0;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 30  

1777   3              }
1778   2      
1779   2              sd_select_first=1;
1780   2                if(back_first)
1781   2                  {
1782   3                    back_TIME_Flag=0;
1783   3                    back_first=0;
1784   3                  }
1785   2          }
1786   1            if(back_first)
1787   1          {
1788   2            back_TIME_Flag=0;
1789   2            back_first=0;
1790   2          }
1791   1      //    if(back_TIME_Flag==over_time ||SET_Short_Flag==1 )
1792   1      //    {
1793   1      //      FD612_DispBuff.DispData[FD612_DIG1_ADDR]=0x00 ; 
1794   1      //      FD612_DispBuff.DispData[FD612_DIG2_ADDR]=0x00 ;
1795   1      //      FD612_DispBuff.DispData[FD612_DIG3_ADDR]=0x00; 
1796   1      //      FD612_DispBuff.DispData[FD612_DIG4_ADDR]=0x00 ;
1797   1      //      FD612_Refresh();
1798   1      
1799   1      //      dislay_all_flag=0;
1800   1      //      back_TIME_Flag=0;
1801   1      //      back_first=1; 
1802   1      //      UP_Short_Flag=0;
1803   1      //      SET_Short_Flag=0;
1804   1      //      mode_select_first=1;
1805   1      //      up_down_flag=1;
1806   1      //    }
1807   1      
1808   1      }
1809          void mode1_select_dislay(void)
1810          {
1811   1          if(mode_select_flag==0)
1812   1          {
1813   2            if(SET_Long_Flag==0)
1814   2            {
1815   3            if(hor_min_delay_time==over_time_2s)
1816   3            {
1817   4              flag_display=5;
1818   4              hor_min_delay_time=0;
1819   4              
1820   4            }
1821   3            if(mon_day_delay_time==over_time_10s)
1822   3            {
1823   4              flag_display=1;
1824   4              mon_day_delay_time=0;
1825   4            }
1826   3            if(temp_delay_time==over_time_2s)
1827   3            {
1828   4              flag_display=0;
1829   4              temp_delay_time=0;
1830   4            } 
1831   3          }
1832   2            
1833   2          }
1834   1      }
1835          
1836          
1837          
1838          void year_long_up_down(UINT8 i)
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 31  

1839          {
1840   1      //      ResetDS1302();
1841   1      //      WriteByteDS1302(year_r_addr); //读取分的地址        
1842   1      //      time.year=ReadByteDS1302();
1843   1      //      ResetDS1302();
1844   1            time.year=Read_addr_byte_ds1302(year_r_addr); 
1845   1            time.year = bcd_decimal(time.year);
1846   1            if(i==1)time.year--;
1847   1            if(i==0)
1848   1            {
1849   2              time.year++;
1850   2              if(time.year>99)time.year=0;
1851   2                
1852   2            }
1853   1                     
1854   1            FD612_display_4DIG_input( dis[2] ,dis[0] ,dis[time.year/10] , dis[ time.year% 10]);
1855   1            time.year = decimal_bcd(time.year);
1856   1            Write_addr_byte_ds1302(year_w_addr,time.year);
1857   1      //      ResetDS1302();
1858   1      //      WriteByteDS1302(year_w_addr); //写入时的地址
1859   1      //      WriteByteDS1302(time.year);
1860   1      //      ResetDS1302();  
1861   1            mDelaymS(up_down_delay_time); 
1862   1            time.year = bcd_decimal(time.year);
1863   1      }
1864          
1865          void hour_long_up_down(UINT8 i)
1866          {
1867   1      //        ResetDS1302();              
1868   1      //        WriteByteDS1302(hour_r_addr); //读取时的地址
1869   1      //        time.hour=ReadByteDS1302();
1870   1              time.hour=Read_addr_byte_ds1302(hour_r_addr);       
1871   1              if(hour_12_24_flag==1)
1872   1              {
1873   2                time.hour<<=3;
1874   2                time.hour>>=3;
1875   2      //          time.hour &=~(1<<7);
1876   2      //          time.hour &=~(1<<5);
1877   2              }
1878   1              time.hour = bcd_decimal(time.hour);
1879   1              if(i==0) 
1880   1              {
1881   2                time.hour++;
1882   2                if(hour_12_24_flag){
1883   3                   if(time.hour>=13)
1884   3                   {
1885   4                     time.hour = 1;
1886   4      //               ResetDS1302();             
1887   4      //               WriteByteDS1302(hour_r_addr); //读取时的地址
1888   4      //               hour_chage_state=ReadByteDS1302();
1889   4                    
1890   4                   }
1891   3                   if(time.hour==12)
1892   3                   {
1893   4                     hour_chage_state=Read_addr_byte_ds1302(hour_r_addr); 
1894   4                     if(hour_chage_state&0x20)
1895   4                     {
1896   5      //                 hour_chage_state &=~(1<<5);
1897   5                       hour_pm_flag=0;
1898   5                     }
1899   4                     else 
1900   4                     {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 32  

1901   5      //                 hour_chage_state |=(1<<5);
1902   5                       hour_pm_flag=1;
1903   5                     }               
1904   4                    }
1905   3                  }
1906   2                else
1907   2                {
1908   3                  if(time.hour >=24)
1909   3                  {
1910   4                    time.hour = 0;
1911   4                  } 
1912   3                }
1913   2              
1914   2              }
1915   1              if(i==1)
1916   1              { 
1917   2                  time.hour--;
1918   2                  if(hour_12_24_flag){
1919   3                     if(time.hour>=13||time.hour==0)
1920   3                     {
1921   4                      time.hour = time.hour -244; //溢出值
1922   4      //               ResetDS1302();             
1923   4      //               WriteByteDS1302(hour_r_addr); //读取时的地址
1924   4      //               hour_chage_state=ReadByteDS1302();
1925   4      
1926   4                     }
1927   3                       if(time.hour==11)
1928   3                       {
1929   4                         hour_chage_state=Read_addr_byte_ds1302(hour_r_addr);
1930   4                         if(hour_chage_state&0x20)
1931   4                         {
1932   5      //                     hour_chage_state &=~(1<<5);
1933   5                           hour_pm_flag=0;
1934   5                         }
1935   4                         else 
1936   4                         {
1937   5      //                     hour_chage_state |=(1<<5);
1938   5                           hour_pm_flag=1;
1939   5                         }               
1940   4                      }              
1941   3                    }
1942   2                  else
1943   2                  {
1944   3                    if(time.hour >=24)
1945   3                    {
1946   4                      time.hour = time.hour -232; //溢出值
1947   4                    }
1948   3                  }         
1949   2                
1950   2              }
1951   1              FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10]  ,dis[time.hour% 10] );
1952   1      
1953   1             time.hour = decimal_bcd(time.hour);
1954   1              if(hour_12_24_flag)
1955   1              {
1956   2                time.hour |=1<<7;
1957   2                if(hour_pm_flag)time.hour |=1<<5;
1958   2                else time.hour &=~(1<<5);
1959   2              }
1960   1              else time.hour &=~(1<<7);
1961   1              Write_addr_byte_ds1302(hour_w_addr,time.hour);
1962   1      //       ResetDS1302();
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 33  

1963   1      //       WriteByteDS1302(hour_w_addr); //写入时的地址
1964   1      //       WriteByteDS1302(time.hour);
1965   1      //       ResetDS1302();
1966   1             mDelaymS(up_down_delay_time);
1967   1            time.hour = bcd_decimal(time.hour);
1968   1              
1969   1      //            if(hour_12_24_flag==1)
1970   1      //          {
1971   1      //            if(hour_pm_flag==1)
1972   1      //            {
1973   1      ////                FD612_DispBuff.DispData[FD612_DIG5_ADDR]=FD612_DISP_P ;
1974   1      //                FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<1) ;
1975   1      //                FD612_Refresh();    
1976   1      //            }
1977   1      //            else 
1978   1      //            {
1979   1      ////                FD612_DispBuff.DispData[FD612_DIG5_ADDR]=FD612_DISP_A ; 
1980   1      //                FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<1) ;
1981   1      //                FD612_Refresh();    
1982   1      //            }
1983   1      //          }
1984   1      //  
1985   1      }
1986          
1987          void min_long_up_down(UINT8 i) 
1988          {
1989   1      //      ResetDS1302();
1990   1      //      WriteByteDS1302(min_r_addr); //读取分的地址       
1991   1      //      time.minute=ReadByteDS1302();
1992   1      //      ResetDS1302();
1993   1            time.minute=Read_addr_byte_ds1302(min_r_addr);  
1994   1            time.minute = bcd_decimal(time.minute);
1995   1            if(i==0)
1996   1            {
1997   2              time.minute++;
1998   2              if(time.minute >=60)
1999   2              {
2000   3                time.minute = 0;
2001   3              }
2002   2            }
2003   1            if(i==1)
2004   1            {
2005   2            time.minute--;
2006   2            if(time.minute>60)
2007   2            {
2008   3                time.minute = time.minute -196; //溢出值
2009   3            } 
2010   2            }
2011   1      
2012   1            FD612_DISPLAY_2DIG_input(2,dis[time.minute/10] ,dis[ time.minute% 10] );
2013   1            time.minute = decimal_bcd(time.minute);
2014   1      
2015   1              Write_addr_byte_ds1302(min_w_addr,time.minute);
2016   1              Write_addr_byte_ds1302(sec_w_addr,0);
2017   1          
2018   1      //        ResetDS1302();
2019   1      //        WriteByteDS1302(min_w_addr); //写入分的地址
2020   1      //        WriteByteDS1302(time.minute);
2021   1      //        ResetDS1302();
2022   1      //        WriteByteDS1302(sec_w_addr); //写入秒的地址
2023   1      //        WriteByteDS1302(0);
2024   1      //        ResetDS1302();
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 34  

2025   1            time.minute = bcd_decimal(time.minute);
2026   1            mDelaymS(up_down_delay_time);
2027   1      }
2028          void mon_long_up_down(UINT8 i)
2029          {
2030   1      //      ResetDS1302();
2031   1      //      WriteByteDS1302(mon_r_addr); //读取分的地址       
2032   1      //      time.month=ReadByteDS1302();
2033   1      //      ResetDS1302();
2034   1            time.month=Read_addr_byte_ds1302(mon_r_addr);
2035   1            time.month = bcd_decimal(time.month); 
2036   1            if(i==0)
2037   1            {
2038   2              time.month++;
2039   2              if(time.month >=13)
2040   2              {
2041   3                time.month = 1;
2042   3              }
2043   2            }
2044   1            if(i==1)
2045   1            {
2046   2            time.month--;
2047   2            if(time.month==0 || time.month>13)
2048   2            {
2049   3                  time.month = time.month -244; //溢出值
2050   3            } 
2051   2            } 
2052   1        
2053   1            
2054   1            FD612_DISPLAY_2DIG_input(1 ,dis[time.month/10] , dis[time.month% 10]);
2055   1            time.month = decimal_bcd(time.month);
2056   1      
2057   1              Write_addr_byte_ds1302(mon_w_addr,time.month);
2058   1      
2059   1      //      ResetDS1302();
2060   1      //      WriteByteDS1302(mon_w_addr); //写入分的地址
2061   1      //      WriteByteDS1302(time.month);
2062   1      //      ResetDS1302();
2063   1      
2064   1            time.month = bcd_decimal(time.month);     
2065   1            mDelaymS(up_down_delay_time);     
2066   1      }
2067          
2068          void mday_long_up_down(UINT8 i)
2069          {
2070   1      //      ResetDS1302();
2071   1      //      WriteByteDS1302(day_r_addr); //读取分的地址       
2072   1      //      time.mday=ReadByteDS1302();
2073   1      //      ResetDS1302();
2074   1            time.mday=Read_addr_byte_ds1302(day_r_addr);
2075   1            time.mday = bcd_decimal(time.mday);
2076   1            if(i==0)
2077   1            {
2078   2              time.mday++;
2079   2              if(time.mday >31)
2080   2              {
2081   3                time.mday = 1;
2082   3              }
2083   2            }
2084   1            if(i==1)
2085   1            {
2086   2            time.mday--;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 35  

2087   2            if(time.mday==0 || time.mday>31)
2088   2            {
2089   3                  time.mday = time.mday -225; //溢出值
2090   3            } 
2091   2            } 
2092   1      
2093   1              
2094   1              FD612_DISPLAY_2DIG_input(2,dis[time.mday/10] ,dis[time.mday% 10] );
2095   1              time.mday = decimal_bcd(time.mday);
2096   1      
2097   1              Write_addr_byte_ds1302(day_w_addr,time.mday);
2098   1      
2099   1      //        ResetDS1302();
2100   1      //        WriteByteDS1302(day_w_addr); //写入日的地址
2101   1      //        WriteByteDS1302(time.mday);   
2102   1              time.mday = bcd_decimal(time.mday);
2103   1              mDelaymS(up_down_delay_time);     
2104   1      }
2105          void alarm_hour_long_up_down(UINT8 alarm_seclect,UINT8 up_down_seclect,struct DATA_ALARM alarm)
2106          {
2107   1        
2108   1        if(up_down_seclect==1)
2109   1        {
2110   2              if(alarm_seclect==1)
2111   2              {
2112   3                
2113   3                alarm1.hour++;
2114   3                if(hour_12_24_flag){
2115   4                   if(alarm1.hour>=13)
2116   4                   {
2117   5                     alarm1.hour = 1;
2118   5                   }
2119   4                   if(alarm1.hour==1)
2120   4      //            if(alarm1.hour==12)
2121   4                  {
2122   5                    if(alarm1_pm_flag)alarm1_pm_flag=0;
2123   5                    else alarm1_pm_flag=1;            
2124   5                  }
2125   4                  }
2126   3                else
2127   3                {
2128   4                  if(alarm1.hour >=24)
2129   4                  {
2130   5                    alarm1.hour = 0;
2131   5                  } 
2132   4                }
2133   3                alarm_hour_long_up_down_flag=1;
2134   3              }
2135   2              if(alarm_seclect==2)
2136   2              {
2137   3                alarm2.hour++;
2138   3                if(hour_12_24_flag){
2139   4                   if(alarm2.hour>=13)
2140   4                   {
2141   5                     alarm2.hour = 1;
2142   5      
2143   5                   }
2144   4                  if(alarm2.hour==1)
2145   4                  {
2146   5                    if(alarm2_pm_flag)alarm2_pm_flag=0;
2147   5                    else alarm2_pm_flag=1;            
2148   5                  }            
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 36  

2149   4                  }
2150   3                else
2151   3                {
2152   4                  if(alarm2.hour >=24)
2153   4                  {
2154   5                    alarm2.hour = 0;
2155   5                  } 
2156   4                }
2157   3                alarm_hour_long_up_down_flag=2;
2158   3              } 
2159   2              if(alarm_seclect==3)
2160   2              {
2161   3                alarm3.hour++;
2162   3                if(hour_12_24_flag){
2163   4                   if(alarm3.hour>=13)
2164   4                   {
2165   5                     alarm3.hour = 1;
2166   5      
2167   5                   }
2168   4                  if(alarm3.hour==1)
2169   4                  {
2170   5                    if(alarm3_pm_flag)alarm3_pm_flag=0;
2171   5                    else alarm3_pm_flag=1;            
2172   5                  }              
2173   4                  }
2174   3                else
2175   3                {
2176   4                  if(alarm3.hour >=24)
2177   4                  {
2178   5                    alarm3.hour = 0;
2179   5                  } 
2180   4                }
2181   3                alarm_hour_long_up_down_flag=3;
2182   3              }
2183   2          }
2184   1          if(up_down_seclect==2)
2185   1          {
2186   2            if(alarm_seclect==1)
2187   2            {
2188   3              alarm1.hour--;          
2189   3              if(hour_12_24_flag){
2190   4                 if(alarm1.hour>=13||alarm1.hour==0)
2191   4                 {
2192   5                    alarm1.hour = alarm1.hour -244; //溢出值
2193   5                  
2194   5                 }
2195   4                  if(alarm1.hour==10)
2196   4                  {
2197   5                    if(alarm1_pm_flag)alarm1_pm_flag=0;
2198   5                    else alarm1_pm_flag=1;            
2199   5                  } 
2200   4                }
2201   3              else
2202   3              {
2203   4                if(alarm1.hour >=24)
2204   4                {
2205   5                  alarm1.hour = alarm1.hour -232; //溢出值
2206   5                }
2207   4              } 
2208   3            alarm_hour_long_up_down_flag=4;
2209   3            }
2210   2            if(alarm_seclect==2)
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 37  

2211   2            {
2212   3              alarm2.hour--;          
2213   3              if(hour_12_24_flag){
2214   4                 if(alarm2.hour>=13||alarm2.hour==0)
2215   4                 {
2216   5                    alarm2.hour = alarm2.hour -244; //溢出值
2217   5      
2218   5                 }
2219   4                    if(alarm2.hour==10)
2220   4                  {
2221   5                    if(alarm2_pm_flag)alarm2_pm_flag=0;
2222   5                    else alarm2_pm_flag=1;            
2223   5                  } 
2224   4                }
2225   3              else
2226   3              {
2227   4                if(alarm2.hour >=24)
2228   4                {
2229   5                  alarm2.hour = alarm2.hour -232; //溢出值
2230   5                }
2231   4              } 
2232   3      
2233   3            alarm_hour_long_up_down_flag=5;
2234   3            }
2235   2            if(alarm_seclect==3)
2236   2            {
2237   3              alarm3.hour--;          
2238   3              if(hour_12_24_flag){
2239   4                 if(alarm3.hour>=13||alarm3.hour==0)
2240   4                 {
2241   5                    alarm3.hour = alarm3.hour -244; //溢出值
2242   5                 }
2243   4                  if(alarm3.hour==10)
2244   4                  {
2245   5                    if(alarm3_pm_flag)alarm3_pm_flag=0;
2246   5                    else alarm3_pm_flag=1;            
2247   5                  } 
2248   4                }
2249   3              else
2250   3              {
2251   4                if(alarm3.hour >=24)
2252   4                {
2253   5                  alarm3.hour = alarm3.hour -232; //溢出值
2254   5                }
2255   4              } 
2256   3            alarm_hour_long_up_down_flag=6;
2257   3            }   
2258   2          }
2259   1      
2260   1                
2261   1              FD612_DISPLAY_2DIG_input(1 , dis[alarm.hour/10],dis[alarm.hour%10] );
2262   1              mDelaymS(up_down_delay_time);
2263   1              
2264   1      }
2265          
2266          
2267          void alarm_min_long_up_down(UINT8 alarm_seclect,UINT8 up_down_seclect,struct DATA_ALARM alarm)
2268          {
2269   1        if(up_down_seclect==1)
2270   1        {
2271   2              if(alarm_seclect==1)
2272   2              {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 38  

2273   3                alarm1.minute++;
2274   3              if(alarm1.minute >=60)
2275   3              {
2276   4                alarm1.minute = 0;
2277   4              }
2278   3              alarm_min_long_up_down_flag=1;
2279   3              }
2280   2              if(alarm_seclect==2)
2281   2              {
2282   3                alarm2.minute++;
2283   3              if(alarm2.minute >=60)
2284   3              {
2285   4                alarm2.minute = 0;
2286   4              }
2287   3              alarm_min_long_up_down_flag=2;        
2288   3              }
2289   2              if(alarm_seclect==3)
2290   2              {
2291   3                alarm3.minute++;
2292   3              if(alarm3.minute >=60)
2293   3              {
2294   4                alarm3.minute = 0;
2295   4              }
2296   3              alarm_min_long_up_down_flag=3;        
2297   3              } 
2298   2          }
2299   1          if(up_down_seclect==2)
2300   1          {
2301   2              if(alarm_seclect==1)
2302   2              {
2303   3                alarm1.minute--;
2304   3              if(alarm1.minute>60)
2305   3              {
2306   4                  alarm1.minute = alarm1.minute -196; //溢出值
2307   4              }
2308   3              alarm_min_long_up_down_flag=4;        
2309   3              }
2310   2              if(alarm_seclect==2)
2311   2              {
2312   3                alarm2.minute--;
2313   3              if(alarm2.minute>60)
2314   3              {
2315   4                  alarm2.minute = alarm2.minute -196; //溢出值
2316   4              }
2317   3              alarm_min_long_up_down_flag=5;        
2318   3              }
2319   2              if(alarm_seclect==3)
2320   2              {
2321   3                alarm3.minute--;
2322   3              if(alarm3.minute>60)
2323   3              {
2324   4                  alarm3.minute = alarm3.minute -196; //溢出值
2325   4              }
2326   3              alarm_min_long_up_down_flag=6;        
2327   3              }     
2328   2          }
2329   1      
2330   1              
2331   1              FD612_DISPLAY_2DIG_input(2,dis[alarm.minute/10]  ,dis[alarm.minute%10] );
2332   1              mDelaymS(up_down_delay_time);
2333   1              
2334   1      }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 39  

2335          
2336          void alarm_set_display(UINT8 i,struct DATA_ALARM alarm)
2337          {
2338   1                    if(SET_Long_Flag)
2339   1                  {
2340   2                      if(key_first)
2341   2                      {
2342   3                        key_first=0;
2343   3                        UP_Short_Flag=0;
2344   3                        DOWN_Short_Flag = 0;
2345   3                      }
2346   2      
2347   2                    if(i==1)alarm1_on_dispaly=1;
2348   2                    if(i==2)alarm2_on_dispaly=1;
2349   2                    if(i==3)alarm3_on_dispaly=1;  
2350   2                    if(SET_Short_Flag)
2351   2                      {
2352   3                        SET_Short_Flag_alarm1_flag++;
2353   3                        SET_Short_Flag=0;
2354   3                        if(SET_Short_Flag_alarm1_flag>3)
2355   3                        {
2356   4                          SET_Short_Flag_alarm1_flag=0;
2357   4                        }
2358   3                      }
2359   2                if(SET_Short_Flag_alarm1_flag==0)
2360   2                  {
2361   3      
2362   3                if(time1_second)
2363   3                {
2364   4                if(blink_flag)
2365   4                  {
2366   5                    blink_flag=0;
2367   5                    FD612_DISPLAY_2DIG_input(1 ,dis[alarm.hour/10] ,dis[alarm.hour%10] );
2368   5                  }
2369   4                  else
2370   4                  {
2371   5                    blink_flag=1;
2372   5                    FD612_DISPLAY_2DIG_input(1 ,0x00 , 0x00);
2373   5                  }
2374   4                  time1_second=0;
2375   4                }
2376   3                  
2377   3                  FD612_DISPLAY_2DIG_input(2,dis[alarm.minute/10] ,dis[alarm.minute%10] );
2378   3                      if(UP_Short_Flag==1)
2379   3                      {
2380   4                        if(i==1)
2381   4                        {
2382   5                          alarm1.hour++;
2383   5                          if(hour_12_24_flag){
2384   6                             if(alarm1.hour>=13)
2385   6                             {
2386   7                               alarm1.hour = 1;
2387   7      
2388   7                             }
2389   6                             if(alarm1.hour==12)
2390   6                             {
2391   7                               if(alarm1_pm_flag)alarm1_pm_flag=0;
2392   7                               else alarm1_pm_flag=1;
2393   7                              }
2394   6                            }
2395   5                          else
2396   5                          {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 40  

2397   6                            if(alarm1.hour >=24)
2398   6                            {
2399   7                              alarm1.hour = 0;
2400   7                            } 
2401   6                          }
2402   5                        }
2403   4                        if(i==2)
2404   4                        {
2405   5                          alarm2.hour++;
2406   5                          if(hour_12_24_flag){
2407   6                             if(alarm2.hour>=13)
2408   6                             {
2409   7                               alarm2.hour = 1;
2410   7      
2411   7                             }
2412   6                           if(alarm2.hour==12)
2413   6                             {
2414   7                               if(alarm2_pm_flag)alarm2_pm_flag=0;
2415   7                               else alarm2_pm_flag=1;
2416   7                              }                      
2417   6                            }
2418   5                          else
2419   5                          {
2420   6                            if(alarm2.hour >=24)
2421   6                            {
2422   7                              alarm2.hour = 0;
2423   7                            } 
2424   6                          }
2425   5                        } 
2426   4                        if(i==3)
2427   4                        {
2428   5                          alarm3.hour++;
2429   5                          if(hour_12_24_flag){
2430   6                             if(alarm3.hour>=13)
2431   6                             {
2432   7                               alarm3.hour = 1;
2433   7                             }
2434   6                           if(alarm3.hour==12)
2435   6                             {
2436   7                               if(alarm3_pm_flag)alarm3_pm_flag=0;
2437   7                               else alarm3_pm_flag=1;
2438   7                              }                      
2439   6                            }
2440   5                          else
2441   5                          {
2442   6                            if(alarm3.hour >=24)
2443   6                            {
2444   7                              alarm3.hour = 0;
2445   7                            } 
2446   6                          }
2447   5                        }                 
2448   4                          UP_Short_Flag=0;
2449   4                      }
2450   3                        if(DOWN_Short_Flag == 1)
2451   3                      {
2452   4                        if(i==1)
2453   4                        {
2454   5                          alarm1.hour--;          
2455   5                          if(hour_12_24_flag){
2456   6                             if(alarm1.hour>=13||alarm1.hour==0)
2457   6                             {
2458   7                                alarm1.hour = alarm1.hour -244; //溢出值
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 41  

2459   7                             }
2460   6                            if(alarm1.hour==11)
2461   6                             {
2462   7                               if(alarm1_pm_flag)alarm1_pm_flag=0;
2463   7                               else alarm1_pm_flag=1;
2464   7                              }                      
2465   6                            }
2466   5                          else
2467   5                          {
2468   6                            if(alarm1.hour >=24)
2469   6                            {
2470   7                              alarm1.hour = alarm1.hour -232; //溢出值
2471   7                            }
2472   6                          }
2473   5                        }
2474   4                        if(i==2)
2475   4                        {
2476   5                          alarm2.hour--;          
2477   5                          if(hour_12_24_flag){
2478   6                             if(alarm2.hour>=13||alarm2.hour==0)
2479   6                             {
2480   7                                alarm2.hour = alarm2.hour -244; //溢出值
2481   7                             }
2482   6                             if(alarm2.hour==11)
2483   6                             {
2484   7                               if(alarm2_pm_flag)alarm2_pm_flag=0;
2485   7                               else alarm2_pm_flag=1;
2486   7                              }                    
2487   6                            }
2488   5                          else
2489   5                          {
2490   6                            if(alarm2.hour >=24)
2491   6                            {
2492   7                              alarm2.hour = alarm2.hour -232; //溢出值
2493   7                            }
2494   6                          }
2495   5                        }
2496   4                        if(i==3)
2497   4                        {
2498   5                          alarm3.hour--;          
2499   5                          if(hour_12_24_flag){
2500   6                             if(alarm3.hour>=13||alarm3.hour==0)
2501   6                             {
2502   7                                alarm3.hour = alarm3.hour -244; //溢出值
2503   7                             }
2504   6                            if(alarm2.hour==11)
2505   6                             {
2506   7                               if(alarm2_pm_flag)alarm2_pm_flag=0;
2507   7                               else alarm2_pm_flag=1;
2508   7                              }                      
2509   6                            }
2510   5                          else
2511   5                          {
2512   6                            if(alarm3.hour >=24)
2513   6                            {
2514   7                              alarm3.hour = alarm3.hour -232; //溢出值
2515   7                            }
2516   6                          }
2517   5                        }                 
2518   4                          DOWN_Short_Flag = 0;
2519   4                      }           
2520   3                  }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 42  

2521   2                if(SET_Short_Flag_alarm1_flag==1)
2522   2                {
2523   3      
2524   3                  if(time1_second)
2525   3                  {
2526   4                  if(blink_flag)
2527   4                    {
2528   5                      blink_flag=0; 
2529   5                      FD612_DISPLAY_2DIG_input(2,dis[alarm.minute/10] ,dis[alarm.minute%10] );
2530   5                    }
2531   4                    else
2532   4                    {
2533   5                      blink_flag=1;
2534   5                      FD612_DISPLAY_2DIG_input(2,0x00 ,0x00 );  
2535   5                    }
2536   4                    time1_second=0;
2537   4                  }
2538   3                    
2539   3                    FD612_DISPLAY_2DIG_input(1 ,dis[alarm.hour/10] ,dis[alarm.hour%10] );
2540   3                      
2541   3                    if(UP_Short_Flag == 1)
2542   3                    {
2543   4                      if(i==1)
2544   4                      {
2545   5                        alarm1.minute++;
2546   5                      if(alarm1.minute >=60)
2547   5                      {
2548   6                        alarm1.minute = 0;
2549   6                      }
2550   5                      }
2551   4                      if(i==2)
2552   4                      {
2553   5                        alarm2.minute++;
2554   5                      if(alarm2.minute >=60)
2555   5                      {
2556   6                        alarm2.minute = 0;
2557   6                      }
2558   5                      }
2559   4                      if(i==3)
2560   4                      {
2561   5                        alarm3.minute++;
2562   5                      if(alarm3.minute >=60)
2563   5                      {
2564   6                        alarm3.minute = 0;
2565   6                      }
2566   5                      }               
2567   4                        UP_Short_Flag = 0;
2568   4                    }
2569   3                    if(DOWN_Short_Flag == 1)
2570   3                    {
2571   4                      if(i==1)
2572   4                      {
2573   5                        alarm1.minute--;
2574   5                      if(alarm1.minute>60)
2575   5                      {
2576   6                          alarm1.minute = alarm1.minute -196; //溢出值
2577   6                      }
2578   5                      }
2579   4                      if(i==2)
2580   4                      {
2581   5                        alarm2.minute--;
2582   5                      if(alarm2.minute>60)
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 43  

2583   5                      {
2584   6                          alarm2.minute = alarm2.minute -196; //溢出值
2585   6                      }
2586   5                      }
2587   4                      if(i==3)
2588   4                      {
2589   5                        alarm3.minute--;
2590   5                      if(alarm3.minute>60)
2591   5                      {
2592   6                          alarm3.minute = alarm3.minute -196; //溢出值
2593   6                      }
2594   5                      }               
2595   4                        DOWN_Short_Flag = 0;
2596   4                    }
2597   3                } 
2598   2                if(SET_Short_Flag_alarm1_flag==2) 
2599   2                {
2600   3                        if(i==1)alarm1_on_dispaly=1;
2601   3                        if(i==2)alarm2_on_dispaly=1;
2602   3                        if(i==3)alarm3_on_dispaly=1;
2603   3                        SET_Long_Flag=0;
2604   3                        SET_Short_Flag_alarm1_flag=0;
2605   3                        key_first=1;
2606   3                
2607   3                }
2608   2                    if(back_first)
2609   2                      {
2610   3                        back_TIME_Flag=0;
2611   3                        back_first=0;
2612   3                      }
2613   2                    if(back_TIME_Flag==over_time)
2614   2                      {
2615   3                        if(i==1)alarm1_on_dispaly=1;
2616   3                        if(i==2)alarm2_on_dispaly=1;
2617   3                        if(i==3)alarm3_on_dispaly=1;
2618   3                        SET_Long_Flag=0;
2619   3                        SET_Short_Flag_alarm1_flag=0;
2620   3                        back_TIME_Flag=0;
2621   3                        back_first=1;
2622   3                        dp_mode_exit( );  
2623   3                        //flag_display=0;
2624   3                        key_first=1;
2625   3      
2626   3                      } 
2627   2                  }
2628   1                  if(i==1)
2629   1                  {
2630   2                  if(alarm1_on_dispaly==0)
2631   2                  {
2632   3                
2633   3                    FD612_display_4DIG_input( 0x40 ,0x40 ,FD612_DISP_A ,FD612_DISP_1 );
2634   3                      if(UP_Short_Flag==1)
2635   3                      {
2636   4                        alarm1_on_dispaly=1;
2637   4                        UP_Short_Flag=0;
2638   4                      }             
2639   3                  }
2640   2      
2641   2                  if(SET_Long_Flag==0)
2642   2                  {
2643   3                  if(alarm1_on_dispaly)
2644   3                    {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 44  

2645   4                        
2646   4                      FD612_display_4DIG_input( 0x5c ,0x54 ,FD612_DISP_A ,FD612_DISP_1 );
2647   4                      if(UP_Short_Flag==1)
2648   4                      {
2649   5                        alarm1_on_dispaly=0;
2650   5                        UP_Short_Flag=0;
2651   5                      }
2652   4                    }
2653   3                  }
2654   2                  }
2655   1                  if(i==2)
2656   1                  {
2657   2                  if(alarm2_on_dispaly==0)
2658   2                  {
2659   3                  
2660   3                  FD612_display_4DIG_input( 0x40 , 0x40,FD612_DISP_A ,FD612_DISP_2 );
2661   3                  if(UP_Short_Flag==1)
2662   3                  {
2663   4                    alarm2_on_dispaly=1;
2664   4                    UP_Short_Flag=0;
2665   4                  }             
2666   3                  }
2667   2      
2668   2                  if(SET_Long_Flag==0)
2669   2                  {
2670   3                  if(alarm2_on_dispaly)
2671   3                    {
2672   4                      
2673   4                      FD612_display_4DIG_input(  0x5c,0x54,FD612_DISP_A ,FD612_DISP_2 );
2674   4                      if(UP_Short_Flag==1)
2675   4                      {
2676   5                        alarm2_on_dispaly=0;
2677   5                        UP_Short_Flag=0;
2678   5                      }
2679   4                    }
2680   3                  }             
2681   2                  }
2682   1                  if(i==3)
2683   1                  {
2684   2                  if(alarm3_on_dispaly==0)
2685   2                  {
2686   3                  
2687   3                    FD612_display_4DIG_input( 0x40 ,0x40 ,FD612_DISP_A ,FD612_DISP_3 );
2688   3                  if(UP_Short_Flag==1)
2689   3                  {
2690   4                    alarm3_on_dispaly=1;
2691   4                    UP_Short_Flag=0;
2692   4                  }             
2693   3                  }
2694   2      
2695   2                  if(SET_Long_Flag==0)
2696   2                  {
2697   3                  if(alarm3_on_dispaly)
2698   3                    {
2699   4                        
2700   4                      FD612_display_4DIG_input( 0x5c , 0x54,FD612_DISP_A ,FD612_DISP_3 );
2701   4                      if(UP_Short_Flag==1)
2702   4                      {
2703   5                        alarm3_on_dispaly=0;
2704   5                        UP_Short_Flag=0;
2705   5                      }
2706   4                    }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 45  

2707   3                  }             
2708   2                  }
2709   1                  if(SET_Long_Flag==0)
2710   1                  {
2711   2                  if(back_first)
2712   2                      {
2713   3                        back_TIME_Flag=0;
2714   3                        back_first=0;
2715   3                      }
2716   2                      if(back_TIME_Flag==over_time)
2717   2                      {
2718   3                      //  alarm1_on_dispaly=1;  
2719   3      //                  SET_Long_Flag=0;
2720   3      //                  SET_Short_Flag_alarm1_flag=0;
2721   3                        back_TIME_Flag=0;
2722   3                        back_first=1;
2723   3                        if(mode_select_flag==2) flag_display=0;
2724   3                        dp_mode_exit()  ;               
2725   3                      } 
2726   2                  }
2727   1      }
2728          
2729          void alarm_hour_display(struct DATA_ALARM alarm)
2730          {
2731   1      
2732   1                
2733   1              FD612_DISPLAY_2DIG_input(1 ,dis[alarm.hour/10] ,dis[alarm.hour%10] );
2734   1      }
2735          
2736          void alarm_min_display(struct DATA_ALARM alarm)
2737          {
2738   1      
2739   1                
2740   1              FD612_DISPLAY_2DIG_input(2,dis[alarm.minute/10] ,dis[alarm.minute%10] );
2741   1      }
2742          
2743          void alarm_long_blink(struct DATA_ALARM alarm)//闹钟长按闪烁
2744          {
2745   1          if(time1_second==1)
2746   1        {
2747   2      
2748   2          if(blink_flag)
2749   2          {
2750   3            blink_flag=0;
2751   3            FD612_DISPLAY_2DIG_input(1 ,dis[alarm.hour/10],dis[alarm.hour%10]);
2752   3          }
2753   2          else
2754   2          {
2755   3            blink_flag=1;
2756   3            FD612_DISPLAY_2DIG_input(1 ,0x00,0x00); 
2757   3          }
2758   2      
2759   2          FD612_DISPLAY_2DIG_input(2 ,dis[alarm.minute/10],dis[alarm.minute%10]);
2760   2          time1_second=0;
2761   2        }
2762   1      }
2763          
2764          void dp_mode_exit(void)
2765          {
2766   1          if(mode_select_flag==0){
2767   2            flag_display=0;
2768   2      //      temp_delay_time=0;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 46  

2769   2            mon_day_delay_time=0;
2770   2            hor_min_delay_time=0;
2771   2          }                                     
2772   1          
2773   1      }
2774          
2775          void key_dislpay_up_down(void)
2776          {
2777   1            if(long_add_flag==0)
2778   1            {
2779   2              switch(flag_display)
2780   2            {
2781   3              case 0:
2782   3              {
2783   4                if(SET_Short_Flag_hur_min==1 )
2784   4                {
2785   5      
2786   5                  
2787   5                  FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10]  ,dis[time.hour% 10]);
2788   5                }
2789   4                if(SET_Short_Flag_hur_min==2 )
2790   4                {
2791   5      
2792   5                
2793   5                  FD612_DISPLAY_2DIG_input(2,dis[time.minute/10] ,dis[time.minute% 10] );
2794   5                } 
2795   4                break;          
2796   4              }
2797   3              case 1:
2798   3              {
2799   4                if(SET_Short_Flag_mon_day==0 )
2800   4                {
2801   5                    
2802   5                  FD612_display_4DIG_input( dis[2] ,dis[0] ,dis[time.year/10] ,dis[time.year%10] );
2803   5                }
2804   4                if(SET_Short_Flag_mon_day==1&&long_add_flag==0 )
2805   4                {
2806   5      
2807   5                
2808   5                FD612_DISPLAY_2DIG_input(1 ,dis[time.month/10] ,dis[time.month% 10] );  
2809   5                }
2810   4                if(SET_Short_Flag_mon_day==2 )
2811   4                {
2812   5        
2813   5                  
2814   5                  FD612_DISPLAY_2DIG_input(2,dis[time.mday/10] ,dis[time.mday% 10] );
2815   5                }
2816   4                break;          
2817   4              }
2818   3              case 2:
2819   3              {
2820   4                if(SET_Short_Flag_alarm1_flag==0 )
2821   4                {
2822   5                 alarm_hour_display(alarm1);
2823   5                
2824   5                }
2825   4                if(SET_Short_Flag_alarm1_flag==1 )
2826   4                {
2827   5                  alarm_min_display(alarm1) ;     
2828   5                } 
2829   4                break;
2830   4              }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 47  

2831   3              case 3:
2832   3              {
2833   4                if(SET_Short_Flag_alarm1_flag==0 )
2834   4                {
2835   5                  alarm_hour_display( alarm2);        
2836   5                } 
2837   4                if(SET_Short_Flag_alarm1_flag==1 )
2838   4                {
2839   5                  alarm_min_display(alarm2) ;
2840   5                }
2841   4                break;
2842   4              }
2843   3              case 4:
2844   3              {
2845   4                  if(SET_Short_Flag_alarm1_flag==0 )
2846   4                  {
2847   5                    alarm_hour_display(alarm3);       
2848   5                  } 
2849   4                  if(SET_Short_Flag_alarm1_flag==1 )
2850   4                  {
2851   5                    alarm_min_display(alarm3) ;
2852   5                  } 
2853   4                break;
2854   4              }       
2855   3            }
2856   2          }
2857   1      }
2858          
2859          
2860          
2861          void FD612_display_4DIG_input(UINT8 dig1,UINT8 dig2,UINT8 dig3,UINT8 dig4)
2862          {
2863   1      //      FD612_DispBuff.DispData[FD612_DIG1_ADDR]=dig1 ; 
2864   1      //      FD612_DispBuff.DispData[FD612_DIG2_ADDR]=dig2;
2865   1      //      FD612_DispBuff.DispData[FD612_DIG3_ADDR]=dig3 ; 
2866   1      //      FD612_DispBuff.DispData[FD612_DIG4_ADDR]=dig4 ;
2867   1            FD612_PotiveTNage(FD612_DIG1_ADDR,dig1);
2868   1            FD612_PotiveTNage(FD612_DIG2_ADDR,dig2);
2869   1            FD612_PotiveTNage(FD612_DIG3_ADDR,dig3);
2870   1            FD612_PotiveTNage(FD612_DIG4_ADDR,dig4);
2871   1            pm_12_24_alarm_display();
2872   1            FD612_Refresh();  
2873   1      }
2874          void FD612_DISPLAY_2DIG_input(UINT8 i ,UINT8 dig1,UINT8 dig2)
2875          {
2876   1          if(i==1)
2877   1          {
2878   2            FD612_PotiveTNage(FD612_DIG1_ADDR,dig1);
2879   2            FD612_PotiveTNage(FD612_DIG2_ADDR,dig2);
2880   2            pm_12_24_alarm_display();
2881   2      //      FD612_Refresh();
2882   2          }
2883   1          if(i==2)
2884   1          {
2885   2            FD612_PotiveTNage(FD612_DIG3_ADDR,dig1);
2886   2            FD612_PotiveTNage(FD612_DIG4_ADDR,dig2);
2887   2            pm_12_24_alarm_display();
2888   2      //      FD612_Refresh();
2889   2          }
2890   1      }
2891          void  pm_12_24_alarm_display(void)
2892          {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 48  

2893   1                if(hour_12_24_flag==1)
2894   1                {
2895   2      //            FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2896   2                
2897   2                  if(hour_pm_flag==1)
2898   2                  {
2899   3                      
2900   3                      FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2901   3                  
2902   3                  }
2903   2                  else 
2904   2                  {
2905   3                    
2906   3                      FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2907   3                  
2908   3                  }
2909   2                  if(SET_Long_Flag==1)
2910   2                  {
2911   3                    if(alarm1_pm_flag==1&&flag_display==2 )
2912   3                    {
2913   4      
2914   4                        FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2915   4                      
2916   4                    }
2917   3                    if(alarm1_pm_flag==0&&flag_display==2)
2918   3                    {
2919   4                        FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2920   4                                  
2921   4                    }       
2922   3      
2923   3      
2924   3                    if(alarm2_pm_flag==1&&flag_display==3)
2925   3                    {
2926   4      
2927   4                        FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2928   4                      
2929   4                    }
2930   3                     if(alarm2_pm_flag==0&&flag_display==3)
2931   3                    {
2932   4                          FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2933   4                                  
2934   4                    } 
2935   3      
2936   3                    
2937   3                    if(alarm3_pm_flag==1&&flag_display==4)
2938   3                    {
2939   4      
2940   4                        FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2941   4                      
2942   4                    } 
2943   3                    if(alarm3_pm_flag==0&&flag_display==4)
2944   3                    {
2945   4                      FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2946   4                                  
2947   4                    } 
2948   3                    if(flag_display==0)
2949   3                    {
2950   4                        if(SET_Short_Flag_hur_min==1||SET_Short_Flag_hur_min==2)FD612_DispBuff.DispData[FD612_DIG12_ADDR]
             - |=(1<<1) ;
2951   4                    }
2952   3                     if(flag_display==2||flag_display==3||flag_display==4)
2953   3                    {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 49  

2954   4                        if(SET_Short_Flag_alarm1_flag==0||SET_Short_Flag_alarm1_flag==1)FD612_DispBuff.DispData[FD612_DIG
             -12_ADDR] |=(1<<1) ;
2955   4                    }
2956   3                    
2957   3                  }
2958   2      //           if(SET_Long_Flag==1&&(flag_display==2||flag_display==3||flag_display==4))
2959   2      //          {
2960   2      //                FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<1) ;
2961   2      //                        
2962   2      //          }           
2963   2                  if(SET_Long_Flag==0&&(flag_display==0||flag_display==1||flag_display==5)&&(hour_pm_flag==1))
2964   2                  {
2965   3                      FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2966   3                  
2967   3                  }
2968   2              
2969   2                }
2970   1                else
2971   1                {
2972   2      
2973   2      //                FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2974   2                  //    FD612_Refresh();
2975   2                }
2976   1                if(alarm1_on_dispaly ||alarm2_on_dispaly ||alarm3_on_dispaly)
2977   1                {
2978   2                  FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<3) ;
2979   2                }
2980   1                else
2981   1                {
2982   2                  FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<3) ;
2983   2                }
2984   1      //          if()
2985   1                FD612_Refresh();
2986   1      }
2987          
2988          
2989          
2990          void after_arrive_write_1302(void)
2991          {
2992   1      //       if(time.hour==12)
2993   1      //     {
2994   1              hour_chage_state=Read_addr_byte_ds1302(hour_r_addr);
2995   1      //      ResetDS1302();              
2996   1      //       WriteByteDS1302(hour_r_addr); //读取时的地址
2997   1      //       hour_chage_state=ReadByteDS1302();
2998   1             if(hour_chage_state&0x20)
2999   1             {
3000   2               hour_chage_state &=~(1<<5);
3001   2               hour_pm_flag=0;
3002   2             }
3003   1             else 
3004   1             {
3005   2               hour_chage_state |=(1<<5);
3006   2               hour_pm_flag=1;
3007   2             }
3008   1            Write_addr_byte_ds1302(hour_w_addr,hour_chage_state);
3009   1      //       ResetDS1302();
3010   1      //       WriteByteDS1302(hour_w_addr); //写入时的地址
3011   1      //       WriteByteDS1302(hour_chage_state);                          
3012   1      //      }
3013   1      }
3014          
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 50  

3015            void hour_chage_input(UINT8 i)
3016            {//24小时转12小时
3017   1          
3018   1          UINT8 hour_state_value;
3019   1          hour_state_value=Read_addr_byte_ds1302(hour_r_addr);
3020   1      //    ResetDS1302();              
3021   1      //    WriteByteDS1302(hour_r_addr); //读取时的地址
3022   1      //    hour_state_value=ReadByteDS1302();
3023   1          if(i==1)    
3024   1          {
3025   2      //      hour_state_value<<=3;
3026   2      //      hour_state_value>>=3;
3027   2                  
3028   2            hour_state_value = bcd_decimal(hour_state_value);       
3029   2          if(hour_state_value>12)
3030   2          {
3031   3            hour_state_value=hour_state_value-12;
3032   3            hour_state_value=decimal_bcd(hour_state_value);
3033   3            hour_state_value |=(1<<5);
3034   3            hour_state_value |= (1<<7);
3035   3            hour_pm_flag=1;
3036   3          }
3037   2          else if(hour_state_value==12)
3038   2          {
3039   3           hour_pm_flag=1;
3040   3            hour_state_value=decimal_bcd(hour_state_value);
3041   3            hour_state_value |=(1<<5);
3042   3            hour_state_value |= (1<<7);
3043   3          }
3044   2            else if(hour_state_value<12)
3045   2            {
3046   3            hour_state_value=decimal_bcd(hour_state_value);
3047   3            hour_state_value |= (1<<7);
3048   3            }
3049   2      //    if(hour_chage_state==12)
3050   2      //    {
3051   2      //     hour_pm_flag=1;
3052   2      //    hour_chage_state |=(1<<5);
3053   2      //    }
3054   2      //    hour_chage_state=decimal_bcd(hour_chage_state);
3055   2              
3056   2          }
3057   1          if(i==0)    
3058   1          {
3059   2            //12小时转24小时
3060   2            if(hour_state_value&0x20)
3061   2            {
3062   3              hour_state_value&=~(1<<7);
3063   3              hour_state_value &=~(1<<5);       
3064   3              hour_pm_flag=0;
3065   3              hour_state_value = bcd_decimal(hour_state_value);   
3066   3              if(hour_state_value!=12)
3067   3              hour_state_value=hour_state_value+12;
3068   3              hour_state_value=decimal_bcd(hour_state_value);
3069   3            }
3070   2            else
3071   2            {
3072   3            hour_state_value&=~(1<<7);  
3073   3            hour_state_value = bcd_decimal(hour_state_value);
3074   3            if(hour_state_value==12)hour_state_value=0;
3075   3            hour_state_value=decimal_bcd(hour_state_value);
3076   3            
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 51  

3077   3            }
3078   2            
3079   2            
3080   2          }
3081   1          Write_addr_byte_ds1302(hour_w_addr,hour_state_value);
3082   1      //    ResetDS1302();
3083   1      //    WriteByteDS1302(hour_w_addr); //写入时的地址
3084   1      //    WriteByteDS1302(hour_state_value);  
3085   1        }
3086            
3087            void temper_display(void)
3088            {
3089   1                
3090   1          if(ADC_TIME_Flag==temp_refresh_time)
3091   1          {
3092   2            ADC_Convert( );
3093   2            ADC_TIME_Flag=0;
3094   2          }
3095   1            adc_switch( );
3096   1      //    if(ADC_Display1==0)
3097   1      //    {     
3098   1      ////    FD612_display_4DIG_input( 0x00 ,dis[(unsigned char)TEM2/10] ,dis[(unsigned char)TEM2%10] ,FD612_DISP
             -_C );
3099   1      //      FD612_PotiveTNage(FD612_DIG1_ADDR,0x00);
3100   1      //      FD612_PotiveTNage(FD612_DIG2_ADDR,dis[(unsigned char)TEM2/10]);
3101   1      //      FD612_PotiveTNage(FD612_DIG3_ADDR,dis[(unsigned char)TEM2%10]);
3102   1      //      FD612_PotiveTNage(FD612_DIG4_ADDR,FD612_DISP_cc);
3103   1      //      FD612_DispBuff.DispData[FD612_DIG12_ADDR]|= 1<<6 ; 
3104   1      //      FD612_Refresh();
3105   1      //    }
3106   1      //    else
3107   1      //    {
3108   1      //    ADC_AVG_NUM[2]   = (unsigned char)TEM4/100;
3109   1      //    ADC_AVG_NUM[1]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )/10;
3110   1      //    ADC_AVG_NUM[0]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )%10;
3111   1      
3112   1      ////    FD612_display_4DIG_input(dis[ADC_AVG_NUM[2]]  , dis[ADC_AVG_NUM[1]],dis[ADC_AVG_NUM[0]]  ,FD612_DISP
             -_F );
3113   1      //      FD612_PotiveTNage(FD612_DIG1_ADDR,dis[ADC_AVG_NUM[2]]);
3114   1      //      FD612_PotiveTNage(FD612_DIG2_ADDR,dis[ADC_AVG_NUM[1]]);
3115   1      //      FD612_PotiveTNage(FD612_DIG3_ADDR,dis[ADC_AVG_NUM[0]] );
3116   1      //      FD612_PotiveTNage(FD612_DIG4_ADDR,FD612_DISP_F );
3117   1      
3118   1      //      FD612_Refresh();
3119   1      //      
3120   1      //    } 
3121   1        }
3122            
3123          void display_12_24_blink(void)
3124          {
3125   1            if(time1_second==1)
3126   1          {
3127   2          if(blink_flag)          
3128   2            {
3129   3              blink_flag=0;
3130   3              if(hour_12_24_flag)
3131   3              {
3132   4              FD612_DISPLAY_2DIG_input(1 ,dis[1],dis[2]);
3133   4              }
3134   3              else
3135   3              {
3136   4              FD612_DISPLAY_2DIG_input(1 ,dis[2],dis[4]);
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 52  

3137   4              }
3138   3      
3139   3              FD612_DISPLAY_2DIG_input(2,FD612_DISP_H ,FD612_DISP_);  
3140   3            }
3141   2            else
3142   2            {
3143   3              blink_flag=1;
3144   3              FD612_display_4DIG_input(0x00,0x00,0x00,0x00);
3145   3            }
3146   2            time1_second=0;
3147   2          } 
3148   1      }
3149          
3150          void year_blink(UINT8 i)
3151          {
3152   1          if(time1_second==1)
3153   1          {
3154   2            if(blink_flag)
3155   2            {
3156   3            blink_flag=0;
3157   3              FD612_display_4DIG_input( dis[2] ,dis[0] ,dis[time.year/10]  ,dis[time.year%10] );
3158   3            }
3159   2            else
3160   2            {
3161   3              blink_flag=1;
3162   3              if(i==0)
3163   3              FD612_display_4DIG_input( 0x00 ,0x00 ,0x00 ,0x00 );
3164   3            }
3165   2            time1_second=0;
3166   2          }
3167   1      }
3168          
3169          
3170          void from_ds1302_read_time_data(void)
3171          {
3172   1        //        UINT8 pm_flag;
3173   1            ResetDS1302();  
3174   1            WriteByteDS1302(0xbf);                                          //以多字节方式读取时钟寄存器数据
3175   1            time.second=ReadByteDS1302();
3176   1            time.minute=ReadByteDS1302();
3177   1            time.hour=ReadByteDS1302();
3178   1            time.mday=ReadByteDS1302();
3179   1            time.month=ReadByteDS1302();
3180   1            time.week=ReadByteDS1302();
3181   1            time.year=ReadByteDS1302();
3182   1            ResetDS1302();
3183   1            if(hour_12_24_flag==1)
3184   1            {
3185   2             if((time.hour&0x20)&&(time.hour&0x80))
3186   2               { 
3187   3                 hour_pm_flag=1;
3188   3               }
3189   2               else 
3190   2               {                 
3191   3                 hour_pm_flag=0;
3192   3               }
3193   2              time.hour<<=3;
3194   2              time.hour>>=3;
3195   2      //        time.hour &=~(1<<7);
3196   2      //        time.hour &=~(1<<5);
3197   2      //         ResetDS1302();             
3198   2      //         WriteByteDS1302(hour_r_addr); //读取时的地址
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 53  

3199   2      //         pm_flag=ReadByteDS1302();
3200   2      //         if((pm_flag&0x20)&&(pm_flag&0x80))
3201   2      //         { 
3202   2      //           hour_pm_flag=1;
3203   2      //         }
3204   2      //         else 
3205   2      //         {                 
3206   2      //           hour_pm_flag=0;
3207   2      //         }        
3208   2            }
3209   1            time.year = bcd_decimal(time.year); 
3210   1            time.month =bcd_decimal(time.month);
3211   1            time.mday = bcd_decimal(time.mday);
3212   1            time.week = bcd_decimal(time.week);
3213   1            time.hour = bcd_decimal(time.hour);
3214   1            time.minute = bcd_decimal(time.minute);
3215   1            time.second = bcd_decimal(time.second);
3216   1      }
3217          
3218          
3219          void InitDS1302(void)
3220          {   
3221   1            unsigned char year,month,mday,week,hour,minute,second ;
3222   1            year = decimal_bcd(year_init); 
3223   1            month =decimal_bcd(month_init);
3224   1            mday = decimal_bcd(mday_init);
3225   1            week = decimal_bcd(week_init);
3226   1            hour = decimal_bcd(hour_init);
3227   1            minute = decimal_bcd(minute_init);
3228   1            second = decimal_bcd(second_init);
3229   1            
3230   1            hour |= 1<<7;
3231   1            hour &=~ (1<<5);
3232   1            hour_12_24_flag=1;
3233   1            hour_pm_flag=0;
3234   1            ds1302_w_on();
3235   1      //      ResetDS1302();
3236   1      //      WriteByteDS1302(0x8e);                          //写保护控制寄存器
3237   1      //      WriteByteDS1302(0x0);                           //允许写入
3238   1            
3239   1            ResetDS1302();
3240   1            WriteByteDS1302(0x90);                          //写涓流充电控制寄存器
3241   1            WriteByteDS1302(0xab);                          //允许充电
3242   1            
3243   1            ResetDS1302();
3244   1            WriteByteDS1302(0xbe);                          //写多字节突发方式控制寄存器
3245   1            
3246   1            WriteByteDS1302(second);
3247   1            WriteByteDS1302(minute);
3248   1            WriteByteDS1302(hour);
3249   1            WriteByteDS1302(mday);
3250   1            WriteByteDS1302(month);
3251   1            WriteByteDS1302(week);
3252   1            WriteByteDS1302(year);
3253   1            WriteByteDS1302(0);                             //对写保护控制寄存器写入0
3254   1            ResetDS1302();
3255   1            ds1302_w_off();
3256   1          
3257   1      //      from_ds1302_read_time_data();
3258   1            
3259   1                
3260   1      }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 54  

3261          
3262          
3263          
3264          void point_blink(void)
3265          {
3266   1                            FD612_PotiveTNage(FD612_DIG1_ADDR,dis[time.hour/10]);
3267   1                          FD612_PotiveTNage(FD612_DIG2_ADDR,dis[time.hour% 10]);
3268   1                          FD612_PotiveTNage(FD612_DIG3_ADDR,dis[time.minute/10]);
3269   1                          FD612_PotiveTNage(FD612_DIG4_ADDR,dis[time.minute% 10]);
3270   1                                      
3271   1      
3272   1                      if(time1_second)
3273   1                      {
3274   2      //                  pm_12_24_alarm_display();
3275   2                        if(blink3_flag)
3276   2                        {
3277   3                          blink3_flag=0;
3278   3      //                    FD612_PotiveTNage(FD612_DIG1_ADDR,dis[time.hour/10]);
3279   3      //                    FD612_PotiveTNage(FD612_DIG2_ADDR,dis[time.hour% 10]);
3280   3      //                    FD612_PotiveTNage(FD612_DIG3_ADDR,dis[time.minute/10]);
3281   3      //                    FD612_PotiveTNage(FD612_DIG4_ADDR,dis[time.minute% 10]);
3282   3                          FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<1);
3283   3                           if(hour_pm_flag==1)
3284   3                          {                       
3285   4                              FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
3286   4                          }
3287   3                          else 
3288   3                          {                     
3289   4                              FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;                   
3290   4                          }
3291   3                          if(alarm1_on_dispaly ||alarm2_on_dispaly ||alarm3_on_dispaly)
3292   3                          {
3293   4                            FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<3) ;
3294   4                          }
3295   3                          else
3296   3                          {
3297   4                            FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<3) ;
3298   4                          }                   
3299   3      //                    FD612_Refresh();
3300   3                        }
3301   2                        else
3302   2                        {
3303   3                          blink3_flag=1;
3304   3      //                    FD612_PotiveTNage(FD612_DIG1_ADDR,dis[time.hour/10]);
3305   3      //                    FD612_PotiveTNage(FD612_DIG2_ADDR,dis[time.hour% 10]);
3306   3      //                    FD612_PotiveTNage(FD612_DIG3_ADDR,dis[time.minute/10]);
3307   3      //                    FD612_PotiveTNage(FD612_DIG4_ADDR,dis[time.minute% 10]);
3308   3                          FD612_DispBuff.DispData[FD612_DIG12_ADDR] |= (1<<1);
3309   3                           if(hour_pm_flag==1)
3310   3                          {  
3311   4                              FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;                    
3312   4                          }
3313   3                          else 
3314   3                          {                     
3315   4                              FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;                   
3316   4                          }
3317   3                          if(alarm1_on_dispaly ||alarm2_on_dispaly ||alarm3_on_dispaly)
3318   3                          {
3319   4                            FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<3) ;
3320   4                          }
3321   3                          else
3322   3                          {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 55  

3323   4                            FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<3) ;
3324   4                          }                   
3325   3      //                    FD612_Refresh();
3326   3                        }
3327   2                        FD612_Refresh();
3328   2                        time1_second=0;
3329   2                        
3330   2                      }
3331   1      }
3332          
3333          void adc_switch(void)
3334          {
3335   1                  switch (ADC_Display)
3336   1                 {
3337   2                   
3338   2                   case 0:
3339   2                   {
3340   3                      
3341   3                     
3342   3                     //FD612_display_4DIG_input(0x00,dis[(unsigned char)TEM2/10],dis[(unsigned char)TEM2%10],FD612_DISP
             -_C);   
3343   3                      FD612_PotiveTNage(FD612_DIG1_ADDR,0x00);
3344   3                      FD612_PotiveTNage(FD612_DIG2_ADDR,dis[(unsigned char)TEM2/10]);
3345   3                      FD612_PotiveTNage(FD612_DIG3_ADDR,dis[(unsigned char)TEM2%10]);
3346   3                      FD612_PotiveTNage(FD612_DIG4_ADDR,FD612_DISP_cc);
3347   3                      FD612_DispBuff.DispData[FD612_DIG12_ADDR]|= 1<<6 ; 
3348   3                      FD612_Refresh();
3349   3                     ADC_Display1=0;
3350   3                     break;
3351   3                   }
3352   2                    
3353   2      
3354   2                    case 1:
3355   2                    {
3356   3                      
3357   3      //              ADC_AVG_NUM[2]   = (unsigned char)TEM4/100;
3358   3      //              ADC_AVG_NUM[1]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )/10;
3359   3      //              ADC_AVG_NUM[0]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )%10;
3360   3      //              FD612_display_4DIG_input(dis[ADC_AVG_NUM[2]],dis[ADC_AVG_NUM[1]],dis[ADC_AVG_NUM[0]],FD612_DISP_F
             -);
3361   3                    FD612_PotiveTNage(FD612_DIG1_ADDR,dis[(unsigned char)TEM4/100]);
3362   3                    FD612_PotiveTNage(FD612_DIG2_ADDR,dis[(unsigned char)TEM4%100/10]);
3363   3                    FD612_PotiveTNage(FD612_DIG3_ADDR,dis[(unsigned char)TEM4%100%10]);
3364   3                      FD612_PotiveTNage(FD612_DIG4_ADDR,FD612_DISP_F);
3365   3      
3366   3                    FD612_Refresh();  
3367   3                      ADC_Display1=1;
3368   3      //                ADC_Display=0;
3369   3                      break;
3370   3                    } 
3371   2                      default :
3372   2                      break;
3373   2                }
3374   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10546    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    136      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 16:08:22 PAGE 56  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
