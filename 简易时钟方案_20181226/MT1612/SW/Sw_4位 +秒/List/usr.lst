C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE USR
OBJECT MODULE PLACED IN .\Output\usr.obj
COMPILER INVOKED BY: E:\Keil_v5\C51\BIN\C51.EXE App\usr.c LARGE BROWSE INCDIR(.\StdDriver\inc;.\App) DEBUG OBJECTEXTEND 
                    -PRINT(.\List\usr.lst) TABS(2) OBJECT(.\Output\usr.obj)

line level    source

   1          
   2          #include "usr.h"
   3          
   4          
   5          struct DATA_ALARM alarm1,alarm2,alarm3;//闹钟初始值
   6          struct DATA_ALARM_ch ch_alarm1,ch_alarm2,ch_alarm3;
   7          struct DATA_TIME time;                  //时间初始值
   8          struct time_char time_ch;               //时间显示初始值
   9          
  10          
  11          
  12          unsigned char second,time1_second=0,long_flag;
  13          unsigned int delaytime =40,dc2=0,delaytime1=10,dc1=0; //20次1S
  14          unsigned char SET_Long_Flag=0,SET_Short_Flag=0,UP_Long_Flag=0,UP_Short_Flag=0,DOWN_Short_Flag=0,DOWN_Long_
             -Flag=0;
  15          unsigned char flag_display=0,display_flag_hur_min=1,SET_Short_Flag_hur_min=0;
  16          const unsigned char  dis[10] = {FD612_DISP_0,FD612_DISP_1,FD612_DISP_2,FD612_DISP_3,FD612_DISP_4,FD612_DIS
             -P_5,FD612_DISP_6,FD612_DISP_7,FD612_DISP_8,FD612_DISP_9 };
  17          unsigned char  TEM_VALUE =1;
  18          unsigned char  ADC_TIME_Flag=0,dc_ADC=0,delaytime_ADC=20,ADC_fisrt=1;//20次1S
  19          unsigned char display_flag_mon_day=1,SET_Short_Flag_mon_day=0,SET_Short_Flag_alarm1_flag=0;
  20          unsigned char  flag_year_leap=0;//闰年的代表
  21          unsigned char alarm_on_flag=0,alarm1_on_dispaly=0,alarm2_on_dispaly=0,alarm3_on_dispaly=0;
  22          unsigned char  back_TIME_Flag=0,dc_back=0,delaytime_back=20,back_first=1,voice_back=0,back_voice_Flag=0,al
             -arm_clock_flag=0,dc_alarm=0;
  23          unsigned char alarm_flag=0,alarm_voice_flag=0,alarm3_voice_flag=0,alarm2_voice_flag=0,alarm3_flag=0,alarm2
             -_flag=0;
  24          unsigned char voice_flag=0,voice_fisrt=1;
  25          unsigned char sd_flag=0,dislay_all_flag=0,sd_mode_flag=0,sd_select_first=1;
  26          float   TEM2,TEM4;
  27          double   TEM;       //浮点类型
  28          unsigned char  ADC_Display=0,ADC_Display1=0,ADC_ONE=1;
  29          unsigned char key_first=1;
  30          unsigned char mode_select_first=1,mode_select_flag=0,hor_min_delay_time=0,mon_day_delay_time=0,mode_select
             -=0,temp_delay_time=0;
  31          UINT8 long_add_flag=0,up_down_flag=0;
  32          UINT8 alarm_hour_long_up_down_flag=0,alarm_min_long_up_down_flag=0;
  33          UINT8 blink_flag=0,blink3_flag=0;
  34          UINT8 hour_chage_state=0,hour_12_24_flag=0,hour_pm_flag=0,alarm1_pm_flag=0,alarm2_pm_flag=0,alarm3_pm_flag
             -=0;
  35          void  mTimer0Interrupt( void ) interrupt INT_NO_TMR0 using 1                //timer0中断服务程序,使用寄存器
             -组1
  36          {                                                                           //方式3时，TH0使用Timer1的中断
             -资源
  37   1      
  38   1              TH0=0XFf;
  39   1              TL0=0X90;
  40   1              buzzer=~buzzer;
  41   1      //      dc2++;
  42   1      //    if(dc2==delaytime){
  43   1      //      second=1; 
  44   1      //      dc2=0;
  45   1      //    }
  46   1      
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 2   

  47   1      
  48   1      }
  49          
  50          void  mTimer1Interrupt( void ) interrupt INT_NO_TMR1 using 2                //timer1中断服务程序,使用寄存器
             -组2
  51          {                                                                           //方式3时，Timer1停止
  52   1          TH1 =0X3C;
  53   1          TL1 =0XB0; 
  54   1            dc2++;
  55   1          if(dc2==delaytime){
  56   2            second=1; 
  57   2            dc2=0;
  58   2          }  
  59   1          dc1++;
  60   1          if(dc1==delaytime1)
  61   1          {
  62   2            time1_second=1;
  63   2            dc1=0;
  64   2          }
  65   1          dc_ADC++;
  66   1          if(dc_ADC==delaytime_ADC)
  67   1          {
  68   2            ADC_TIME_Flag++;
  69   2            dc_ADC=0;
  70   2          }
  71   1          dc_back++;
  72   1          if(dc_back==delaytime_back)
  73   1          {
  74   2            back_TIME_Flag++;
  75   2            dc_back=0;
  76   2          }
  77   1          voice_back++;
  78   1          if(voice_back==delaytime_back)
  79   1          {
  80   2            back_voice_Flag++;
  81   2            voice_back=0;
  82   2          }
  83   1          dc_alarm++;
  84   1          if(dc_alarm==delaytime1)
  85   1          {
  86   2            alarm_clock_flag=1;
  87   2            dc_alarm=0;
  88   2            
  89   2          }
  90   1          mode_select++;
  91   1          if(mode_select==delaytime_back)
  92   1          {
  93   2            if(flag_display==1)
  94   2            hor_min_delay_time++;
  95   2            if(flag_display==0)
  96   2              mon_day_delay_time++;
  97   2            if(flag_display==5)
  98   2            temp_delay_time++;
  99   2              mode_select=0;
 100   2            
 101   2          }
 102   1      }
 103          
 104          
 105          /**
 106           *  @brief  BCD转十进制
 107           *  @param  bcd
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 3   

 108           *  @return decimal
 109           *  @note    
 110           *  @note    
 111           */
 112          UINT8 bcd_decimal(UINT8 bcd)
 113          {
 114   1      return bcd-(bcd >> 4)*6;
 115   1      }
 116          
 117          /**
 118           *  @brief  十进制转BCD
 119           *  @param  decimal
 120           *  @return bcd
 121           *  @note    
 122           *  @note    
 123           */
 124          UINT8 decimal_bcd(UINT8 decimal)
 125          {
 126   1      return  (decimal+(decimal / 10)*6);
 127   1      }
 128          
 129          
 130          /**
 131           *  @brief  判断是否是闰年
 132           *  @param  year
 133           *  @return 1代表闰年 0代表不是闰年
 134           *  @note    
 135           *  @note    
 136           */
 137          
 138          
 139          void alarm_time_init(void)
 140          {
 141   1          alarm1.hour  =0;
 142   1          alarm1.minute=0;
 143   1          alarm2.hour  =0;
 144   1          alarm2.minute=0;
 145   1          alarm3.hour  =0;
 146   1          alarm3.minute=0;
 147   1          //buzzer=0;
 148   1      }
 149          
 150          void time0_setup(void)
 151          {
 152   1          long_flag=0;
 153   1          back_first=1;
 154   1          delaytime =40;
 155   1          second=0;
 156   1          dc2=0;
 157   1      
 158   1      //    TH0 =0X3C;
 159   1      //    TL0 =0XB0;
 160   1      //    TR0=1;
 161   1          back_TIME_Flag=0;
 162   1        if(mode_select_flag==0)
 163   1        {
 164   2          temp_delay_time=0; //DP1计数清0
 165   2          mon_day_delay_time=0;
 166   2          hor_min_delay_time=0; 
 167   2        }
 168   1          TR0=1;
 169   1          mDelaymS(70);
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 4   

 170   1          TR0=0;
 171   1          buzzer=0;
 172   1      
 173   1          back_voice_Flag=0; //唤醒功能延时重新计数
 174   1            
 175   1      }
 176          
 177          void key_statue(void)
 178          {
 179   1          from_ds1302_read_time_data( );
 180   1              
 181   1      if(alarm_flag==0 && alarm2_flag==0&& alarm3_flag==0)  {
 182   2      //set按键
 183   2        if(SET==0)
 184   2        {
 185   3          time0_setup( );
 186   3          while(!SET)
 187   3          {
 188   4        //    pm_12_24_alarm_display();
 189   4            /*SET按下时秒还在跳*/
 190   4            if(flag_display==0&&SET_Long_Flag==0)
 191   4            {
 192   5      
 193   5              time.second=Read_addr_byte_ds1302(sec_r_addr);
 194   5              time.second = bcd_decimal(time.second);
 195   5            FD612_PotiveTNage(FD612_DIG5_ADDR,dis[time.second/10]);
 196   5            FD612_PotiveTNage(FD612_DIG6_ADDR,dis[time.second% 10]);                    
 197   5            FD612_Refresh();  
 198   5            }
 199   4            else
 200   4            {
 201   5            FD612_PotiveTNage(FD612_DIG5_ADDR,0X00);
 202   5            FD612_PotiveTNage(FD612_DIG6_ADDR,0X00);                    
 203   5            FD612_Refresh();      
 204   5            }     
 205   4      
 206   4            if(second==1)
 207   4            {
 208   5              
 209   5              long_flag=1;
 210   5              SET_Long_Flag=1;
 211   5              switch(flag_display)
 212   5              {
 213   6                case 0:
 214   6                {
 215   7                  display_12_24_blink( );
 216   7                  break;
 217   7                }
 218   6              
 219   6                case 1:
 220   6                {
 221   7                    year_blink(0) ;         
 222   7                    break;
 223   7                }
 224   6                case 2:
 225   6                {
 226   7                  alarm_long_blink(alarm1)  ;       
 227   7                  break;
 228   7                }
 229   6                case 3:
 230   6                {
 231   7                  alarm_long_blink(alarm2)  ;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 5   

 232   7                  break;
 233   7                }
 234   6                case 4:
 235   6                {
 236   7                  alarm_long_blink(alarm3)  ;
 237   7                  break;
 238   7                }         
 239   6              }       
 240   5              
 241   5              
 242   5            }
 243   4          }
 244   3          second=0;
 245   3          while(!SET);
 246   3          if(long_flag==0)
 247   3          {
 248   4            SET_Short_Flag=1;
 249   4            second=0;
 250   4          }
 251   3        }
 252   2      //up按键
 253   2        if(UP==0)
 254   2        {
 255   3          
 256   3          time0_setup( );
 257   3          while(!UP)
 258   3          {
 259   4          //  pm_12_24_alarm_display();
 260   4            if(SET_Long_Flag==1)
 261   4            {
 262   5             key_dislpay_up_down( );
 263   5            }
 264   4            if(second==1)
 265   4            {
 266   5              
 267   5              long_flag=1;
 268   5              UP_Long_Flag=1;
 269   5              long_add_flag=1;//长按时显示
 270   5              
 271   5              if(SET_Long_Flag==1)
 272   5              {
 273   6                back_TIME_Flag=0;
 274   6                if(mode_select_flag==0)
 275   6                {
 276   7                  temp_delay_time=0; //DP1计数清0
 277   7                  mon_day_delay_time=0;
 278   7                  hor_min_delay_time=0; 
 279   7                }
 280   6                switch (flag_display)
 281   6                {
 282   7                case 0:
 283   7                {
 284   8                   if(SET_Short_Flag_hur_min==1)
 285   8                   {
 286   9                     hour_long_up_down(0);
 287   9                   }
 288   8                   if(SET_Short_Flag_hur_min==2)
 289   8                   {
 290   9      
 291   9                   min_long_up_down(0) ;
 292   9                   }             
 293   8                  break;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 6   

 294   8                }
 295   7                case 1:
 296   7                {
 297   8                   if(SET_Short_Flag_mon_day==0)
 298   8                   {
 299   9                    year_long_up_down(0);
 300   9                   }
 301   8                   if(SET_Short_Flag_mon_day==1)
 302   8                   {
 303   9                    mon_long_up_down(0);
 304   9                   }  
 305   8                   if(SET_Short_Flag_mon_day==2)
 306   8                   {
 307   9                    mday_long_up_down(0);
 308   9                   }             
 309   8                  break;
 310   8                }
 311   7                case 2:
 312   7                {
 313   8                    if(SET_Short_Flag_alarm1_flag==0) 
 314   8                    {
 315   9                       alarm_hour_long_up_down(1,1,alarm1);
 316   9      
 317   9                    }   
 318   8                    if(SET_Short_Flag_alarm1_flag==1) 
 319   8                    {
 320   9                       alarm_min_long_up_down(1,1,alarm1);
 321   9                    }           
 322   8                  break;
 323   8                }
 324   7                case 3:
 325   7                {
 326   8                  if(SET_Short_Flag_alarm1_flag==0) 
 327   8                  {
 328   9                     alarm_hour_long_up_down(2,1, alarm2);
 329   9                  }
 330   8                  if(SET_Short_Flag_alarm1_flag==1) 
 331   8                  {
 332   9                     alarm_min_long_up_down(2,1,alarm2);
 333   9                  }             
 334   8                  break;
 335   8                }
 336   7                case 4:
 337   7                {
 338   8                  if(SET_Short_Flag_alarm1_flag==0) 
 339   8                  {
 340   9                     alarm_hour_long_up_down(3,1, alarm3);
 341   9                  }
 342   8                  if(SET_Short_Flag_alarm1_flag==1) 
 343   8                  {
 344   9                     alarm_min_long_up_down(3,1, alarm3);
 345   9                  }           
 346   8                  break;
 347   8                }   
 348   7              }
 349   6      
 350   6                    
 351   6              }
 352   5            }
 353   4        
 354   4          }
 355   3      
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 7   

 356   3      /*用于ALARM自加自减时多加减一 */  
 357   3          switch(alarm_hour_long_up_down_flag)
 358   3          {
 359   4            case 1:
 360   4            {
 361   5              alarm1.hour--;
 362   5             if(hour_12_24_flag)
 363   5              {
 364   6                if(alarm1.hour==0)alarm1.hour=12;
 365   6              }
 366   5              else 
 367   5              {
 368   6                if(alarm1.hour>=24)alarm1.hour=23;
 369   6              }
 370   5              alarm_hour_long_up_down_flag=0; 
 371   5              alarm_hour_long_up_down_flag=0;       
 372   5              break;
 373   5            }
 374   4            case 2:
 375   4            {
 376   5              alarm2.hour--;
 377   5              if(hour_12_24_flag)
 378   5              {
 379   6                if(alarm2.hour==0)alarm2.hour=12;
 380   6              }
 381   5              else 
 382   5              {
 383   6                if(alarm2.hour>=24)alarm2.hour=23;
 384   6              }         
 385   5              alarm_hour_long_up_down_flag=0;       
 386   5              break;
 387   5            }     
 388   4            case 3:
 389   4            {
 390   5              alarm3.hour--;
 391   5               if(hour_12_24_flag)
 392   5              {
 393   6                if(alarm3.hour==0)alarm3.hour=12;
 394   6              }
 395   5              else 
 396   5              {
 397   6                if(alarm3.hour>=24)alarm3.hour=23;
 398   6              }       
 399   5              alarm_hour_long_up_down_flag=0;       
 400   5              break;
 401   5            }     
 402   4          
 403   4            default :
 404   4            break;      
 405   4          }
 406   3          switch(alarm_min_long_up_down_flag)
 407   3          {
 408   4            case 1:
 409   4            {
 410   5              alarm1.minute--;
 411   5              if(alarm1.minute>=60)alarm1.minute=59;
 412   5              alarm_min_long_up_down_flag=0;        
 413   5              break;
 414   5            }
 415   4            case 2:
 416   4            {
 417   5              alarm2.minute--;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 8   

 418   5              if(alarm2.minute>=60)alarm2.minute=59;
 419   5              alarm_min_long_up_down_flag=0;        
 420   5              break;
 421   5            }     
 422   4            case 3:
 423   4            {
 424   5              alarm3.minute--;
 425   5              if(alarm3.minute>=60)alarm3.minute=59;
 426   5              alarm_min_long_up_down_flag=0;        
 427   5              break;
 428   5            }     
 429   4            
 430   4            default :
 431   4            break;      
 432   4          }
 433   3          long_add_flag=0;
 434   3          second=0;
 435   3          while(!UP);
 436   3          if(long_flag==0)
 437   3          {
 438   4            UP_Short_Flag=1;
 439   4            second=0;
 440   4          }
 441   3        }
 442   2      
 443   2      //down按键
 444   2        if(DOWN==0)
 445   2        {
 446   3      
 447   3          time0_setup( );
 448   3          while(!DOWN)
 449   3          {
 450   4          //  pm_12_24_alarm_display();
 451   4            if(SET_Long_Flag==1)
 452   4            {
 453   5             key_dislpay_up_down( );
 454   5            }
 455   4            if(second==1)
 456   4            {
 457   5                back_TIME_Flag=0;
 458   5                if(mode_select_flag==0)
 459   5                {
 460   6                  temp_delay_time=0; //DP1计数清0
 461   6                  mon_day_delay_time=0;
 462   6                  hor_min_delay_time=0; 
 463   6                }
 464   5                
 465   5              long_add_flag=1;
 466   5              
 467   5              long_flag=1;
 468   5              DOWN_Long_Flag=1;
 469   5              if(SET_Long_Flag==1)
 470   5              {
 471   6                switch (flag_display)
 472   6                {
 473   7                  case 0:
 474   7                  {
 475   8                   if(SET_Short_Flag_hur_min==1)
 476   8                   {
 477   9                     hour_long_up_down(1);
 478   9                   }  
 479   8                    if(SET_Short_Flag_hur_min==2)
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 9   

 480   8                   {
 481   9                    min_long_up_down(1) ;
 482   9                   }            
 483   8                    break;
 484   8                  }
 485   7                  case 1:
 486   7                  {
 487   8                   if(SET_Short_Flag_mon_day==0)
 488   8                   {
 489   9                    year_long_up_down(1);
 490   9                   }
 491   8                   if(SET_Short_Flag_mon_day==1)
 492   8                   {
 493   9                    mon_long_up_down(1);
 494   9                   }
 495   8                   if(SET_Short_Flag_mon_day==2)
 496   8                   {
 497   9                    mday_long_up_down(1);
 498   9                   }             
 499   8                  
 500   8                    break;
 501   8                  }
 502   7                  case 2:
 503   7                  {
 504   8                    if(SET_Short_Flag_alarm1_flag==0) 
 505   8                    {
 506   9                       alarm_hour_long_up_down(1,2,  alarm1);
 507   9                      
 508   9                    }
 509   8                    if(SET_Short_Flag_alarm1_flag==1) 
 510   8                    {
 511   9                       alarm_min_long_up_down(1,2,alarm1);
 512   9                    }               
 513   8                    break;
 514   8                  }
 515   7                  case 3:
 516   7                  {
 517   8                    if(SET_Short_Flag_alarm1_flag==0) 
 518   8                    {
 519   9                       alarm_hour_long_up_down(2,2,alarm2);
 520   9                    }
 521   8                    if(SET_Short_Flag_alarm1_flag==1) 
 522   8                    {
 523   9                       alarm_min_long_up_down(2,2, alarm2);
 524   9                    }             
 525   8                    break;
 526   8                  }
 527   7                  case 4:
 528   7                  {
 529   8                    if(SET_Short_Flag_alarm1_flag==0) 
 530   8                    {
 531   9                       alarm_hour_long_up_down(3,2, alarm3);
 532   9                    }
 533   8                    if(SET_Short_Flag_alarm1_flag==1) 
 534   8                    {
 535   9                       alarm_min_long_up_down(3,2, alarm3);
 536   9                    }                       
 537   8                    break;
 538   8                  }
 539   7                  default :
 540   7                  break;
 541   7                              
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 10  

 542   7                }
 543   6      
 544   6                  
 545   6              } 
 546   5              if(flag_display==5&&ADC_ONE==1)
 547   5              {
 548   6                if(ADC_Display==0)ADC_Display=1;
 549   6                else ADC_Display=0;
 550   6                  adc_switch( );
 551   6      //          switch (ADC_Display)
 552   6      //           {
 553   6      //             
 554   6      //             case 0:
 555   6      //             {
 556   6      //                
 557   6      //               
 558   6      //               //FD612_display_4DIG_input(0x00,dis[(unsigned char)TEM2/10],dis[(unsigned char)TEM2%10],FD612_DI
             -SP_C);   
 559   6      //                FD612_PotiveTNage(FD612_DIG1_ADDR,0x00);
 560   6      //                FD612_PotiveTNage(FD612_DIG2_ADDR,dis[(unsigned char)TEM2/10]);
 561   6      //                FD612_PotiveTNage(FD612_DIG3_ADDR,dis[(unsigned char)TEM2%10]);
 562   6      //                FD612_PotiveTNage(FD612_DIG4_ADDR,FD612_DISP_cc);
 563   6      //                FD612_DispBuff.DispData[FD612_DIG12_ADDR]|= 1<<6 ; 
 564   6      //                FD612_Refresh();
 565   6      //               ADC_Display1=0;
 566   6      //               break;
 567   6      //             }
 568   6      //              
 569   6      
 570   6      //              case 1:
 571   6      //              {
 572   6      //              ADC_AVG_NUM[2]   = (unsigned char)TEM4/100;
 573   6      //              ADC_AVG_NUM[1]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )/10;
 574   6      //              ADC_AVG_NUM[0]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )%10;
 575   6      ////              FD612_display_4DIG_input(dis[ADC_AVG_NUM[2]],dis[ADC_AVG_NUM[1]],dis[ADC_AVG_NUM[0]],FD612_DISP
             -_F);
 576   6      //              FD612_PotiveTNage(FD612_DIG1_ADDR,dis[ADC_AVG_NUM[2]]);
 577   6      //              FD612_PotiveTNage(FD612_DIG2_ADDR,dis[ADC_AVG_NUM[1]]);
 578   6      //              FD612_PotiveTNage(FD612_DIG3_ADDR,dis[ADC_AVG_NUM[0]] );
 579   6      //                FD612_PotiveTNage(FD612_DIG4_ADDR,FD612_DISP_F);
 580   6      
 581   6      //              FD612_Refresh();  
 582   6      //                ADC_Display1=1;
 583   6      ////                ADC_Display=0;
 584   6      //                break;
 585   6      //              } 
 586   6      //                default :
 587   6      //                break;
 588   6      //          }
 589   6                ADC_ONE=0;
 590   6              }
 591   5            }
 592   4        
 593   4          }
 594   3          switch(alarm_hour_long_up_down_flag)
 595   3          {
 596   4            case 4:
 597   4            {
 598   5              alarm1.hour++;
 599   5              if(hour_12_24_flag)
 600   5              {
 601   6                if(alarm1.hour==13)alarm1.hour=1;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 11  

 602   6              }
 603   5              else 
 604   5              {
 605   6                if(alarm1.hour>=24)alarm1.hour=0;
 606   6              }       
 607   5              alarm_hour_long_up_down_flag=0;       
 608   5              break;
 609   5            }     
 610   4            case 5:
 611   4            {
 612   5              alarm2.hour++;
 613   5              if(hour_12_24_flag)
 614   5              {
 615   6                if(alarm2.hour==13)alarm2.hour=1;
 616   6              }
 617   5              else 
 618   5              {
 619   6                if(alarm2.hour>=24)alarm2.hour=0;
 620   6              }         
 621   5              alarm_hour_long_up_down_flag=0;       
 622   5              break;
 623   5            }
 624   4            case 6:
 625   4            {
 626   5              alarm3.hour++;
 627   5              if(hour_12_24_flag)
 628   5              {
 629   6                if(alarm3.hour==13)alarm3.hour=1;
 630   6              }
 631   5              else 
 632   5              {
 633   6                if(alarm3.hour>=24)alarm3.hour=0;
 634   6              }         
 635   5              alarm_hour_long_up_down_flag=0;       
 636   5              break;
 637   5            }
 638   4            default :
 639   4            break;      
 640   4          }
 641   3          switch(alarm_min_long_up_down_flag)
 642   3          {
 643   4            case 4:
 644   4            {
 645   5              alarm1.minute++;
 646   5              if(alarm1.minute==60)alarm1.minute=0;
 647   5              alarm_min_long_up_down_flag=0;        
 648   5              break;
 649   5            }     
 650   4            case 5:
 651   4            {
 652   5              alarm2.minute++;
 653   5              if(alarm2.minute==60)alarm2.minute=0;
 654   5              alarm_min_long_up_down_flag=0;        
 655   5              break;
 656   5            }
 657   4            case 6:
 658   4            {
 659   5              alarm3.minute++;
 660   5              if(alarm3.minute==60)alarm3.minute=0;
 661   5              alarm_min_long_up_down_flag=0;        
 662   5              break;
 663   5            }     
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 12  

 664   4            default :
 665   4            break;      
 666   4          }
 667   3          long_add_flag=0;
 668   3          ADC_ONE=1;
 669   3          second=0;
 670   3          while(!DOWN);
 671   3          if(long_flag==0)
 672   3          {
 673   4            DOWN_Short_Flag=1;
 674   4            second=0;
 675   4          }
 676   3        }
 677   2      }
 678   1      if(alarm_flag==1)
 679   1      {
 680   2        if(SET==0||UP==0||DOWN==0)
 681   2        {
 682   3          alarm_flag=0;
 683   3          PWM_CTRL &= ~(1<<3);
 684   3          alarm_voice_flag=0;   
 685   3        }
 686   2      }
 687   1      if(alarm2_flag==1)
 688   1      {
 689   2        if(SET==0||UP==0||DOWN==0)
 690   2        {
 691   3          alarm2_flag=0;
 692   3          PWM_CTRL &= ~(1<<3);
 693   3          alarm2_voice_flag=0;
 694   3        }
 695   2      }
 696   1      if(alarm3_flag==1)
 697   1      {
 698   2        if(SET==0||UP==0||DOWN==0)
 699   2        {
 700   3          alarm3_flag=0;
 701   3          PWM_CTRL &= ~(1<<3);
 702   3          alarm3_voice_flag=0;    
 703   3        }
 704   2      }
 705   1      
 706   1      }
 707          void display(void)
 708          {
 709   1      //  UINT8 pm_flag;
 710   1      //    temper_display();
 711   1          from_ds1302_read_time_data( );
 712   1          if(SET_Long_Flag==0)
 713   1          {
 714   2          if(SET_Short_Flag)
 715   2          {
 716   3            flag_display++;
 717   3            SET_Short_Flag=0;
 718   3            if(flag_display>5)
 719   3            {
 720   4              flag_display=0;
 721   4              ADC_fisrt=1;
 722   4            }
 723   3          }
 724   2      //    if(time.hour>=13&&hour_12_24_flag==1)
 725   2      //    {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 13  

 726   2      //      time.hour=time.hour-12;
 727   2      //      if(hour_pm_flag)hour_pm_flag=0;
 728   2      //      else hour_pm_flag=1;
 729   2      //      time.hour = decimal_bcd(time.hour);
 730   2      //     ResetDS1302();
 731   2      //     WriteByteDS1302(hour_w_addr); //写入时的地址
 732   2      //     WriteByteDS1302(time.hour);                                  
 733   2      //    time.hour = bcd_decimal(time.hour);     
 734   2      //    }
 735   2          }
 736   1          if(flag_display==0&&SET_Long_Flag==0&&display_flag_hur_min==1)
 737   1          {
 738   2            FD612_PotiveTNage(FD612_DIG5_ADDR,dis[time.second/10]);
 739   2            FD612_PotiveTNage(FD612_DIG6_ADDR,dis[time.second% 10]);                    
 740   2            FD612_Refresh();    
 741   2          }
 742   1          else
 743   1          {
 744   2            FD612_PotiveTNage(FD612_DIG5_ADDR,0X00);
 745   2            FD612_PotiveTNage(FD612_DIG6_ADDR,0X00);                    
 746   2            FD612_Refresh();      
 747   2          }
 748   1          switch(flag_display)
 749   1          {
 750   2            case 0:
 751   2              {
 752   3      
 753   3      
 754   3      
 755   3                    if(display_flag_hur_min)
 756   3                    {
 757   4                        point_blink();
 758   4                                      
 759   4      
 760   4                    
 761   4                    
 762   4      
 763   4      //              after_arrive_write_1302();  
 764   4                    }
 765   3                    if(SET_Long_Flag)
 766   3                    {
 767   4                      if(key_first)
 768   4                      {
 769   5                        key_first=0;
 770   5                        UP_Short_Flag=0;
 771   5                        DOWN_Short_Flag = 0;
 772   5                      }
 773   4                      display_flag_hur_min=0;
 774   4                      if(SET_Short_Flag)
 775   4                      {
 776   5                        SET_Short_Flag_hur_min++;
 777   5                        SET_Short_Flag=0;
 778   5                        if(SET_Short_Flag_hur_min>4)
 779   5                        {
 780   6                          SET_Short_Flag_hur_min=0;
 781   6                        }
 782   5                      }
 783   4                      if(SET_Short_Flag_hur_min==0)
 784   4                      {
 785   5                          display_12_24_blink( ); 
 786   5                          if(UP_Short_Flag==1)
 787   5                          {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 14  

 788   6                              if(hour_12_24_flag)
 789   6                              {
 790   7                                hour_12_24_flag=0;
 791   7                                hour_chage_input(hour_12_24_flag);
 792   7                                if(alarm1_pm_flag)
 793   7                            {
 794   8                              if(alarm1.hour!=12)
 795   8                              {
 796   9                                alarm1.hour=alarm1.hour+12;
 797   9                              }
 798   8                              alarm1_pm_flag=0;
 799   8                            }
 800   7                            else if(alarm1.hour==12)alarm1.hour=0;
 801   7                            
 802   7                            if(alarm2_pm_flag)
 803   7                            {
 804   8                              if(alarm2.hour!=12)
 805   8                              {
 806   9                                alarm2.hour=alarm2.hour+12;
 807   9                              }
 808   8                              alarm2_pm_flag=0;
 809   8                            }
 810   7                            else if(alarm2.hour==12)alarm2.hour=0;
 811   7                            
 812   7                            if(alarm3_pm_flag)
 813   7                            {
 814   8                              if(alarm3.hour!=12)
 815   8                              {
 816   9                                alarm3.hour=alarm3.hour+12;
 817   9                              }
 818   8                              alarm3_pm_flag=0;
 819   8                            }
 820   7                            else if(alarm3.hour==12)alarm3.hour=0;  
 821   7                              }
 822   6                              
 823   6                              else  
 824   6                              {
 825   7                                hour_12_24_flag=1;
 826   7                                hour_chage_input(hour_12_24_flag);    
 827   7                            if(alarm1.hour>12)
 828   7                            {
 829   8                              alarm1.hour=alarm1.hour-12;
 830   8                              alarm1_pm_flag=1;
 831   8                            }
 832   7                            if(alarm1.hour==12)alarm1_pm_flag=1;
 833   7                            if(alarm1.hour==0){alarm1.hour=12;alarm1_pm_flag=0;}
 834   7                            
 835   7                            if(alarm2.hour>12)
 836   7                            {
 837   8                              alarm2.hour=alarm2.hour-12;
 838   8                              alarm2_pm_flag=1;
 839   8                            }
 840   7                            if(alarm2.hour==12)alarm2_pm_flag=1;
 841   7                            if(alarm2.hour==0){alarm2.hour=12;alarm2_pm_flag=0;}
 842   7                            
 843   7                            if(alarm3.hour>12)
 844   7                            {
 845   8                              alarm3.hour=alarm3.hour-12;
 846   8                              alarm3_pm_flag=1;
 847   8                            }
 848   7                            if(alarm3.hour==12)alarm3_pm_flag=1;
 849   7                            if(alarm3.hour==0){alarm3.hour=12;alarm3_pm_flag=0;}                          
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 15  

 850   7                              }
 851   6                              UP_Short_Flag=0;
 852   6                                                                                        
 853   6                        }
 854   5                      }
 855   4                      if(SET_Short_Flag_hur_min==1)
 856   4                      {
 857   5      //                  if(hour_12_24_flag==1)
 858   5      //                  {
 859   5      //                    time.hour<<=3;
 860   5      //                    time.hour>>=3;
 861   5      //                    time.hour &=~(1<<7);
 862   5      //                    time.hour &=~(1<<5);
 863   5      //                  }
 864   5                      FD612_DISPLAY_2DIG_input(2, dis[time.minute/10] ,dis[time.minute%10]);  
 865   5                      if(time1_second)
 866   5                      {
 867   6                      if(blink_flag)
 868   6                      { 
 869   7                        blink_flag=0;
 870   7                        FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10] , dis[time.hour%10]);
 871   7                      }
 872   6                      else
 873   6                      {
 874   7                        blink_flag=1; 
 875   7                        FD612_DISPLAY_2DIG_input(1 ,0x00 ,0x00  );
 876   7                      }
 877   6                      time1_second=0;
 878   6                      }
 879   5                      if(UP_Short_Flag==1)
 880   5                      {                   
 881   6                          time.hour++;
 882   6                        if(hour_12_24_flag){
 883   7                           if(time.hour>=13)
 884   7                           {
 885   8                             time.hour = 1;                  
 886   8                             
 887   8                           }
 888   7                        if(time.hour==12) after_arrive_write_1302();
 889   7                          }
 890   6                        else
 891   6                        {
 892   7                          if(time.hour >=24)
 893   7                          {
 894   8                            time.hour = 0;
 895   8                          }
 896   7                        }
 897   6                          UP_Short_Flag=0;
 898   6                      }
 899   5                        if(DOWN_Short_Flag == 1)
 900   5                      {
 901   6                          time.hour--;  
 902   6                        if(hour_12_24_flag){
 903   7                           if(time.hour>=13||time.hour==0)
 904   7                           {
 905   8                              time.hour = time.hour -244; //溢出值
 906   8                         
 907   8                             
 908   8                           }
 909   7                        if(time.hour==11) after_arrive_write_1302();                   
 910   7                          }
 911   6                        else
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 16  

 912   6                        {
 913   7                          if(time.hour >=24)
 914   7                          {
 915   8                            time.hour = time.hour -232; //溢出值
 916   8                          }
 917   7                        }                 
 918   6      
 919   6                          DOWN_Short_Flag = 0;
 920   6                      }
 921   5                      time.hour = decimal_bcd(time.hour);
 922   5      //                ResetDS1302();
 923   5      //                WriteByteDS1302(hour_w_addr); //写入时的地址
 924   5                      if(hour_12_24_flag)
 925   5                      {
 926   6                        time.hour |=1<<7;
 927   6                        if(hour_pm_flag)time.hour |=1<<5;
 928   6                        else time.hour &=~(1<<5);
 929   6                      }
 930   5                      else time.hour &=~(1<<7);
 931   5                      Write_addr_byte_ds1302(hour_w_addr,time.hour);
 932   5      //                ResetDS1302();
 933   5      //                WriteByteDS1302(hour_w_addr); //写入时的地址                
 934   5      //                WriteByteDS1302(time.hour);
 935   5      //                ResetDS1302();
 936   5                      }
 937   4                      if(SET_Short_Flag_hur_min==2)
 938   4                      {
 939   5                        FD612_DispBuff.DispData[12]|=1<<2;
 940   5                        FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10]  ,dis[time.hour%10]);
 941   5                        if(time1_second)
 942   5                        {
 943   6                          if(blink_flag)
 944   6                          {
 945   7                            blink_flag=0;
 946   7                            
 947   7                            FD612_PotiveTNage(FD612_DIG3_ADDR,dis[time.minute/10]);
 948   7                            FD612_PotiveTNage(FD612_DIG4_ADDR,dis[time.minute%10]);
 949   7                            pm_12_24_alarm_display();
 950   7                            FD612_Refresh();
 951   7                          }
 952   6                        else
 953   6                          {
 954   7                            blink_flag=1;
 955   7                            FD612_PotiveTNage(FD612_DIG3_ADDR,0x00);
 956   7                            FD612_PotiveTNage(FD612_DIG4_ADDR,0x00);
 957   7                            pm_12_24_alarm_display();
 958   7                            FD612_Refresh();
 959   7                            
 960   7                          }
 961   6                          time1_second=0;
 962   6                         }
 963   5                          if(UP_Short_Flag == 1)
 964   5                          {
 965   6                              time.minute++;
 966   6                            if(time.minute >=60)
 967   6                            {
 968   7                              time.minute = 0;
 969   7                            }
 970   6                              UP_Short_Flag = 0;
 971   6                            
 972   6                            Write_addr_byte_ds1302(sec_w_addr,0);
 973   6      //                      ResetDS1302();
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 17  

 974   6      //                      WriteByteDS1302(sec_w_addr); //写入秒的地址
 975   6      //                      WriteByteDS1302(0);
 976   6                          }
 977   5                          if(DOWN_Short_Flag == 1)
 978   5                          {
 979   6                              time.minute--;
 980   6                            if(time.minute>60)
 981   6                            {
 982   7                                time.minute = time.minute -196; //溢出值
 983   7                            }
 984   6                              DOWN_Short_Flag = 0;
 985   6                              Write_addr_byte_ds1302(sec_w_addr,0);
 986   6      //                        ResetDS1302();
 987   6      //                        WriteByteDS1302(sec_w_addr); //写入秒的地址
 988   6      //                        WriteByteDS1302(0); 
 989   6      
 990   6                          }
 991   5                          time.minute = decimal_bcd(time.minute);
 992   5                          
 993   5                          Write_addr_byte_ds1302(min_w_addr,time.minute);
 994   5      //                    ResetDS1302();
 995   5      //                    WriteByteDS1302(min_w_addr); //写入秒的地址
 996   5      //                    WriteByteDS1302(time.minute);
 997   5                      }
 998   4                      if(SET_Short_Flag_hur_min==3)
 999   4                      {
1000   5                        display_flag_hur_min=1;
1001   5                        SET_Long_Flag=0;
1002   5                        SET_Short_Flag_hur_min=0;
1003   5                        key_first=1;
1004   5                      }
1005   4                      if(back_first)
1006   4                      {
1007   5                        back_TIME_Flag=0;
1008   5                        back_first=0;
1009   5                      }
1010   4                      if(back_TIME_Flag==over_time)
1011   4                      {
1012   5                        display_flag_hur_min=1; 
1013   5                        SET_Long_Flag=0;
1014   5                        SET_Short_Flag_hur_min=0;
1015   5                        back_TIME_Flag=0;
1016   5                        back_first=1;
1017   5                        key_first=1;
1018   5                        dp_mode_exit();
1019   5                        if(mode_select_flag==2) flag_display=0;
1020   5                      }
1021   4                    
1022   4                      
1023   4                    }
1024   3                    break;          
1025   3              }
1026   2              case 1:
1027   2                {
1028   3      
1029   3                    
1030   3              
1031   3      
1032   3      
1033   3                if(SET_Long_Flag)
1034   3                {
1035   4                      if(key_first)
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 18  

1036   4                      {
1037   5                        key_first=0;
1038   5                        UP_Short_Flag=0;
1039   5                        DOWN_Short_Flag = 0;
1040   5                      }           
1041   4                  display_flag_mon_day=0;
1042   4                
1043   4                if(SET_Short_Flag)
1044   4                      {
1045   5                        SET_Short_Flag_mon_day++;
1046   5                        SET_Short_Flag=0;
1047   5                        if(SET_Short_Flag_mon_day>4)
1048   5                        {
1049   6                          SET_Short_Flag_mon_day=0;
1050   6                        }
1051   5                      }
1052   4                if(SET_Short_Flag_mon_day==0)
1053   4                {
1054   5                year_blink(0);
1055   5                if(UP_Short_Flag == 1)
1056   5                {
1057   6                    time.year++;  
1058   6                    if(time.year>99)time.year=0;
1059   6                    UP_Short_Flag = 0;
1060   6                }
1061   5                if(DOWN_Short_Flag == 1)
1062   5                {
1063   6                    time.year--;
1064   6                    DOWN_Short_Flag = 0;
1065   6                } 
1066   5                time.year= decimal_bcd(time.year);
1067   5                Write_addr_byte_ds1302(year_w_addr,time.year);
1068   5      //          ResetDS1302();
1069   5      //          WriteByteDS1302(year_w_addr); //写入秒的地址
1070   5      //          WriteByteDS1302(time.year);
1071   5                
1072   5                }
1073   4                if(SET_Short_Flag_mon_day==1)
1074   4                {
1075   5                        
1076   5                      FD612_DISPLAY_2DIG_input(2,dis[time.mday/10] ,dis[time.mday%10] );
1077   5                      if(time1_second)
1078   5                      {
1079   6                      if(blink_flag)
1080   6                      {
1081   7                        blink_flag=0; 
1082   7                        FD612_DISPLAY_2DIG_input(1 ,dis[time.month/10] ,dis[time.month%10] );
1083   7                      }
1084   6                      else
1085   6                      {
1086   7                        blink_flag=1;
1087   7                        FD612_DISPLAY_2DIG_input(1 ,0x00  ,0x00 );
1088   7                      }
1089   6                      time1_second=0;
1090   6                      }
1091   5                if(UP_Short_Flag == 1)
1092   5                {
1093   6                    time.month++;
1094   6                  
1095   6                  if(time.month >=13)
1096   6                  {
1097   7                    time.month = 1;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 19  

1098   7                  }
1099   6                    UP_Short_Flag = 0;
1100   6                }
1101   5                if(DOWN_Short_Flag == 1)
1102   5                {
1103   6                    time.month--;
1104   6                    
1105   6                  if(time.month==0 || time.month>13)
1106   6                  {
1107   7                      time.month = time.month -244; //溢出值
1108   7                  }
1109   6                    DOWN_Short_Flag = 0;
1110   6                } 
1111   5                time.month = decimal_bcd(time.month);
1112   5      
1113   5                Write_addr_byte_ds1302(mon_w_addr,time.month);
1114   5      //          ResetDS1302();
1115   5      //          WriteByteDS1302(mon_w_addr); //写入秒的地址
1116   5      //          WriteByteDS1302(time.month);
1117   5                }
1118   4                if(SET_Short_Flag_mon_day==2)
1119   4                      {
1120   5                        
1121   5                        
1122   5                        FD612_DISPLAY_2DIG_input(1 ,dis[time.month/10] ,dis[time.month%10] );
1123   5                        if(time1_second)
1124   5                        {
1125   6                          if(blink_flag)
1126   6                          {
1127   7                            blink_flag=0; 
1128   7                            FD612_DISPLAY_2DIG_input(2,dis[time.mday/10] ,dis[time.mday%10] );
1129   7                          }
1130   6                        else
1131   6                          {
1132   7                            blink_flag=1; 
1133   7                            FD612_DISPLAY_2DIG_input(2,0x00 ,0x00 );
1134   7                          }
1135   6                          time1_second=0;
1136   6                         }
1137   5                       
1138   5                if(UP_Short_Flag >= 1)
1139   5                {
1140   6                    time.mday++;
1141   6                               
1142   6                    if(time.mday>=32)   
1143   6                    {                         
1144   7                          time.mday=1;
1145   7                    }          
1146   6              
1147   6                  UP_Short_Flag = 0;            
1148   6                } 
1149   5                if(DOWN_Short_Flag >= 1)
1150   5                {
1151   6                    time.mday--;
1152   6                    if(time.mday==0 || time.mday >=32)
1153   6                      {               
1154   7                    
1155   7                      time.mday = time.mday -225;
1156   7                      }          
1157   6                                                                              
1158   6                    DOWN_Short_Flag = 0;
1159   6                }         
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 20  

1160   5                time.mday = decimal_bcd(time.mday);
1161   5                Write_addr_byte_ds1302(day_w_addr,time.mday);
1162   5      //          ResetDS1302();
1163   5      //          WriteByteDS1302(day_w_addr); //写入秒的地址
1164   5      //          WriteByteDS1302(time.mday);
1165   5                
1166   5                }
1167   4                       
1168   4                      if(SET_Short_Flag_mon_day==3)
1169   4                      {
1170   5                        display_flag_mon_day=1;
1171   5                        SET_Long_Flag=0;
1172   5                        SET_Short_Flag_mon_day=0;
1173   5                        key_first=1;
1174   5                      }
1175   4                      if(back_first)
1176   4                      {
1177   5                        back_TIME_Flag=0;
1178   5                        back_first=0;
1179   5                      }
1180   4                      if(back_TIME_Flag==over_time)
1181   4                      {
1182   5                        display_flag_mon_day=1; 
1183   5                        SET_Long_Flag=0;
1184   5                        SET_Short_Flag_mon_day=0;
1185   5                        back_TIME_Flag=0;
1186   5                        back_first=1;
1187   5                        key_first=1;
1188   5                        dp_mode_exit();                   
1189   5                      }                 
1190   4                    }
1191   3                    
1192   3                  if(display_flag_mon_day)
1193   3                    {
1194   4                      
1195   4                      FD612_display_4DIG_input( dis[time.month/10] ,dis[time.month% 10] ,dis[time.mday/10] , dis[time.md
             -ay% 10]);
1196   4                    }
1197   3                    
1198   3                    
1199   3      //              if(SET_Long_Flag==0){
1200   3      //              if(back_first)
1201   3      //                {
1202   3      //                  back_TIME_Flag=0;
1203   3      //                  back_first=0;
1204   3      //                }
1205   3      //                if(back_TIME_Flag==over_time)
1206   3      //                {
1207   3      //                  display_flag_mon_day=1; 
1208   3      //                  SET_Long_Flag=0;
1209   3      //                  SET_Short_Flag_mon_day=0;
1210   3      //                  back_TIME_Flag=0;
1211   3      //                  back_first=1;
1212   3      //                  key_first=1;
1213   3      //                  if(mode_select_flag==2) flag_display=0;
1214   3      //                } 
1215   3      //              }
1216   3                  break;            
1217   3                }
1218   2              case 2:
1219   2                {
1220   3      
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 21  

1221   3                  alarm_set_display(1, alarm1);
1222   3                  break;  
1223   3                }
1224   2              case 3:
1225   2                {
1226   3      
1227   3                  alarm_set_display(2, alarm2);
1228   3                  break;  
1229   3                }
1230   2              case 4:
1231   2                {
1232   3      
1233   3                  alarm_set_display(3, alarm3);
1234   3                  break;  
1235   3                }
1236   2            
1237   2              case 5:
1238   2              {
1239   3                if(SET_Long_Flag==1)SET_Long_Flag=0;
1240   3                if(UP_Short_Flag)UP_Short_Flag=0;
1241   3                if(ADC_fisrt)
1242   3                {
1243   4                  ADC_Convert( );
1244   4                  ADC_fisrt=0;
1245   4                  ADC_TIME_Flag=0;
1246   4                  
1247   4                }
1248   3                temper_display();
1249   3      //          if(ADC_TIME_Flag==temp_refresh_time)
1250   3      //          {
1251   3      //            ADC_fisrt=1;
1252   3      //            ADC_TIME_Flag=0;
1253   3      //          }
1254   3      //        
1255   3      //      if(ADC_Display1==0)
1256   3      //      {     
1257   3      //      FD612_display_4DIG_input( 0x00 ,dis[(unsigned char)TEM2/10] ,dis[(unsigned char)TEM2%10] ,FD612_DISP_
             -C );
1258   3      //      }
1259   3      //      else
1260   3      //      {
1261   3      //      ADC_AVG_NUM[2]   = (unsigned char)TEM4/100;
1262   3      //      ADC_AVG_NUM[1]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )/10;
1263   3      //      ADC_AVG_NUM[0]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )%10;
1264   3      
1265   3      //      FD612_display_4DIG_input(dis[ADC_AVG_NUM[2]]  , dis[ADC_AVG_NUM[1]],dis[ADC_AVG_NUM[0]]  ,FD612_DISP_
             -F );
1266   3      //      }       
1267   3                if(back_first)
1268   3                {
1269   4                  back_TIME_Flag=0;
1270   4                  back_first=0;
1271   4                }
1272   3                if(back_TIME_Flag==over_time)
1273   3                {                                                   
1274   4                  back_TIME_Flag=0;
1275   4                  back_first=1;
1276   4                  if(mode_select_flag==2) flag_display=0;
1277   4                  dp_mode_exit();                     
1278   4                }
1279   3                break;  
1280   3              }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 22  

1281   2              default :
1282   2              break;
1283   2          }
1284   1      }
1285          
1286          
1287          
1288          
1289          
1290          
1291          void  ADC_Convert(void) 
1292          {
1293   1          float VCC = 4.77;                          //
1294   1          float ADC_VALUE;                           //
1295   1                                 //
1296   1      //    unsigned int B_value = 3450;
1297   1          unsigned int B_value = 3950;//科艺传感器
1298   1      
1299   1          ADC_CHAN1 =0;
1300   1          ADC_CHAN0=0;
1301   1          P1_DIR_PU &= ~bAIN0;  
1302   1          ADC_START = 1;  
1303   1          while(ADC_START);                                                      //ADC_START变为0时，表示采样完成
1304   1          ADC_VALUE = ADC_DATA * VCC / 255; // 读取转换的AD值   
1305   1        
1306   1          TEM = 1/(log(ADC_VALUE/(VCC - ADC_VALUE))/B_value + 1/(273.15 + 25));
1307   1            
1308   1          TEM4=TEM2*1.8+32;
1309   1          TEM2=TEM- 273.15;
1310   1          
1311   1      }
1312          
1313          
1314          void alarm1_sleep(void)
1315          {
1316   1          UINT8 alarm1_value1,alarm1_value2,alarm1_value3,alarm1_value4,alarm1_value5;
1317   1          if(time.second==0 && time.hour==alarm1.hour && time.minute==alarm1.minute&&hour_pm_flag==alarm1_pm_flag)
1318   1          {
1319   2            alarm_flag=1;
1320   2            alarm_voice_flag=1;
1321   2          }
1322   1          if(alarm_flag)
1323   1          {
1324   2            alarm1_value1=alarm1.minute+alarm_time;
1325   2            alarm1_value2=alarm1.minute+alarm_time+sleep_time;
1326   2            alarm1_value3=alarm1.minute+(alarm_time*2)+sleep_time;
1327   2            alarm1_value4=alarm1.minute+(alarm_time*2)+(sleep_time*2);
1328   2            alarm1_value5=alarm1.minute+(alarm_time*3)+(sleep_time*2);
1329   2            if(alarm_voice_flag)
1330   2            {
1331   3              
1332   3              if(alarm_clock_flag)
1333   3              {
1334   4                if(TR0)
1335   4                {TR0=0;buzzer=0;}
1336   4                else TR0=1;
1337   4                alarm_clock_flag=0;
1338   4              }       
1339   3              
1340   3            }
1341   2            if((alarm1_value1)>=60)
1342   2            {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 23  

1343   3              if((alarm1_value1-60)==time.minute)
1344   3              {
1345   4               TR0=0;
1346   4               buzzer=0;
1347   4               alarm_voice_flag=0;
1348   4              }
1349   3            }
1350   2            else if((alarm1_value1)==time.minute)
1351   2            {
1352   3              TR0=0;
1353   3              buzzer=0;
1354   3              alarm_voice_flag=0;
1355   3            }
1356   2            if((alarm1_value2)>=60)
1357   2            {
1358   3              if((alarm1_value2-60)==time.minute)
1359   3              {
1360   4                alarm_voice_flag=1;
1361   4              }       
1362   3            }
1363   2            else if(alarm1_value2==time.minute)
1364   2            {
1365   3              alarm_voice_flag=1;
1366   3            }
1367   2            if((alarm1_value3)>=60)
1368   2            {
1369   3              if((alarm1_value3-60)==time.minute)
1370   3              {
1371   4                TR0=0;
1372   4                buzzer=0;
1373   4                alarm_voice_flag=0;
1374   4              }       
1375   3            }
1376   2            else if((alarm1_value3)==time.minute)
1377   2            {
1378   3              TR0=0;
1379   3              buzzer=0;
1380   3              alarm_voice_flag=0;
1381   3            }
1382   2            if((alarm1_value4)>=60)
1383   2            {
1384   3              if((alarm1_value4-60)==time.minute)
1385   3              {
1386   4                alarm_voice_flag=1;
1387   4              }       
1388   3            }
1389   2            else if((alarm1_value4)==time.minute)
1390   2            {
1391   3              alarm_voice_flag=1;
1392   3            }
1393   2            if((alarm1_value5)>=60)
1394   2            {
1395   3              if((alarm1_value5-60)==time.minute)
1396   3              {
1397   4                TR0=0;
1398   4                buzzer=0;
1399   4                alarm_voice_flag=0;
1400   4              }     
1401   3            }
1402   2            else if((alarm1_value5)==time.minute)
1403   2            {
1404   3              TR0=0;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 24  

1405   3              buzzer=0;
1406   3              alarm_voice_flag=0;
1407   3            }
1408   2      
1409   2          }
1410   1      
1411   1      }
1412          
1413          void alarm2_sleep(void)
1414          {
1415   1          UINT8 alarm2_value1,alarm2_value2,alarm2_value3,alarm2_value4,alarm2_value5;
1416   1          if(time.second==0 && time.hour==alarm2.hour && time.minute==alarm2.minute&&hour_pm_flag==alarm2_pm_flag)
1417   1          {
1418   2            alarm2_flag=1;
1419   2            alarm2_voice_flag=1;
1420   2          }
1421   1          if(alarm2_flag)
1422   1          {
1423   2            alarm2_value1=alarm2.minute+alarm_time;
1424   2            alarm2_value2=alarm2.minute+alarm_time+sleep_time;
1425   2            alarm2_value3=alarm2.minute+(alarm_time*2)+sleep_time;
1426   2            alarm2_value4=alarm2.minute+(alarm_time*2)+(sleep_time*2);
1427   2            alarm2_value5=alarm2.minute+(alarm_time*3)+(sleep_time*2);
1428   2            
1429   2            if(alarm2_voice_flag)
1430   2            {
1431   3              if(alarm_clock_flag)
1432   3              {
1433   4                if(TR0)
1434   4                {TR0=0;buzzer=0;}
1435   4                else TR0=1;
1436   4                alarm_clock_flag=0;
1437   4              }
1438   3            }
1439   2            if((alarm2_value1)>=60)
1440   2            {
1441   3              if((alarm2_value1-60)==time.minute)
1442   3              {
1443   4                TR0=0;
1444   4                buzzer=0;
1445   4                alarm2_voice_flag=0;
1446   4              }     
1447   3            }
1448   2            else if((alarm2_value1)==time.minute)
1449   2            {
1450   3              TR0=0;
1451   3              buzzer=0;
1452   3              alarm2_voice_flag=0;
1453   3            }
1454   2            if((alarm2_value2)>=60)
1455   2            {
1456   3               if((alarm2_value2-60)==time.minute)
1457   3              {
1458   4                alarm2_voice_flag=1;
1459   4              }
1460   3            }
1461   2            else if((alarm2_value2)==time.minute)
1462   2            {
1463   3              alarm2_voice_flag=1;
1464   3            }
1465   2            if((alarm2_value3)>=60)
1466   2            {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 25  

1467   3              if((alarm2_value3-60)>=time.minute)
1468   3              {
1469   4                TR0=0;
1470   4                buzzer=0;
1471   4                alarm2_voice_flag=0;
1472   4              }
1473   3            }     
1474   2            else if((alarm2_value3)==time.minute)
1475   2            {
1476   3              TR0=0;
1477   3              buzzer=0;
1478   3              alarm2_voice_flag=0;
1479   3            }
1480   2            if((alarm2_value4)>=60)
1481   2            {
1482   3              if((alarm2_value4-60)==time.minute)
1483   3              alarm2_voice_flag=1;
1484   3            }     
1485   2            else if((alarm2_value4)==time.minute)
1486   2            {
1487   3              alarm2_voice_flag=1;
1488   3            }
1489   2            if((alarm2_value5)>=60)
1490   2            {
1491   3            if((alarm2_value5-60)==time.minute)
1492   3            {
1493   4              TR0=0;
1494   4              buzzer=0;
1495   4              alarm2_voice_flag=0;
1496   4            }       
1497   3            }
1498   2            else if((alarm2_value5)==time.minute)
1499   2            {
1500   3              TR0=0;
1501   3              buzzer=0;
1502   3              alarm2_voice_flag=0;
1503   3            }
1504   2      
1505   2          }
1506   1      
1507   1      }
1508          
1509          void alarm3_sleep(void)
1510          {
1511   1          UINT8 alarm3_value1,alarm3_value2,alarm3_value3,alarm3_value4,alarm3_value5;
1512   1          if(time.second==0 && time.hour==alarm3.hour && time.minute==alarm3.minute&&hour_pm_flag==alarm3_pm_flag)
1513   1          {
1514   2            alarm3_flag=1;
1515   2            alarm3_voice_flag=1;
1516   2          }
1517   1          if(alarm3_flag)
1518   1          {
1519   2            alarm3_value1=alarm3.minute+alarm_time;
1520   2            alarm3_value2=alarm3.minute+alarm_time+sleep_time;
1521   2            alarm3_value3=alarm3.minute+(alarm_time*2)+sleep_time;
1522   2            alarm3_value4=alarm3.minute+(alarm_time*2)+(sleep_time*2);
1523   2            alarm3_value5=alarm3.minute+(alarm_time*3)+(sleep_time*2);
1524   2            if(alarm3_voice_flag)
1525   2            {
1526   3              if(alarm_clock_flag)
1527   3              {
1528   4                if(TR0)
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 26  

1529   4                {TR0=0;buzzer=0;}
1530   4                else TR0=1;
1531   4                alarm_clock_flag=0;
1532   4              }
1533   3            }
1534   2            if((alarm3_value1)>=60)
1535   2            {
1536   3              if((alarm3_value1-60)==time.minute)
1537   3              {
1538   4                TR0=0;
1539   4                buzzer=0;
1540   4                alarm3_voice_flag=0;
1541   4              }       
1542   3            }
1543   2            else if((alarm3_value1)==time.minute)
1544   2            {
1545   3              TR0=0;
1546   3              buzzer=0;
1547   3              alarm3_voice_flag=0;
1548   3            }
1549   2            
1550   2            if((alarm3_value2)>=60)
1551   2            {
1552   3              if((alarm3_value2-60)==time.minute)
1553   3              {
1554   4                alarm3_voice_flag=1;
1555   4              }       
1556   3            }
1557   2            else if((alarm3_value2)==time.minute)
1558   2            {
1559   3              alarm3_voice_flag=1;
1560   3            }
1561   2            if((alarm3_value3)>=60)
1562   2            {
1563   3              if((alarm3_value3-60)==time.minute)
1564   3              {
1565   4                TR0=0;
1566   4                buzzer=0;
1567   4                alarm3_voice_flag=0;
1568   4              }       
1569   3            }
1570   2            else if((alarm3_value3)==time.minute)
1571   2            {
1572   3              TR0=0;
1573   3              buzzer=0;
1574   3              alarm3_voice_flag=0;
1575   3            }
1576   2            if((alarm3_value4)>=60)
1577   2            {
1578   3              if((alarm3_value4-60)==time.minute)
1579   3              {
1580   4                alarm3_voice_flag=1;
1581   4              }       
1582   3            }
1583   2            else if((alarm3_value4)==time.minute)
1584   2            {
1585   3              alarm3_voice_flag=1;
1586   3            }
1587   2            if((alarm3_value5)>=60)
1588   2            {
1589   3              if((alarm3_value5-60)==time.minute)
1590   3              {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 27  

1591   4                TR0=0;
1592   4                buzzer=0;
1593   4                alarm3_voice_flag=0;
1594   4              }       
1595   3            }
1596   2            else if((alarm3_value5)==time.minute)
1597   2            {
1598   3              TR0=0;
1599   3              buzzer=0;
1600   3              alarm3_voice_flag=0;
1601   3            }
1602   2      
1603   2          }
1604   1      
1605   1      }
1606          
1607          void alarm_display (void)
1608          {
1609   1         if(alarm1_on_dispaly)
1610   1       {
1611   2          alarm1_sleep( );
1612   2       }
1613   1         if(alarm2_on_dispaly)
1614   1       {
1615   2          alarm2_sleep( );
1616   2       }
1617   1         if(alarm3_on_dispaly)
1618   1       {
1619   2          alarm3_sleep( );
1620   2       }
1621   1      }
1622          
1623          
1624          
1625          void voice_control(void)
1626          {
1627   1        if(SET_Long_Flag==0)
1628   1        {
1629   2          if(voice_flag==0)
1630   2          {
1631   3          if(voice_key==1)
1632   3            {
1633   4        
1634   4              if(voice_key==1)
1635   4              {
1636   5                FD612_DispStateWr(FD612_INTENS8|FD612_DISP_ON);  
1637   5                FD612_Refresh();
1638   5              }
1639   4      
1640   4            }
1641   3              else
1642   3              {
1643   4                FD612_DispStateWr(FD612_DISP_OFF); 
1644   4                FD612_Refresh();
1645   4              }     
1646   3          }
1647   2          if(FD612_DispBuff.DispState&0x08)
1648   2              {
1649   3              
1650   3                voice_flag=1;
1651   3                if(voice_fisrt)
1652   3                {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 28  

1653   4                  back_voice_Flag=0;
1654   4                  voice_fisrt=0;
1655   4                }
1656   3      
1657   3                if(back_voice_Flag==voice_wake_up_time)
1658   3                {
1659   4                  voice_flag=0;
1660   4                  voice_fisrt=1;
1661   4                  flag_display=0;
1662   4                  FD612_DispStateWr(FD612_DISP_OFF); 
1663   4                  FD612_Refresh();
1664   4                  mDelayuS(150);
1665   4              
1666   4                }
1667   3              }
1668   2            }
1669   1      }
1670          
1671          void sd_mode (void)
1672          {
1673   1        if(DOWN_Short_Flag)
1674   1        {
1675   2          up_down_flag=1;//up_down键与模式选择冲突
1676   2      //    if(SET_Long_Flag==0&&flag_display !=5)
1677   2          if(SET_Long_Flag==0&&flag_display ==0)
1678   2          {
1679   3            dislay_all_flag=1;
1680   3            sd_flag++;
1681   3            if(sd_select_first==1)
1682   3                {
1683   4                  sd_flag--;
1684   4                  sd_select_first=0;
1685   4                }
1686   3                if(sd_flag>1)sd_flag=0;     
1687   3              switch(sd_flag)
1688   3              {
1689   4                case 0:
1690   4                {
1691   5                  
1692   5                  FD612_display_4DIG_input(0x40  ,0x40 ,FD612_DISP_S ,FD612_DISP_d  );
1693   5                  sd_mode_flag=0;
1694   5                  break;
1695   5            
1696   5                }
1697   4                case 1: 
1698   4                {
1699   5                  
1700   5                  FD612_display_4DIG_input(0x5c  ,0x54 ,FD612_DISP_S ,FD612_DISP_d );
1701   5                  sd_mode_flag=1;
1702   5                  break;
1703   5                }
1704   4                  default :
1705   4                  break;          
1706   4              }
1707   3          }
1708   2          up_down_flag=0;
1709   2          DOWN_Short_Flag=0;  
1710   2          mode_select_first=1;
1711   2        if(back_first)
1712   2          {
1713   3            back_TIME_Flag=0;
1714   3            back_first=0;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 29  

1715   3          }   
1716   2        }
1717   1        if(back_first)
1718   1          {
1719   2            back_TIME_Flag=0;
1720   2            back_first=0;
1721   2          }
1722   1          if(back_TIME_Flag==over_time  ||SET_Short_Flag==1)
1723   1          {
1724   2      
1725   2            dislay_all_flag=0;
1726   2            back_TIME_Flag=0;
1727   2            back_first=1; 
1728   2            UP_Short_Flag=0;
1729   2            SET_Short_Flag=0;
1730   2            mode_select_first=1;
1731   2            sd_select_first=1;
1732   2      //      up_down_flag=0;
1733   2            
1734   2      
1735   2          }         
1736   1      }
1737          
1738          
1739          void Display_Mode_Select(void)
1740          {
1741   1          if(UP_Short_Flag)
1742   1          {
1743   2              up_down_flag=1;//up_down键与模式选择冲突
1744   2      //        dislay_all_flag=1;
1745   2      
1746   2      //        if(SET_Long_Flag==0&&flag_display !=2&&flag_display !=3&&flag_display !=4)
1747   2            if(SET_Long_Flag==0&&flag_display ==0)
1748   2              {
1749   3                dislay_all_flag=1;
1750   3                  mode_select_flag++;
1751   3                if(mode_select_first==1)
1752   3                {
1753   4                  mode_select_flag--;
1754   4                  mode_select_first=0;
1755   4                }
1756   3                if(mode_select_flag>2)mode_select_flag=0;
1757   3                switch (mode_select_flag)
1758   3                {
1759   4                  case 0:
1760   4                    {
1761   5                      
1762   5                      FD612_display_4DIG_input( FD612_DISP_d ,FD612_DISP_P  ,0x40 ,FD612_DISP_1 );
1763   5                      break;
1764   5                    }
1765   4                  case 1:
1766   4                    {
1767   5                        
1768   5                      FD612_display_4DIG_input( FD612_DISP_d ,FD612_DISP_P ,0x40 ,FD612_DISP_2 );
1769   5                      break;
1770   5                    }
1771   4                  case 2:
1772   4                    {
1773   5                      
1774   5                      FD612_display_4DIG_input( FD612_DISP_d ,FD612_DISP_P ,0x40 ,FD612_DISP_3 );
1775   5                      break;
1776   5                    } 
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 30  

1777   4                      default :
1778   4                      break;              
1779   4                }
1780   3                          UP_Short_Flag=0;
1781   3                          up_down_flag=0;
1782   3              }
1783   2      
1784   2              sd_select_first=1;
1785   2                if(back_first)
1786   2                  {
1787   3                    back_TIME_Flag=0;
1788   3                    back_first=0;
1789   3                  }
1790   2          }
1791   1            if(back_first)
1792   1          {
1793   2            back_TIME_Flag=0;
1794   2            back_first=0;
1795   2          }
1796   1      //    if(back_TIME_Flag==over_time ||SET_Short_Flag==1 )
1797   1      //    {
1798   1      //      FD612_DispBuff.DispData[FD612_DIG1_ADDR]=0x00 ; 
1799   1      //      FD612_DispBuff.DispData[FD612_DIG2_ADDR]=0x00 ;
1800   1      //      FD612_DispBuff.DispData[FD612_DIG3_ADDR]=0x00; 
1801   1      //      FD612_DispBuff.DispData[FD612_DIG4_ADDR]=0x00 ;
1802   1      //      FD612_Refresh();
1803   1      
1804   1      //      dislay_all_flag=0;
1805   1      //      back_TIME_Flag=0;
1806   1      //      back_first=1; 
1807   1      //      UP_Short_Flag=0;
1808   1      //      SET_Short_Flag=0;
1809   1      //      mode_select_first=1;
1810   1      //      up_down_flag=1;
1811   1      //    }
1812   1      
1813   1      }
1814          void mode1_select_dislay(void)
1815          {
1816   1          if(mode_select_flag==0)
1817   1          {
1818   2            if(SET_Long_Flag==0)
1819   2            {
1820   3            if(hor_min_delay_time==over_time_2s)
1821   3            {
1822   4              flag_display=5;
1823   4              hor_min_delay_time=0;
1824   4              
1825   4            }
1826   3            if(mon_day_delay_time==over_time_10s)
1827   3            {
1828   4              flag_display=1;
1829   4              mon_day_delay_time=0;
1830   4            }
1831   3            if(temp_delay_time==over_time_2s)
1832   3            {
1833   4              flag_display=0;
1834   4              temp_delay_time=0;
1835   4            } 
1836   3          }
1837   2            
1838   2          }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 31  

1839   1      }
1840          
1841          
1842          
1843          void year_long_up_down(UINT8 i)
1844          {
1845   1      //      ResetDS1302();
1846   1      //      WriteByteDS1302(year_r_addr); //读取分的地址        
1847   1      //      time.year=ReadByteDS1302();
1848   1      //      ResetDS1302();
1849   1            time.year=Read_addr_byte_ds1302(year_r_addr); 
1850   1            time.year = bcd_decimal(time.year);
1851   1            if(i==1)time.year--;
1852   1            if(i==0)
1853   1            {
1854   2              time.year++;
1855   2              if(time.year>99)time.year=0;
1856   2                
1857   2            }
1858   1                     
1859   1            FD612_display_4DIG_input( dis[2] ,dis[0] ,dis[time.year/10] , dis[ time.year% 10]);
1860   1            time.year = decimal_bcd(time.year);
1861   1            Write_addr_byte_ds1302(year_w_addr,time.year);
1862   1      //      ResetDS1302();
1863   1      //      WriteByteDS1302(year_w_addr); //写入时的地址
1864   1      //      WriteByteDS1302(time.year);
1865   1      //      ResetDS1302();  
1866   1            mDelaymS(up_down_delay_time); 
1867   1            time.year = bcd_decimal(time.year);
1868   1      }
1869          
1870          void hour_long_up_down(UINT8 i)
1871          {
1872   1      //        ResetDS1302();              
1873   1      //        WriteByteDS1302(hour_r_addr); //读取时的地址
1874   1      //        time.hour=ReadByteDS1302();
1875   1              time.hour=Read_addr_byte_ds1302(hour_r_addr);       
1876   1              if(hour_12_24_flag==1)
1877   1              {
1878   2                time.hour<<=3;
1879   2                time.hour>>=3;
1880   2      //          time.hour &=~(1<<7);
1881   2      //          time.hour &=~(1<<5);
1882   2              }
1883   1              time.hour = bcd_decimal(time.hour);
1884   1              if(i==0) 
1885   1              {
1886   2                time.hour++;
1887   2                if(hour_12_24_flag){
1888   3                   if(time.hour>=13)
1889   3                   {
1890   4                     time.hour = 1;
1891   4      //               ResetDS1302();             
1892   4      //               WriteByteDS1302(hour_r_addr); //读取时的地址
1893   4      //               hour_chage_state=ReadByteDS1302();
1894   4                    
1895   4                   }
1896   3                   if(time.hour==12)
1897   3                   {
1898   4                     hour_chage_state=Read_addr_byte_ds1302(hour_r_addr); 
1899   4                     if(hour_chage_state&0x20)
1900   4                     {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 32  

1901   5      //                 hour_chage_state &=~(1<<5);
1902   5                       hour_pm_flag=0;
1903   5                     }
1904   4                     else 
1905   4                     {
1906   5      //                 hour_chage_state |=(1<<5);
1907   5                       hour_pm_flag=1;
1908   5                     }               
1909   4                    }
1910   3                  }
1911   2                else
1912   2                {
1913   3                  if(time.hour >=24)
1914   3                  {
1915   4                    time.hour = 0;
1916   4                  } 
1917   3                }
1918   2              
1919   2              }
1920   1              if(i==1)
1921   1              { 
1922   2                  time.hour--;
1923   2                  if(hour_12_24_flag){
1924   3                     if(time.hour>=13||time.hour==0)
1925   3                     {
1926   4                      time.hour = time.hour -244; //溢出值
1927   4      //               ResetDS1302();             
1928   4      //               WriteByteDS1302(hour_r_addr); //读取时的地址
1929   4      //               hour_chage_state=ReadByteDS1302();
1930   4      
1931   4                     }
1932   3                       if(time.hour==11)
1933   3                       {
1934   4                         hour_chage_state=Read_addr_byte_ds1302(hour_r_addr);
1935   4                         if(hour_chage_state&0x20)
1936   4                         {
1937   5      //                     hour_chage_state &=~(1<<5);
1938   5                           hour_pm_flag=0;
1939   5                         }
1940   4                         else 
1941   4                         {
1942   5      //                     hour_chage_state |=(1<<5);
1943   5                           hour_pm_flag=1;
1944   5                         }               
1945   4                      }              
1946   3                    }
1947   2                  else
1948   2                  {
1949   3                    if(time.hour >=24)
1950   3                    {
1951   4                      time.hour = time.hour -232; //溢出值
1952   4                    }
1953   3                  }         
1954   2                
1955   2              }
1956   1              FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10]  ,dis[time.hour% 10] );
1957   1      
1958   1             time.hour = decimal_bcd(time.hour);
1959   1              if(hour_12_24_flag)
1960   1              {
1961   2                time.hour |=1<<7;
1962   2                if(hour_pm_flag)time.hour |=1<<5;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 33  

1963   2                else time.hour &=~(1<<5);
1964   2              }
1965   1              else time.hour &=~(1<<7);
1966   1              Write_addr_byte_ds1302(hour_w_addr,time.hour);
1967   1      //       ResetDS1302();
1968   1      //       WriteByteDS1302(hour_w_addr); //写入时的地址
1969   1      //       WriteByteDS1302(time.hour);
1970   1      //       ResetDS1302();
1971   1             mDelaymS(up_down_delay_time);
1972   1            time.hour = bcd_decimal(time.hour);
1973   1              
1974   1      //            if(hour_12_24_flag==1)
1975   1      //          {
1976   1      //            if(hour_pm_flag==1)
1977   1      //            {
1978   1      ////                FD612_DispBuff.DispData[FD612_DIG5_ADDR]=FD612_DISP_P ;
1979   1      //                FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<1) ;
1980   1      //                FD612_Refresh();    
1981   1      //            }
1982   1      //            else 
1983   1      //            {
1984   1      ////                FD612_DispBuff.DispData[FD612_DIG5_ADDR]=FD612_DISP_A ; 
1985   1      //                FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<1) ;
1986   1      //                FD612_Refresh();    
1987   1      //            }
1988   1      //          }
1989   1      //  
1990   1      }
1991          
1992          void min_long_up_down(UINT8 i) 
1993          {
1994   1      //      ResetDS1302();
1995   1      //      WriteByteDS1302(min_r_addr); //读取分的地址       
1996   1      //      time.minute=ReadByteDS1302();
1997   1      //      ResetDS1302();
1998   1            time.minute=Read_addr_byte_ds1302(min_r_addr);  
1999   1            time.minute = bcd_decimal(time.minute);
2000   1            if(i==0)
2001   1            {
2002   2              time.minute++;
2003   2              if(time.minute >=60)
2004   2              {
2005   3                time.minute = 0;
2006   3              }
2007   2            }
2008   1            if(i==1)
2009   1            {
2010   2            time.minute--;
2011   2            if(time.minute>60)
2012   2            {
2013   3                time.minute = time.minute -196; //溢出值
2014   3            } 
2015   2            }
2016   1      
2017   1            FD612_DISPLAY_2DIG_input(2,dis[time.minute/10] ,dis[ time.minute% 10] );
2018   1            time.minute = decimal_bcd(time.minute);
2019   1      
2020   1              Write_addr_byte_ds1302(min_w_addr,time.minute);
2021   1              Write_addr_byte_ds1302(sec_w_addr,0);
2022   1          
2023   1      //        ResetDS1302();
2024   1      //        WriteByteDS1302(min_w_addr); //写入分的地址
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 34  

2025   1      //        WriteByteDS1302(time.minute);
2026   1      //        ResetDS1302();
2027   1      //        WriteByteDS1302(sec_w_addr); //写入秒的地址
2028   1      //        WriteByteDS1302(0);
2029   1      //        ResetDS1302();
2030   1            time.minute = bcd_decimal(time.minute);
2031   1            mDelaymS(up_down_delay_time);
2032   1      }
2033          void mon_long_up_down(UINT8 i)
2034          {
2035   1      //      ResetDS1302();
2036   1      //      WriteByteDS1302(mon_r_addr); //读取分的地址       
2037   1      //      time.month=ReadByteDS1302();
2038   1      //      ResetDS1302();
2039   1            time.month=Read_addr_byte_ds1302(mon_r_addr);
2040   1            time.month = bcd_decimal(time.month); 
2041   1            if(i==0)
2042   1            {
2043   2              time.month++;
2044   2              if(time.month >=13)
2045   2              {
2046   3                time.month = 1;
2047   3              }
2048   2            }
2049   1            if(i==1)
2050   1            {
2051   2            time.month--;
2052   2            if(time.month==0 || time.month>13)
2053   2            {
2054   3                  time.month = time.month -244; //溢出值
2055   3            } 
2056   2            } 
2057   1        
2058   1            
2059   1            FD612_DISPLAY_2DIG_input(1 ,dis[time.month/10] , dis[time.month% 10]);
2060   1            time.month = decimal_bcd(time.month);
2061   1      
2062   1              Write_addr_byte_ds1302(mon_w_addr,time.month);
2063   1      
2064   1      //      ResetDS1302();
2065   1      //      WriteByteDS1302(mon_w_addr); //写入分的地址
2066   1      //      WriteByteDS1302(time.month);
2067   1      //      ResetDS1302();
2068   1      
2069   1            time.month = bcd_decimal(time.month);     
2070   1            mDelaymS(up_down_delay_time);     
2071   1      }
2072          
2073          void mday_long_up_down(UINT8 i)
2074          {
2075   1      //      ResetDS1302();
2076   1      //      WriteByteDS1302(day_r_addr); //读取分的地址       
2077   1      //      time.mday=ReadByteDS1302();
2078   1      //      ResetDS1302();
2079   1            time.mday=Read_addr_byte_ds1302(day_r_addr);
2080   1            time.mday = bcd_decimal(time.mday);
2081   1            if(i==0)
2082   1            {
2083   2              time.mday++;
2084   2              if(time.mday >31)
2085   2              {
2086   3                time.mday = 1;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 35  

2087   3              }
2088   2            }
2089   1            if(i==1)
2090   1            {
2091   2            time.mday--;
2092   2            if(time.mday==0 || time.mday>31)
2093   2            {
2094   3                  time.mday = time.mday -225; //溢出值
2095   3            } 
2096   2            } 
2097   1      
2098   1              
2099   1              FD612_DISPLAY_2DIG_input(2,dis[time.mday/10] ,dis[time.mday% 10] );
2100   1              time.mday = decimal_bcd(time.mday);
2101   1      
2102   1              Write_addr_byte_ds1302(day_w_addr,time.mday);
2103   1      
2104   1      //        ResetDS1302();
2105   1      //        WriteByteDS1302(day_w_addr); //写入日的地址
2106   1      //        WriteByteDS1302(time.mday);   
2107   1              time.mday = bcd_decimal(time.mday);
2108   1              mDelaymS(up_down_delay_time);     
2109   1      }
2110          void alarm_hour_long_up_down(UINT8 alarm_seclect,UINT8 up_down_seclect,struct DATA_ALARM alarm)
2111          {
2112   1        
2113   1        if(up_down_seclect==1)
2114   1        {
2115   2              if(alarm_seclect==1)
2116   2              {
2117   3                
2118   3                alarm1.hour++;
2119   3                if(hour_12_24_flag){
2120   4                   if(alarm1.hour>=13)
2121   4                   {
2122   5                     alarm1.hour = 1;
2123   5                   }
2124   4                   if(alarm1.hour==1)
2125   4      //            if(alarm1.hour==12)
2126   4                  {
2127   5                    if(alarm1_pm_flag)alarm1_pm_flag=0;
2128   5                    else alarm1_pm_flag=1;            
2129   5                  }
2130   4                  }
2131   3                else
2132   3                {
2133   4                  if(alarm1.hour >=24)
2134   4                  {
2135   5                    alarm1.hour = 0;
2136   5                  } 
2137   4                }
2138   3                alarm_hour_long_up_down_flag=1;
2139   3              }
2140   2              if(alarm_seclect==2)
2141   2              {
2142   3                alarm2.hour++;
2143   3                if(hour_12_24_flag){
2144   4                   if(alarm2.hour>=13)
2145   4                   {
2146   5                     alarm2.hour = 1;
2147   5      
2148   5                   }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 36  

2149   4                  if(alarm2.hour==1)
2150   4                  {
2151   5                    if(alarm2_pm_flag)alarm2_pm_flag=0;
2152   5                    else alarm2_pm_flag=1;            
2153   5                  }            
2154   4                  }
2155   3                else
2156   3                {
2157   4                  if(alarm2.hour >=24)
2158   4                  {
2159   5                    alarm2.hour = 0;
2160   5                  } 
2161   4                }
2162   3                alarm_hour_long_up_down_flag=2;
2163   3              } 
2164   2              if(alarm_seclect==3)
2165   2              {
2166   3                alarm3.hour++;
2167   3                if(hour_12_24_flag){
2168   4                   if(alarm3.hour>=13)
2169   4                   {
2170   5                     alarm3.hour = 1;
2171   5      
2172   5                   }
2173   4                  if(alarm3.hour==1)
2174   4                  {
2175   5                    if(alarm3_pm_flag)alarm3_pm_flag=0;
2176   5                    else alarm3_pm_flag=1;            
2177   5                  }              
2178   4                  }
2179   3                else
2180   3                {
2181   4                  if(alarm3.hour >=24)
2182   4                  {
2183   5                    alarm3.hour = 0;
2184   5                  } 
2185   4                }
2186   3                alarm_hour_long_up_down_flag=3;
2187   3              }
2188   2          }
2189   1          if(up_down_seclect==2)
2190   1          {
2191   2            if(alarm_seclect==1)
2192   2            {
2193   3              alarm1.hour--;          
2194   3              if(hour_12_24_flag){
2195   4                 if(alarm1.hour>=13||alarm1.hour==0)
2196   4                 {
2197   5                    alarm1.hour = alarm1.hour -244; //溢出值
2198   5                  
2199   5                 }
2200   4                  if(alarm1.hour==10)
2201   4                  {
2202   5                    if(alarm1_pm_flag)alarm1_pm_flag=0;
2203   5                    else alarm1_pm_flag=1;            
2204   5                  } 
2205   4                }
2206   3              else
2207   3              {
2208   4                if(alarm1.hour >=24)
2209   4                {
2210   5                  alarm1.hour = alarm1.hour -232; //溢出值
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 37  

2211   5                }
2212   4              } 
2213   3            alarm_hour_long_up_down_flag=4;
2214   3            }
2215   2            if(alarm_seclect==2)
2216   2            {
2217   3              alarm2.hour--;          
2218   3              if(hour_12_24_flag){
2219   4                 if(alarm2.hour>=13||alarm2.hour==0)
2220   4                 {
2221   5                    alarm2.hour = alarm2.hour -244; //溢出值
2222   5      
2223   5                 }
2224   4                    if(alarm2.hour==10)
2225   4                  {
2226   5                    if(alarm2_pm_flag)alarm2_pm_flag=0;
2227   5                    else alarm2_pm_flag=1;            
2228   5                  } 
2229   4                }
2230   3              else
2231   3              {
2232   4                if(alarm2.hour >=24)
2233   4                {
2234   5                  alarm2.hour = alarm2.hour -232; //溢出值
2235   5                }
2236   4              } 
2237   3      
2238   3            alarm_hour_long_up_down_flag=5;
2239   3            }
2240   2            if(alarm_seclect==3)
2241   2            {
2242   3              alarm3.hour--;          
2243   3              if(hour_12_24_flag){
2244   4                 if(alarm3.hour>=13||alarm3.hour==0)
2245   4                 {
2246   5                    alarm3.hour = alarm3.hour -244; //溢出值
2247   5                 }
2248   4                  if(alarm3.hour==10)
2249   4                  {
2250   5                    if(alarm3_pm_flag)alarm3_pm_flag=0;
2251   5                    else alarm3_pm_flag=1;            
2252   5                  } 
2253   4                }
2254   3              else
2255   3              {
2256   4                if(alarm3.hour >=24)
2257   4                {
2258   5                  alarm3.hour = alarm3.hour -232; //溢出值
2259   5                }
2260   4              } 
2261   3            alarm_hour_long_up_down_flag=6;
2262   3            }   
2263   2          }
2264   1      
2265   1                
2266   1              FD612_DISPLAY_2DIG_input(1 , dis[alarm.hour/10],dis[alarm.hour%10] );
2267   1              mDelaymS(up_down_delay_time);
2268   1              
2269   1      }
2270          
2271          
2272          void alarm_min_long_up_down(UINT8 alarm_seclect,UINT8 up_down_seclect,struct DATA_ALARM alarm)
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 38  

2273          {
2274   1        if(up_down_seclect==1)
2275   1        {
2276   2              if(alarm_seclect==1)
2277   2              {
2278   3                alarm1.minute++;
2279   3              if(alarm1.minute >=60)
2280   3              {
2281   4                alarm1.minute = 0;
2282   4              }
2283   3              alarm_min_long_up_down_flag=1;
2284   3              }
2285   2              if(alarm_seclect==2)
2286   2              {
2287   3                alarm2.minute++;
2288   3              if(alarm2.minute >=60)
2289   3              {
2290   4                alarm2.minute = 0;
2291   4              }
2292   3              alarm_min_long_up_down_flag=2;        
2293   3              }
2294   2              if(alarm_seclect==3)
2295   2              {
2296   3                alarm3.minute++;
2297   3              if(alarm3.minute >=60)
2298   3              {
2299   4                alarm3.minute = 0;
2300   4              }
2301   3              alarm_min_long_up_down_flag=3;        
2302   3              } 
2303   2          }
2304   1          if(up_down_seclect==2)
2305   1          {
2306   2              if(alarm_seclect==1)
2307   2              {
2308   3                alarm1.minute--;
2309   3              if(alarm1.minute>60)
2310   3              {
2311   4                  alarm1.minute = alarm1.minute -196; //溢出值
2312   4              }
2313   3              alarm_min_long_up_down_flag=4;        
2314   3              }
2315   2              if(alarm_seclect==2)
2316   2              {
2317   3                alarm2.minute--;
2318   3              if(alarm2.minute>60)
2319   3              {
2320   4                  alarm2.minute = alarm2.minute -196; //溢出值
2321   4              }
2322   3              alarm_min_long_up_down_flag=5;        
2323   3              }
2324   2              if(alarm_seclect==3)
2325   2              {
2326   3                alarm3.minute--;
2327   3              if(alarm3.minute>60)
2328   3              {
2329   4                  alarm3.minute = alarm3.minute -196; //溢出值
2330   4              }
2331   3              alarm_min_long_up_down_flag=6;        
2332   3              }     
2333   2          }
2334   1      
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 39  

2335   1              
2336   1              FD612_DISPLAY_2DIG_input(2,dis[alarm.minute/10]  ,dis[alarm.minute%10] );
2337   1              mDelaymS(up_down_delay_time);
2338   1              
2339   1      }
2340          
2341          void alarm_set_display(UINT8 i,struct DATA_ALARM alarm)
2342          {
2343   1                    if(SET_Long_Flag)
2344   1                  {
2345   2                      if(key_first)
2346   2                      {
2347   3                        key_first=0;
2348   3                        UP_Short_Flag=0;
2349   3                        DOWN_Short_Flag = 0;
2350   3                      }
2351   2      
2352   2                    if(i==1)alarm1_on_dispaly=1;
2353   2                    if(i==2)alarm2_on_dispaly=1;
2354   2                    if(i==3)alarm3_on_dispaly=1;  
2355   2                    if(SET_Short_Flag)
2356   2                      {
2357   3                        SET_Short_Flag_alarm1_flag++;
2358   3                        SET_Short_Flag=0;
2359   3                        if(SET_Short_Flag_alarm1_flag>3)
2360   3                        {
2361   4                          SET_Short_Flag_alarm1_flag=0;
2362   4                        }
2363   3                      }
2364   2                if(SET_Short_Flag_alarm1_flag==0)
2365   2                  {
2366   3      
2367   3                if(time1_second)
2368   3                {
2369   4                if(blink_flag)
2370   4                  {
2371   5                    blink_flag=0;
2372   5                    FD612_DISPLAY_2DIG_input(1 ,dis[alarm.hour/10] ,dis[alarm.hour%10] );
2373   5                  }
2374   4                  else
2375   4                  {
2376   5                    blink_flag=1;
2377   5                    FD612_DISPLAY_2DIG_input(1 ,0x00 , 0x00);
2378   5                  }
2379   4                  time1_second=0;
2380   4                }
2381   3                  
2382   3                  FD612_DISPLAY_2DIG_input(2,dis[alarm.minute/10] ,dis[alarm.minute%10] );
2383   3                      if(UP_Short_Flag==1)
2384   3                      {
2385   4                        if(i==1)
2386   4                        {
2387   5                          alarm1.hour++;
2388   5                          if(hour_12_24_flag){
2389   6                             if(alarm1.hour>=13)
2390   6                             {
2391   7                               alarm1.hour = 1;
2392   7      
2393   7                             }
2394   6                             if(alarm1.hour==12)
2395   6                             {
2396   7                               if(alarm1_pm_flag)alarm1_pm_flag=0;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 40  

2397   7                               else alarm1_pm_flag=1;
2398   7                              }
2399   6                            }
2400   5                          else
2401   5                          {
2402   6                            if(alarm1.hour >=24)
2403   6                            {
2404   7                              alarm1.hour = 0;
2405   7                            } 
2406   6                          }
2407   5                        }
2408   4                        if(i==2)
2409   4                        {
2410   5                          alarm2.hour++;
2411   5                          if(hour_12_24_flag){
2412   6                             if(alarm2.hour>=13)
2413   6                             {
2414   7                               alarm2.hour = 1;
2415   7      
2416   7                             }
2417   6                           if(alarm2.hour==12)
2418   6                             {
2419   7                               if(alarm2_pm_flag)alarm2_pm_flag=0;
2420   7                               else alarm2_pm_flag=1;
2421   7                              }                      
2422   6                            }
2423   5                          else
2424   5                          {
2425   6                            if(alarm2.hour >=24)
2426   6                            {
2427   7                              alarm2.hour = 0;
2428   7                            } 
2429   6                          }
2430   5                        } 
2431   4                        if(i==3)
2432   4                        {
2433   5                          alarm3.hour++;
2434   5                          if(hour_12_24_flag){
2435   6                             if(alarm3.hour>=13)
2436   6                             {
2437   7                               alarm3.hour = 1;
2438   7                             }
2439   6                           if(alarm3.hour==12)
2440   6                             {
2441   7                               if(alarm3_pm_flag)alarm3_pm_flag=0;
2442   7                               else alarm3_pm_flag=1;
2443   7                              }                      
2444   6                            }
2445   5                          else
2446   5                          {
2447   6                            if(alarm3.hour >=24)
2448   6                            {
2449   7                              alarm3.hour = 0;
2450   7                            } 
2451   6                          }
2452   5                        }                 
2453   4                          UP_Short_Flag=0;
2454   4                      }
2455   3                        if(DOWN_Short_Flag == 1)
2456   3                      {
2457   4                        if(i==1)
2458   4                        {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 41  

2459   5                          alarm1.hour--;          
2460   5                          if(hour_12_24_flag){
2461   6                             if(alarm1.hour>=13||alarm1.hour==0)
2462   6                             {
2463   7                                alarm1.hour = alarm1.hour -244; //溢出值
2464   7                             }
2465   6                            if(alarm1.hour==11)
2466   6                             {
2467   7                               if(alarm1_pm_flag)alarm1_pm_flag=0;
2468   7                               else alarm1_pm_flag=1;
2469   7                              }                      
2470   6                            }
2471   5                          else
2472   5                          {
2473   6                            if(alarm1.hour >=24)
2474   6                            {
2475   7                              alarm1.hour = alarm1.hour -232; //溢出值
2476   7                            }
2477   6                          }
2478   5                        }
2479   4                        if(i==2)
2480   4                        {
2481   5                          alarm2.hour--;          
2482   5                          if(hour_12_24_flag){
2483   6                             if(alarm2.hour>=13||alarm2.hour==0)
2484   6                             {
2485   7                                alarm2.hour = alarm2.hour -244; //溢出值
2486   7                             }
2487   6                             if(alarm2.hour==11)
2488   6                             {
2489   7                               if(alarm2_pm_flag)alarm2_pm_flag=0;
2490   7                               else alarm2_pm_flag=1;
2491   7                              }                    
2492   6                            }
2493   5                          else
2494   5                          {
2495   6                            if(alarm2.hour >=24)
2496   6                            {
2497   7                              alarm2.hour = alarm2.hour -232; //溢出值
2498   7                            }
2499   6                          }
2500   5                        }
2501   4                        if(i==3)
2502   4                        {
2503   5                          alarm3.hour--;          
2504   5                          if(hour_12_24_flag){
2505   6                             if(alarm3.hour>=13||alarm3.hour==0)
2506   6                             {
2507   7                                alarm3.hour = alarm3.hour -244; //溢出值
2508   7                             }
2509   6                            if(alarm2.hour==11)
2510   6                             {
2511   7                               if(alarm2_pm_flag)alarm2_pm_flag=0;
2512   7                               else alarm2_pm_flag=1;
2513   7                              }                      
2514   6                            }
2515   5                          else
2516   5                          {
2517   6                            if(alarm3.hour >=24)
2518   6                            {
2519   7                              alarm3.hour = alarm3.hour -232; //溢出值
2520   7                            }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 42  

2521   6                          }
2522   5                        }                 
2523   4                          DOWN_Short_Flag = 0;
2524   4                      }           
2525   3                  }
2526   2                if(SET_Short_Flag_alarm1_flag==1)
2527   2                {
2528   3      
2529   3                  if(time1_second)
2530   3                  {
2531   4                  if(blink_flag)
2532   4                    {
2533   5                      blink_flag=0; 
2534   5                      FD612_DISPLAY_2DIG_input(2,dis[alarm.minute/10] ,dis[alarm.minute%10] );
2535   5                    }
2536   4                    else
2537   4                    {
2538   5                      blink_flag=1;
2539   5                      FD612_DISPLAY_2DIG_input(2,0x00 ,0x00 );  
2540   5                    }
2541   4                    time1_second=0;
2542   4                  }
2543   3                    
2544   3                    FD612_DISPLAY_2DIG_input(1 ,dis[alarm.hour/10] ,dis[alarm.hour%10] );
2545   3                      
2546   3                    if(UP_Short_Flag == 1)
2547   3                    {
2548   4                      if(i==1)
2549   4                      {
2550   5                        alarm1.minute++;
2551   5                      if(alarm1.minute >=60)
2552   5                      {
2553   6                        alarm1.minute = 0;
2554   6                      }
2555   5                      }
2556   4                      if(i==2)
2557   4                      {
2558   5                        alarm2.minute++;
2559   5                      if(alarm2.minute >=60)
2560   5                      {
2561   6                        alarm2.minute = 0;
2562   6                      }
2563   5                      }
2564   4                      if(i==3)
2565   4                      {
2566   5                        alarm3.minute++;
2567   5                      if(alarm3.minute >=60)
2568   5                      {
2569   6                        alarm3.minute = 0;
2570   6                      }
2571   5                      }               
2572   4                        UP_Short_Flag = 0;
2573   4                    }
2574   3                    if(DOWN_Short_Flag == 1)
2575   3                    {
2576   4                      if(i==1)
2577   4                      {
2578   5                        alarm1.minute--;
2579   5                      if(alarm1.minute>60)
2580   5                      {
2581   6                          alarm1.minute = alarm1.minute -196; //溢出值
2582   6                      }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 43  

2583   5                      }
2584   4                      if(i==2)
2585   4                      {
2586   5                        alarm2.minute--;
2587   5                      if(alarm2.minute>60)
2588   5                      {
2589   6                          alarm2.minute = alarm2.minute -196; //溢出值
2590   6                      }
2591   5                      }
2592   4                      if(i==3)
2593   4                      {
2594   5                        alarm3.minute--;
2595   5                      if(alarm3.minute>60)
2596   5                      {
2597   6                          alarm3.minute = alarm3.minute -196; //溢出值
2598   6                      }
2599   5                      }               
2600   4                        DOWN_Short_Flag = 0;
2601   4                    }
2602   3                } 
2603   2                if(SET_Short_Flag_alarm1_flag==2) 
2604   2                {
2605   3                        if(i==1)alarm1_on_dispaly=1;
2606   3                        if(i==2)alarm2_on_dispaly=1;
2607   3                        if(i==3)alarm3_on_dispaly=1;
2608   3                        SET_Long_Flag=0;
2609   3                        SET_Short_Flag_alarm1_flag=0;
2610   3                        key_first=1;
2611   3                
2612   3                }
2613   2                    if(back_first)
2614   2                      {
2615   3                        back_TIME_Flag=0;
2616   3                        back_first=0;
2617   3                      }
2618   2                    if(back_TIME_Flag==over_time)
2619   2                      {
2620   3                        if(i==1)alarm1_on_dispaly=1;
2621   3                        if(i==2)alarm2_on_dispaly=1;
2622   3                        if(i==3)alarm3_on_dispaly=1;
2623   3                        SET_Long_Flag=0;
2624   3                        SET_Short_Flag_alarm1_flag=0;
2625   3                        back_TIME_Flag=0;
2626   3                        back_first=1;
2627   3                        dp_mode_exit( );  
2628   3                        //flag_display=0;
2629   3                        key_first=1;
2630   3      
2631   3                      } 
2632   2                  }
2633   1                  if(i==1)
2634   1                  {
2635   2                  if(alarm1_on_dispaly==0)
2636   2                  {
2637   3                
2638   3                    FD612_display_4DIG_input( 0x40 ,0x40 ,FD612_DISP_A ,FD612_DISP_1 );
2639   3                      if(UP_Short_Flag==1)
2640   3                      {
2641   4                        alarm1_on_dispaly=1;
2642   4                        UP_Short_Flag=0;
2643   4                      }             
2644   3                  }
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 44  

2645   2      
2646   2                  if(SET_Long_Flag==0)
2647   2                  {
2648   3                  if(alarm1_on_dispaly)
2649   3                    {
2650   4                        
2651   4                      FD612_display_4DIG_input( 0x5c ,0x54 ,FD612_DISP_A ,FD612_DISP_1 );
2652   4                      if(UP_Short_Flag==1)
2653   4                      {
2654   5                        alarm1_on_dispaly=0;
2655   5                        UP_Short_Flag=0;
2656   5                      }
2657   4                    }
2658   3                  }
2659   2                  }
2660   1                  if(i==2)
2661   1                  {
2662   2                  if(alarm2_on_dispaly==0)
2663   2                  {
2664   3                  
2665   3                  FD612_display_4DIG_input( 0x40 , 0x40,FD612_DISP_A ,FD612_DISP_2 );
2666   3                  if(UP_Short_Flag==1)
2667   3                  {
2668   4                    alarm2_on_dispaly=1;
2669   4                    UP_Short_Flag=0;
2670   4                  }             
2671   3                  }
2672   2      
2673   2                  if(SET_Long_Flag==0)
2674   2                  {
2675   3                  if(alarm2_on_dispaly)
2676   3                    {
2677   4                      
2678   4                      FD612_display_4DIG_input(  0x5c,0x54,FD612_DISP_A ,FD612_DISP_2 );
2679   4                      if(UP_Short_Flag==1)
2680   4                      {
2681   5                        alarm2_on_dispaly=0;
2682   5                        UP_Short_Flag=0;
2683   5                      }
2684   4                    }
2685   3                  }             
2686   2                  }
2687   1                  if(i==3)
2688   1                  {
2689   2                  if(alarm3_on_dispaly==0)
2690   2                  {
2691   3                  
2692   3                    FD612_display_4DIG_input( 0x40 ,0x40 ,FD612_DISP_A ,FD612_DISP_3 );
2693   3                  if(UP_Short_Flag==1)
2694   3                  {
2695   4                    alarm3_on_dispaly=1;
2696   4                    UP_Short_Flag=0;
2697   4                  }             
2698   3                  }
2699   2      
2700   2                  if(SET_Long_Flag==0)
2701   2                  {
2702   3                  if(alarm3_on_dispaly)
2703   3                    {
2704   4                        
2705   4                      FD612_display_4DIG_input( 0x5c , 0x54,FD612_DISP_A ,FD612_DISP_3 );
2706   4                      if(UP_Short_Flag==1)
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 45  

2707   4                      {
2708   5                        alarm3_on_dispaly=0;
2709   5                        UP_Short_Flag=0;
2710   5                      }
2711   4                    }
2712   3                  }             
2713   2                  }
2714   1                  if(SET_Long_Flag==0)
2715   1                  {
2716   2                  if(back_first)
2717   2                      {
2718   3                        back_TIME_Flag=0;
2719   3                        back_first=0;
2720   3                      }
2721   2                      if(back_TIME_Flag==over_time)
2722   2                      {
2723   3                      //  alarm1_on_dispaly=1;  
2724   3      //                  SET_Long_Flag=0;
2725   3      //                  SET_Short_Flag_alarm1_flag=0;
2726   3                        back_TIME_Flag=0;
2727   3                        back_first=1;
2728   3                        if(mode_select_flag==2) flag_display=0;
2729   3                        dp_mode_exit()  ;               
2730   3                      } 
2731   2                  }
2732   1      }
2733          
2734          void alarm_hour_display(struct DATA_ALARM alarm)
2735          {
2736   1      
2737   1                
2738   1              FD612_DISPLAY_2DIG_input(1 ,dis[alarm.hour/10] ,dis[alarm.hour%10] );
2739   1      }
2740          
2741          void alarm_min_display(struct DATA_ALARM alarm)
2742          {
2743   1      
2744   1                
2745   1              FD612_DISPLAY_2DIG_input(2,dis[alarm.minute/10] ,dis[alarm.minute%10] );
2746   1      }
2747          
2748          void alarm_long_blink(struct DATA_ALARM alarm)//闹钟长按闪烁
2749          {
2750   1          if(time1_second==1)
2751   1        {
2752   2      
2753   2          if(blink_flag)
2754   2          {
2755   3            blink_flag=0;
2756   3            FD612_DISPLAY_2DIG_input(1 ,dis[alarm.hour/10],dis[alarm.hour%10]);
2757   3          }
2758   2          else
2759   2          {
2760   3            blink_flag=1;
2761   3            FD612_DISPLAY_2DIG_input(1 ,0x00,0x00); 
2762   3          }
2763   2      
2764   2          FD612_DISPLAY_2DIG_input(2 ,dis[alarm.minute/10],dis[alarm.minute%10]);
2765   2          time1_second=0;
2766   2        }
2767   1      }
2768          
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 46  

2769          void dp_mode_exit(void)
2770          {
2771   1          if(mode_select_flag==0){
2772   2            flag_display=0;
2773   2      //      temp_delay_time=0;
2774   2            mon_day_delay_time=0;
2775   2            hor_min_delay_time=0;
2776   2          }                                     
2777   1          
2778   1      }
2779          
2780          void key_dislpay_up_down(void)
2781          {
2782   1            if(long_add_flag==0)
2783   1            {
2784   2              switch(flag_display)
2785   2            {
2786   3              case 0:
2787   3              {
2788   4                if(SET_Short_Flag_hur_min==1 )
2789   4                {
2790   5      
2791   5                  
2792   5                  FD612_DISPLAY_2DIG_input(1 ,dis[time.hour/10]  ,dis[time.hour% 10]);
2793   5                }
2794   4                if(SET_Short_Flag_hur_min==2 )
2795   4                {
2796   5      
2797   5                
2798   5                  FD612_DISPLAY_2DIG_input(2,dis[time.minute/10] ,dis[time.minute% 10] );
2799   5                } 
2800   4                break;          
2801   4              }
2802   3              case 1:
2803   3              {
2804   4                if(SET_Short_Flag_mon_day==0 )
2805   4                {
2806   5                    
2807   5                  FD612_display_4DIG_input( dis[2] ,dis[0] ,dis[time.year/10] ,dis[time.year%10] );
2808   5                }
2809   4                if(SET_Short_Flag_mon_day==1&&long_add_flag==0 )
2810   4                {
2811   5      
2812   5                
2813   5                FD612_DISPLAY_2DIG_input(1 ,dis[time.month/10] ,dis[time.month% 10] );  
2814   5                }
2815   4                if(SET_Short_Flag_mon_day==2 )
2816   4                {
2817   5        
2818   5                  
2819   5                  FD612_DISPLAY_2DIG_input(2,dis[time.mday/10] ,dis[time.mday% 10] );
2820   5                }
2821   4                break;          
2822   4              }
2823   3              case 2:
2824   3              {
2825   4                if(SET_Short_Flag_alarm1_flag==0 )
2826   4                {
2827   5                 alarm_hour_display(alarm1);
2828   5                
2829   5                }
2830   4                if(SET_Short_Flag_alarm1_flag==1 )
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 47  

2831   4                {
2832   5                  alarm_min_display(alarm1) ;     
2833   5                } 
2834   4                break;
2835   4              }
2836   3              case 3:
2837   3              {
2838   4                if(SET_Short_Flag_alarm1_flag==0 )
2839   4                {
2840   5                  alarm_hour_display( alarm2);        
2841   5                } 
2842   4                if(SET_Short_Flag_alarm1_flag==1 )
2843   4                {
2844   5                  alarm_min_display(alarm2) ;
2845   5                }
2846   4                break;
2847   4              }
2848   3              case 4:
2849   3              {
2850   4                  if(SET_Short_Flag_alarm1_flag==0 )
2851   4                  {
2852   5                    alarm_hour_display(alarm3);       
2853   5                  } 
2854   4                  if(SET_Short_Flag_alarm1_flag==1 )
2855   4                  {
2856   5                    alarm_min_display(alarm3) ;
2857   5                  } 
2858   4                break;
2859   4              }       
2860   3            }
2861   2          }
2862   1      }
2863          
2864          
2865          
2866          void FD612_display_4DIG_input(UINT8 dig1,UINT8 dig2,UINT8 dig3,UINT8 dig4)
2867          {
2868   1      //      FD612_DispBuff.DispData[FD612_DIG1_ADDR]=dig1 ; 
2869   1      //      FD612_DispBuff.DispData[FD612_DIG2_ADDR]=dig2;
2870   1      //      FD612_DispBuff.DispData[FD612_DIG3_ADDR]=dig3 ; 
2871   1      //      FD612_DispBuff.DispData[FD612_DIG4_ADDR]=dig4 ;
2872   1            FD612_PotiveTNage(FD612_DIG1_ADDR,dig1);
2873   1            FD612_PotiveTNage(FD612_DIG2_ADDR,dig2);
2874   1            FD612_PotiveTNage(FD612_DIG3_ADDR,dig3);
2875   1            FD612_PotiveTNage(FD612_DIG4_ADDR,dig4);
2876   1            pm_12_24_alarm_display();
2877   1            FD612_Refresh();  
2878   1      }
2879          void FD612_DISPLAY_2DIG_input(UINT8 i ,UINT8 dig1,UINT8 dig2)
2880          {
2881   1          if(i==1)
2882   1          {
2883   2            FD612_PotiveTNage(FD612_DIG1_ADDR,dig1);
2884   2            FD612_PotiveTNage(FD612_DIG2_ADDR,dig2);
2885   2            pm_12_24_alarm_display();
2886   2      //      FD612_Refresh();
2887   2          }
2888   1          if(i==2)
2889   1          {
2890   2            FD612_PotiveTNage(FD612_DIG3_ADDR,dig1);
2891   2            FD612_PotiveTNage(FD612_DIG4_ADDR,dig2);
2892   2            pm_12_24_alarm_display();
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 48  

2893   2      //      FD612_Refresh();
2894   2          }
2895   1      }
2896          void  pm_12_24_alarm_display(void)
2897          {
2898   1                if(hour_12_24_flag==1)
2899   1                {
2900   2      //            FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2901   2                
2902   2                  if(hour_pm_flag==1)
2903   2                  {
2904   3                      
2905   3                      FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2906   3                  
2907   3                  }
2908   2                  else 
2909   2                  {
2910   3                    
2911   3                      FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2912   3                  
2913   3                  }
2914   2                  if(SET_Long_Flag==1)
2915   2                  {
2916   3                    if(alarm1_pm_flag==1&&flag_display==2 )
2917   3                    {
2918   4      
2919   4                        FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2920   4                      
2921   4                    }
2922   3                    if(alarm1_pm_flag==0&&flag_display==2)
2923   3                    {
2924   4                        FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2925   4                                  
2926   4                    }       
2927   3      
2928   3      
2929   3                    if(alarm2_pm_flag==1&&flag_display==3)
2930   3                    {
2931   4      
2932   4                        FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2933   4                      
2934   4                    }
2935   3                     if(alarm2_pm_flag==0&&flag_display==3)
2936   3                    {
2937   4                          FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2938   4                                  
2939   4                    } 
2940   3      
2941   3                    
2942   3                    if(alarm3_pm_flag==1&&flag_display==4)
2943   3                    {
2944   4      
2945   4                        FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2946   4                      
2947   4                    } 
2948   3                    if(alarm3_pm_flag==0&&flag_display==4)
2949   3                    {
2950   4                      FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2951   4                                  
2952   4                    } 
2953   3                    if(flag_display==0)
2954   3                    {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 49  

2955   4                        if(SET_Short_Flag_hur_min==1||SET_Short_Flag_hur_min==2)FD612_DispBuff.DispData[FD612_DIG12_ADDR]
             - |=(1<<1) ;
2956   4                    }
2957   3                     if(flag_display==2||flag_display==3||flag_display==4)
2958   3                    {
2959   4                        if(SET_Short_Flag_alarm1_flag==0||SET_Short_Flag_alarm1_flag==1)FD612_DispBuff.DispData[FD612_DIG
             -12_ADDR] |=(1<<1) ;
2960   4                    }
2961   3                    
2962   3                  }
2963   2      //           if(SET_Long_Flag==1&&(flag_display==2||flag_display==3||flag_display==4))
2964   2      //          {
2965   2      //                FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<1) ;
2966   2      //                        
2967   2      //          }           
2968   2                  if(SET_Long_Flag==0&&(flag_display==0||flag_display==1||flag_display==5)&&(hour_pm_flag==1))
2969   2                  {
2970   3                      FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
2971   3                  
2972   3                  }
2973   2              
2974   2                }
2975   1                else
2976   1                {
2977   2      
2978   2      //                FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;
2979   2                  //    FD612_Refresh();
2980   2                }
2981   1                if(alarm1_on_dispaly ||alarm2_on_dispaly ||alarm3_on_dispaly)
2982   1                {
2983   2                  FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<3) ;
2984   2                }
2985   1                else
2986   1                {
2987   2                  FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<3) ;
2988   2                }
2989   1      //          if()
2990   1                FD612_Refresh();
2991   1      }
2992          
2993          
2994          
2995          void after_arrive_write_1302(void)
2996          {
2997   1      //       if(time.hour==12)
2998   1      //     {
2999   1              hour_chage_state=Read_addr_byte_ds1302(hour_r_addr);
3000   1      //      ResetDS1302();              
3001   1      //       WriteByteDS1302(hour_r_addr); //读取时的地址
3002   1      //       hour_chage_state=ReadByteDS1302();
3003   1             if(hour_chage_state&0x20)
3004   1             {
3005   2               hour_chage_state &=~(1<<5);
3006   2               hour_pm_flag=0;
3007   2             }
3008   1             else 
3009   1             {
3010   2               hour_chage_state |=(1<<5);
3011   2               hour_pm_flag=1;
3012   2             }
3013   1            Write_addr_byte_ds1302(hour_w_addr,hour_chage_state);
3014   1      //       ResetDS1302();
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 50  

3015   1      //       WriteByteDS1302(hour_w_addr); //写入时的地址
3016   1      //       WriteByteDS1302(hour_chage_state);                          
3017   1      //      }
3018   1      }
3019          
3020            void hour_chage_input(UINT8 i)
3021            {//24小时转12小时
3022   1          
3023   1          UINT8 hour_state_value;
3024   1          hour_state_value=Read_addr_byte_ds1302(hour_r_addr);
3025   1      //    ResetDS1302();              
3026   1      //    WriteByteDS1302(hour_r_addr); //读取时的地址
3027   1      //    hour_state_value=ReadByteDS1302();
3028   1          if(i==1)    
3029   1          {
3030   2      //      hour_state_value<<=3;
3031   2      //      hour_state_value>>=3;
3032   2                  
3033   2            hour_state_value = bcd_decimal(hour_state_value);       
3034   2          if(hour_state_value>12)
3035   2          {
3036   3            hour_state_value=hour_state_value-12;
3037   3            hour_state_value=decimal_bcd(hour_state_value);
3038   3            hour_state_value |=(1<<5);
3039   3            hour_state_value |= (1<<7);
3040   3            hour_pm_flag=1;
3041   3          }
3042   2          else if(hour_state_value==12)
3043   2          {
3044   3           hour_pm_flag=1;
3045   3            hour_state_value=decimal_bcd(hour_state_value);
3046   3            hour_state_value |=(1<<5);
3047   3            hour_state_value |= (1<<7);
3048   3          }
3049   2            else if(hour_state_value<12)
3050   2            {
3051   3            hour_state_value=decimal_bcd(hour_state_value);
3052   3            hour_state_value |= (1<<7);
3053   3            }
3054   2      //    if(hour_chage_state==12)
3055   2      //    {
3056   2      //     hour_pm_flag=1;
3057   2      //    hour_chage_state |=(1<<5);
3058   2      //    }
3059   2      //    hour_chage_state=decimal_bcd(hour_chage_state);
3060   2              
3061   2          }
3062   1          if(i==0)    
3063   1          {
3064   2            //12小时转24小时
3065   2            if(hour_state_value&0x20)
3066   2            {
3067   3              hour_state_value&=~(1<<7);
3068   3              hour_state_value &=~(1<<5);       
3069   3              hour_pm_flag=0;
3070   3              hour_state_value = bcd_decimal(hour_state_value);   
3071   3              if(hour_state_value!=12)
3072   3              hour_state_value=hour_state_value+12;
3073   3              hour_state_value=decimal_bcd(hour_state_value);
3074   3            }
3075   2            else
3076   2            {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 51  

3077   3            hour_state_value&=~(1<<7);  
3078   3            hour_state_value = bcd_decimal(hour_state_value);
3079   3            if(hour_state_value==12)hour_state_value=0;
3080   3            hour_state_value=decimal_bcd(hour_state_value);
3081   3            
3082   3            }
3083   2            
3084   2            
3085   2          }
3086   1          Write_addr_byte_ds1302(hour_w_addr,hour_state_value);
3087   1      //    ResetDS1302();
3088   1      //    WriteByteDS1302(hour_w_addr); //写入时的地址
3089   1      //    WriteByteDS1302(hour_state_value);  
3090   1        }
3091            
3092            void temper_display(void)
3093            {
3094   1                
3095   1          if(ADC_TIME_Flag==temp_refresh_time)
3096   1          {
3097   2            ADC_Convert( );
3098   2            ADC_TIME_Flag=0;
3099   2          }
3100   1            adc_switch( );
3101   1      //    if(ADC_Display1==0)
3102   1      //    {     
3103   1      ////    FD612_display_4DIG_input( 0x00 ,dis[(unsigned char)TEM2/10] ,dis[(unsigned char)TEM2%10] ,FD612_DISP
             -_C );
3104   1      //      FD612_PotiveTNage(FD612_DIG1_ADDR,0x00);
3105   1      //      FD612_PotiveTNage(FD612_DIG2_ADDR,dis[(unsigned char)TEM2/10]);
3106   1      //      FD612_PotiveTNage(FD612_DIG3_ADDR,dis[(unsigned char)TEM2%10]);
3107   1      //      FD612_PotiveTNage(FD612_DIG4_ADDR,FD612_DISP_cc);
3108   1      //      FD612_DispBuff.DispData[FD612_DIG12_ADDR]|= 1<<6 ; 
3109   1      //      FD612_Refresh();
3110   1      //    }
3111   1      //    else
3112   1      //    {
3113   1      //    ADC_AVG_NUM[2]   = (unsigned char)TEM4/100;
3114   1      //    ADC_AVG_NUM[1]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )/10;
3115   1      //    ADC_AVG_NUM[0]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )%10;
3116   1      
3117   1      ////    FD612_display_4DIG_input(dis[ADC_AVG_NUM[2]]  , dis[ADC_AVG_NUM[1]],dis[ADC_AVG_NUM[0]]  ,FD612_DISP
             -_F );
3118   1      //      FD612_PotiveTNage(FD612_DIG1_ADDR,dis[ADC_AVG_NUM[2]]);
3119   1      //      FD612_PotiveTNage(FD612_DIG2_ADDR,dis[ADC_AVG_NUM[1]]);
3120   1      //      FD612_PotiveTNage(FD612_DIG3_ADDR,dis[ADC_AVG_NUM[0]] );
3121   1      //      FD612_PotiveTNage(FD612_DIG4_ADDR,FD612_DISP_F );
3122   1      
3123   1      //      FD612_Refresh();
3124   1      //      
3125   1      //    } 
3126   1        }
3127            
3128          void display_12_24_blink(void)
3129          {
3130   1            if(time1_second==1)
3131   1          {
3132   2          if(blink_flag)          
3133   2            {
3134   3              blink_flag=0;
3135   3              if(hour_12_24_flag)
3136   3              {
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 52  

3137   4              FD612_DISPLAY_2DIG_input(1 ,dis[1],dis[2]);
3138   4              }
3139   3              else
3140   3              {
3141   4              FD612_DISPLAY_2DIG_input(1 ,dis[2],dis[4]);
3142   4              }
3143   3      
3144   3              FD612_DISPLAY_2DIG_input(2,FD612_DISP_H ,FD612_DISP_);  
3145   3            }
3146   2            else
3147   2            {
3148   3              blink_flag=1;
3149   3              FD612_display_4DIG_input(0x00,0x00,0x00,0x00);
3150   3            }
3151   2            time1_second=0;
3152   2          } 
3153   1      }
3154          
3155          void year_blink(UINT8 i)
3156          {
3157   1          if(time1_second==1)
3158   1          {
3159   2            if(blink_flag)
3160   2            {
3161   3            blink_flag=0;
3162   3              FD612_display_4DIG_input( dis[2] ,dis[0] ,dis[time.year/10]  ,dis[time.year%10] );
3163   3            }
3164   2            else
3165   2            {
3166   3              blink_flag=1;
3167   3              if(i==0)
3168   3              FD612_display_4DIG_input( 0x00 ,0x00 ,0x00 ,0x00 );
3169   3            }
3170   2            time1_second=0;
3171   2          }
3172   1      }
3173          
3174          
3175          void from_ds1302_read_time_data(void)
3176          {
3177   1        //        UINT8 pm_flag;
3178   1            ResetDS1302();  
3179   1            WriteByteDS1302(0xbf);                                          //以多字节方式读取时钟寄存器数据
3180   1            time.second=ReadByteDS1302();
3181   1            time.minute=ReadByteDS1302();
3182   1            time.hour=ReadByteDS1302();
3183   1            time.mday=ReadByteDS1302();
3184   1            time.month=ReadByteDS1302();
3185   1            time.week=ReadByteDS1302();
3186   1            time.year=ReadByteDS1302();
3187   1            ResetDS1302();
3188   1            if(hour_12_24_flag==1)
3189   1            {
3190   2             if((time.hour&0x20)&&(time.hour&0x80))
3191   2               { 
3192   3                 hour_pm_flag=1;
3193   3               }
3194   2               else 
3195   2               {                 
3196   3                 hour_pm_flag=0;
3197   3               }
3198   2              time.hour<<=3;
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 53  

3199   2              time.hour>>=3;
3200   2      //        time.hour &=~(1<<7);
3201   2      //        time.hour &=~(1<<5);
3202   2      //         ResetDS1302();             
3203   2      //         WriteByteDS1302(hour_r_addr); //读取时的地址
3204   2      //         pm_flag=ReadByteDS1302();
3205   2      //         if((pm_flag&0x20)&&(pm_flag&0x80))
3206   2      //         { 
3207   2      //           hour_pm_flag=1;
3208   2      //         }
3209   2      //         else 
3210   2      //         {                 
3211   2      //           hour_pm_flag=0;
3212   2      //         }        
3213   2            }
3214   1            time.year = bcd_decimal(time.year); 
3215   1            time.month =bcd_decimal(time.month);
3216   1            time.mday = bcd_decimal(time.mday);
3217   1            time.week = bcd_decimal(time.week);
3218   1            time.hour = bcd_decimal(time.hour);
3219   1            time.minute = bcd_decimal(time.minute);
3220   1            time.second = bcd_decimal(time.second);
3221   1      }
3222          
3223          
3224          void InitDS1302(void)
3225          {   
3226   1            unsigned char year,month,mday,week,hour,minute,second ;
3227   1            year = decimal_bcd(year_init); 
3228   1            month =decimal_bcd(month_init);
3229   1            mday = decimal_bcd(mday_init);
3230   1            week = decimal_bcd(week_init);
3231   1            hour = decimal_bcd(hour_init);
3232   1            minute = decimal_bcd(minute_init);
3233   1            second = decimal_bcd(second_init);
3234   1            
3235   1            hour |= 1<<7;
3236   1            hour &=~ (1<<5);
3237   1            hour_12_24_flag=1;
3238   1            hour_pm_flag=0;
3239   1            ds1302_w_on();
3240   1      //      ResetDS1302();
3241   1      //      WriteByteDS1302(0x8e);                          //写保护控制寄存器
3242   1      //      WriteByteDS1302(0x0);                           //允许写入
3243   1            
3244   1            ResetDS1302();
3245   1            WriteByteDS1302(0x90);                          //写涓流充电控制寄存器
3246   1            WriteByteDS1302(0xab);                          //允许充电
3247   1            
3248   1            ResetDS1302();
3249   1            WriteByteDS1302(0xbe);                          //写多字节突发方式控制寄存器
3250   1            
3251   1            WriteByteDS1302(second);
3252   1            WriteByteDS1302(minute);
3253   1            WriteByteDS1302(hour);
3254   1            WriteByteDS1302(mday);
3255   1            WriteByteDS1302(month);
3256   1            WriteByteDS1302(week);
3257   1            WriteByteDS1302(year);
3258   1            WriteByteDS1302(0);                             //对写保护控制寄存器写入0
3259   1            ResetDS1302();
3260   1            ds1302_w_off();
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 54  

3261   1          
3262   1      //      from_ds1302_read_time_data();
3263   1            
3264   1                
3265   1      }
3266          
3267          
3268          
3269          void point_blink(void)
3270          {
3271   1      
3272   1                                      
3273   1            FD612_PotiveTNage(FD612_DIG1_ADDR,dis[time.hour/10]);
3274   1            FD612_PotiveTNage(FD612_DIG2_ADDR,dis[time.hour% 10]);
3275   1            FD612_PotiveTNage(FD612_DIG3_ADDR,dis[time.minute/10]);
3276   1            FD612_PotiveTNage(FD612_DIG4_ADDR,dis[time.minute% 10]);
3277   1            FD612_DispBuff.DispData[FD612_DIG12_ADDR] |= (1<<1);                
3278   1            if(hour_pm_flag==1)
3279   1              {                       
3280   2                  FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<0) ;
3281   2              }
3282   1              else 
3283   1              {                     
3284   2                  FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<0) ;                   
3285   2              }
3286   1              if(alarm1_on_dispaly ||alarm2_on_dispaly ||alarm3_on_dispaly)
3287   1              {
3288   2                FD612_DispBuff.DispData[FD612_DIG12_ADDR] |=(1<<3) ;
3289   2              }
3290   1              else
3291   1              {
3292   2                FD612_DispBuff.DispData[FD612_DIG12_ADDR] &=~(1<<3) ;
3293   2              }                   
3294   1              FD612_Refresh();
3295   1                      
3296   1      }
3297          
3298          void adc_switch(void)
3299          {
3300   1                  switch (ADC_Display)
3301   1                 {
3302   2                   
3303   2                   case 0:
3304   2                   {
3305   3                      
3306   3                     
3307   3                     //FD612_display_4DIG_input(0x00,dis[(unsigned char)TEM2/10],dis[(unsigned char)TEM2%10],FD612_DISP
             -_C);   
3308   3                      FD612_PotiveTNage(FD612_DIG1_ADDR,0x00);
3309   3                      FD612_PotiveTNage(FD612_DIG2_ADDR,dis[(unsigned char)TEM2/10]);
3310   3                      FD612_PotiveTNage(FD612_DIG3_ADDR,dis[(unsigned char)TEM2%10]);
3311   3                      FD612_PotiveTNage(FD612_DIG4_ADDR,FD612_DISP_cc);
3312   3                      FD612_DispBuff.DispData[FD612_DIG12_ADDR]|= 1<<6 ; 
3313   3                      FD612_Refresh();
3314   3                     ADC_Display1=0;
3315   3                     break;
3316   3                   }
3317   2                    
3318   2      
3319   2                    case 1:
3320   2                    {
3321   3                      
C51 COMPILER V9.52.0.0   USR                                                               01/31/2018 17:38:08 PAGE 55  

3322   3      //              ADC_AVG_NUM[2]   = (unsigned char)TEM4/100;
3323   3      //              ADC_AVG_NUM[1]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )/10;
3324   3      //              ADC_AVG_NUM[0]   = ((unsigned char)TEM4-ADC_AVG_NUM[2]*100 )%10;
3325   3      //              FD612_display_4DIG_input(dis[ADC_AVG_NUM[2]],dis[ADC_AVG_NUM[1]],dis[ADC_AVG_NUM[0]],FD612_DISP_F
             -);
3326   3                    FD612_PotiveTNage(FD612_DIG1_ADDR,dis[(unsigned char)TEM4/100]);
3327   3                    FD612_PotiveTNage(FD612_DIG2_ADDR,dis[(unsigned char)TEM4%100/10]);
3328   3                    FD612_PotiveTNage(FD612_DIG3_ADDR,dis[(unsigned char)TEM4%100%10]);
3329   3                      FD612_PotiveTNage(FD612_DIG4_ADDR,FD612_DISP_F);
3330   3      
3331   3                    FD612_Refresh();  
3332   3                      ADC_Display1=1;
3333   3      //                ADC_Display=0;
3334   3                      break;
3335   3                    } 
3336   2                      default :
3337   2                      break;
3338   2                }
3339   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10631    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    136      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
